<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/28/css%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    <url>/2022/03/28/css%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs applescript">    &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;左&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;中&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;右&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>.content  postiton: relative<br>left  position:absolute <span class="hljs-number">200</span>px<br>left <span class="hljs-number">0</span><br>right position:absolute <span class="hljs-number">200</span>px<br>right <span class="hljs-number">0</span><br><br>center<br>left <span class="hljs-number">200</span>px<br>right <span class="hljs-number">200</span>px<br></code></pre></td></tr></table></figure><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JS Bin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.outer</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;</span><br><span class="css">&#125;</span><br><span class="css"><span class="hljs-selector-class">.outer</span> &gt; <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">float</span>: right;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00f</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;</span><br><span class="css">    <span class="hljs-attribute">overflow</span>: hidden;  <span class="hljs-comment">/*重点*/</span></span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JS Bin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.outer</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">&#125;</span><br><span class="css"><span class="hljs-selector-class">.outer</span> &gt; <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00f</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JS Bin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">display</span>: grid;</span><br><span class="css">            grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">200px</span> auto <span class="hljs-number">200px</span>;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">        <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">            <span class="hljs-attribute">background-color</span>: green;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">        <span class="hljs-selector-class">.center</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#999</span>;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">        <span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">            <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>中<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/28/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url/"/>
    <url>/2022/03/28/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url/</url>
    
    <content type="html"><![CDATA[<ul><li>DNS解析  将域名解析成IP地址</li><li>tcp 连接: tcp三次握手</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>断开连接 TCP四次挥手</li></ul><h4 id="什么是url-—-统一资源定位符，用于定位互联网上资源，俗称网址"><a href="#什么是url-—-统一资源定位符，用于定位互联网上资源，俗称网址" class="headerlink" title="什么是url?              — 统一资源定位符，用于定位互联网上资源，俗称网址"></a>什么是url?              — 统一资源定位符，用于定位互联网上资源，俗称网址</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">scheme       - 定义因特网服务的类型。常见的协议有 <span class="hljs-keyword">http</span>、<span class="hljs-keyword">https</span>、<span class="hljs-keyword">ftp</span>、<span class="hljs-built_in">file</span>，<br>               其中最常见的类型是 <span class="hljs-keyword">http</span>，而 <span class="hljs-keyword">https</span> 则是进行加密的网络传输。<br>host         - 定义域主机（<span class="hljs-keyword">http</span> 的默认主机是 www）<br>domain       - 定义因特网域名，比如 baidu.com<br>port         - 定义主机上的端口号（<span class="hljs-keyword">http</span> 的默认端口号是 <span class="hljs-number">80</span>）<br>path         - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。<br>filename     - 定义文档/资源的名称<br>query        - 即查询参数<br>fragment     - 即 <span class="hljs-comment"># 后的hash值，一般用来定位到某个位置</span><br></code></pre></td></tr></table></figure><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p><ul><li>IP 地址</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">IP</span> 地址是指互联网协议地址，是 <span class="hljs-built_in">IP</span> Address 的缩写。<span class="hljs-built_in">IP</span> 地址是 <span class="hljs-built_in">IP</span> 协议提供的一种统一的地址格式，<br>它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>什么是域名解析</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">DNS 协议提供通过域名查找<span class="hljs-built_in"> IP </span>地址，或逆向从<span class="hljs-built_in"> IP </span>地址反查域名的服务。<span class="hljs-built_in"></span><br><span class="hljs-built_in">DNS </span>是一个网络服务器，我们的域名解析简单来说就是在<span class="hljs-built_in"> DNS </span>上记录一条信息记录。<br></code></pre></td></tr></table></figure><ul><li>浏览器如何通过域名去查询 URL 对应的 IP 呢？</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">DNS域名解析分为递归查询和迭代查询两种方式，现一般为迭代查询。<br></code></pre></td></tr></table></figure><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692e4385f72aae4~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口<code>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</code></li><li>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息<code>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</code></li><li>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”<code>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</code></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gcode">用户界面    <span class="hljs-comment">(User Interface)</span>    － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分<br><br>浏览器引擎  <span class="hljs-comment">(Browser Engine)</span>    － 用来查询及操作渲染引擎的接口<br><br>渲染引擎    <span class="hljs-comment">(Rendering Engine)</span>  － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来<br><br>网络        <span class="hljs-comment">(Networking)</span>        － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作<br><br>JS解释器    <span class="hljs-comment">(JS Interpreter)</span>    － 用来解释执行JS代码<br><br>UI后端      <span class="hljs-comment">(UI Backend)</span>        － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口<br><br>数据存储    <span class="hljs-comment">(DB Persistence)</span>    － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML<span class="hljs-number">5</span>定义了web database技术，这是一种轻量级完整的客户端存储技术<br><br></code></pre></td></tr></table></figure><blockquote><p>总是要问：为什么需要三次握手，两次不行吗？其实这是由TCP的自身特点<strong>可靠传输</strong>决定的。客户端和服务端要进行可靠传输，那么就需要<strong>确认双方的<code>接收</code>和<code>发送</code>能力</strong>。第一次握手可以确认客服端的<code>发送能力</code>,第二次握手，服务端<code>SYN=1,Seq=Y</code>就确认了<code>发送能力</code>,<code>ACK=X+1</code>就确认了<code>接收能力</code>,所以第三次握手才可以确认客户端的<code>接收能力</code>。不然容易出现丢包的现象。</p></blockquote><h4 id="第三次握手的必要性？"><a href="#第三次握手的必要性？" class="headerlink" title="第三次握手的必要性？"></a>第三次握手的必要性？</h4><p>试想如果是用两次握手，则会出现下面这种情况： 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><h4 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h4><ul><li>Browser进程浏览器的主进程</li><li>第三方插件进程</li><li>Gpu进程  用于3D渲染</li><li>浏览器渲染内核</li></ul><h4 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h4><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：</p><ol><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ol><h3 id="浏览器内核拿到内容后，渲染步骤大致可以分为以下几步："><a href="#浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：" class="headerlink" title="浏览器内核拿到内容后，渲染步骤大致可以分为以下几步："></a>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 解析HTML，构建DOM树<br><br><span class="hljs-bullet">2.</span> 解析CSS，生成CSS规则树<br><br><span class="hljs-bullet">3.</span> 合并DOM树和CSS规则，生成render树<br><br><span class="hljs-bullet">4.</span> 布局render树（Layout/reflow），负责各元素尺寸、位置的计算<br><br><span class="hljs-bullet">5.</span> 绘制render树（paint），绘制页面像素信息<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">以webkit内核为例<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692e6c31379adc6~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="1-HTML解析，构建DOM"><a href="#1-HTML解析，构建DOM" class="headerlink" title="1. HTML解析，构建DOM"></a>1. HTML解析，构建DOM</h4><p>简单的理解，这一步的流程是这样的：浏览器解析HTML，构建DOM树。 解析HTML到构建出DOM当然过程可以简述如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Bytes → <span class="hljs-built_in">characters</span> → tokens → nodes → DOM<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f37de1ac505e~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">其中比较关键的几个步骤<br><span class="hljs-number">1.</span> <span class="hljs-keyword">Conversion</span>转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符<br><br><span class="hljs-number">2.</span> Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集<br><br><span class="hljs-number">3.</span> Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则<br><br><span class="hljs-number">4.</span> DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样<br>例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象<br></code></pre></td></tr></table></figure><h4 id="2-解析CSS，生成CSS规则树"><a href="#2-解析CSS，生成CSS规则树" class="headerlink" title="2. 解析CSS，生成CSS规则树"></a>2. 解析CSS，生成CSS规则树</h4><p>同理，CSS规则树的生成也是类似。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Bytes → <span class="hljs-built_in">characters</span> → tokens → nodes → CSSOM<br>复制代码<br></code></pre></td></tr></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f392c69b8b3c~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="3-合并DOM树和CSS规则，生成render树"><a href="#3-合并DOM树和CSS规则，生成render树" class="headerlink" title="3. 合并DOM树和CSS规则，生成render树"></a>3. 合并DOM树和CSS规则，生成render树</h4><p>当DOM树和CSSOM都有了后，就要开始构建渲染树了</p><p>一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应,因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f39d1fa1584e~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="4-布局render树（Layout-Reflow），负责各元素尺寸、位置的计算"><a href="#4-布局render树（Layout-Reflow），负责各元素尺寸、位置的计算" class="headerlink" title="4. 布局render树（Layout/Reflow），负责各元素尺寸、位置的计算"></a>4. 布局render树（Layout/Reflow），负责各元素尺寸、位置的计算</h4><p>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。</p><h4 id="5-绘制render树（Paint），绘制页面像素信息"><a href="#5-绘制render树（Paint），绘制页面像素信息" class="headerlink" title="5. 绘制render树（Paint），绘制页面像素信息"></a>5. 绘制render树（Paint），绘制页面像素信息</h4><p>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f3e3ca738411~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这张图片中重要的四个步骤<br><span class="hljs-bullet">1.</span> 计算CSS样式<br><br><span class="hljs-bullet">2.</span> 构建渲染树<br><br><span class="hljs-bullet">3.</span> 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性<br><br><span class="hljs-bullet">4.</span> 绘制，将图像绘制出来<br>复制代码<br></code></pre></td></tr></table></figure><ul><li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li><li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul><h2 id="七、断开连接"><a href="#七、断开连接" class="headerlink" title="七、断开连接"></a>七、断开连接</h2><p>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/27/1692f41b21b32870~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。 <code>(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</code></li><li>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。 <code>(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</code></li><li>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。 <code>(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</code></li><li>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。 <code>(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</code></li></ul><h3 id="挥手为什么需要四次？"><a href="#挥手为什么需要四次？" class="headerlink" title="挥手为什么需要四次？"></a>挥手为什么需要四次？</h3><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p><h3 id="为什么客户端发送ACK之后不直接关闭，而是要等一阵子才关闭？"><a href="#为什么客户端发送ACK之后不直接关闭，而是要等一阵子才关闭？" class="headerlink" title="为什么客户端发送ACK之后不直接关闭，而是要等一阵子才关闭？"></a>为什么客户端发送ACK之后不直接关闭，而是要等一阵子才关闭？</h3><p>客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。</p><h3 id="为什么TIME-WAIT状态需要经过2MSL（最大报文生存时间）才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL（最大报文生存时间）才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL（最大报文生存时间）才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL（最大报文生存时间）才能返回到CLOSE状态？</h3><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端； 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/03/28/IOS%E8%B8%A9%E5%9D%91%20%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%AD%A3%E5%88%99%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80/"/>
    <url>/2022/03/28/IOS%E8%B8%A9%E5%9D%91%20%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%AD%A3%E5%88%99%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="踩坑记：ios不兼容正则后行断言"><a href="#踩坑记：ios不兼容正则后行断言" class="headerlink" title="踩坑记：ios不兼容正则后行断言"></a>踩坑记：ios不兼容正则后行断言</h1><h4 id="包括-微信小程序-IOS-还有Safari"><a href="#包括-微信小程序-IOS-还有Safari" class="headerlink" title="包括: 微信小程序,IOS,还有Safari"></a>包括: 微信小程序,IOS,还有Safari</h4><h3 id="简单尝试打包Android-APP"><a href="#简单尝试打包Android-APP" class="headerlink" title="简单尝试打包Android   APP"></a>简单尝试打包Android   APP</h3><ul><li>使用 HBuilder</li><li>创建项目</li></ul><p><img src="http://lxandzjy.top:9003/2022/03/28/24c663ce24b06.png"></p><ul><li>把vue   npm run build 打包好的文件替换</li></ul><p><img src="http://lxandzjy.top:9003/2022/03/28/548a4687d11f8.png"></p><ul><li>右键项目—-原生App云打包</li><li>完成</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 执行机制</title>
    <link href="/2021/12/03/JavaScript%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/12/03/JavaScript%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="关于javascript"><a href="#关于javascript" class="headerlink" title="关于javascript"></a>关于javascript</h3><p>javascript是一门<strong>单线程</strong>语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p><h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>js的单线程，就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。</p><h3 id="同步与异步的概念"><a href="#同步与异步的概念" class="headerlink" title="同步与异步的概念"></a>同步与异步的概念</h3><blockquote><p>为什么要区分同步与异步？</p><p>因为Js是单线程的，如果全都是同步任务的话，主线程就被<code>阻塞</code>了。比如发送一个AJAX请求，如果它是同步的话，那么在等待服务器响应的过程中整个主线程就被阻塞了，其他任务都无法被执行。</p><p>就像人在散步的过程中，不可能全程只走路。不观察四周有没有认识的人、突然驶来的车。</p></blockquote><blockquote><p>什么是同步函数？什么是异步函数？</p><p>简单来说，同步函数按照顺序执行，且在执行后能<code>立即</code>获得结果。</p><p>异步函数调用后马上返回，但是<code>不会马上返回结果</code>，调用者无需阻塞等待，当函数得到结果后会通过<code>回调函数</code>主动通知调用者。</p></blockquote><p><strong>当我们打开网页时,网页的渲染过程就是一大堆同步任务,比如页面骨架和页面元素的渲染.而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务</strong></p><p><img src="http://lxandzjy.top:9003/2021/12/02/55afb9b92819e.png"></p><p><strong>上图的意思就是</strong></p><ul><li>同步和异步任务分别进入不同的执行”场所”,同步的进入到主线程,异步的进入Event Table并注册函数</li><li>当指定的事情完成之后Event Table 会将函数移入到Event Queue</li><li>主线程执行完毕,会去Event Queue读取对应的函数,进入主线程执行</li><li>上述过程会不断的重复,也就是Event Loop (事件循环)</li></ul><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。</p><h3 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h3><ul><li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有IE10支持，具体可见<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate"><code>MDN</code></a>）、<code>I/O</code>、<code>UI Rendering</code>。</li></ul><h3 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h3><ul><li><code>Process.nextTick（Node独有）</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code></li></ul><p><img src="http://lxandzjy.top:9003/2021/12/02/1824ce40c3b8b.png"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">Promise</span>.resolve()<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>  &#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>);<br><br><span class="hljs-comment">// 运行结果为</span><br>script start<br>script end<br>promise1<br>promise2<br><span class="hljs-built_in">setTimeout</span><br></code></pre></td></tr></table></figure><blockquote><p>结果  script start    script end        promise1    promise2    setTimeout</p><p>分析 </p><ul><li>先执行宏任务script start     script end</li><li>然后执行微任务,遇到新的微任务promise1、promise2</li><li>最后异步宏任务setTimeout</li></ul></blockquote><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br><br><span class="hljs-comment">// Let&#x27;s get hold of those elements</span><br><span class="hljs-keyword">var</span> outer = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.outer&#x27;</span>);<br><span class="hljs-keyword">var</span> inner = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.inner&#x27;</span>);<br><br><span class="hljs-comment">// Let&#x27;s listen for attribute changes on the</span><br><span class="hljs-comment">// outer element</span><br><span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mutate&#x27;</span>);<br>&#125;).observe(outer, &#123;<br>  <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br><br><span class="hljs-comment">// Here&#x27;s a click listener…</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;click&#x27;</span>);<br><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);<br>  &#125;);<br><br>  outer.setAttribute(<span class="hljs-string">&#x27;data-random&#x27;</span>, <span class="hljs-built_in">Math</span>.random());<br>&#125;<br><br><span class="hljs-comment">// …which we&#x27;ll attach to both elements</span><br>inner.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, onClick);<br>outer.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, onClick);<br></code></pre></td></tr></table></figure><blockquote><p>点击inner盒子,  结果 click    promise    mutate    click    promise    mutate    timeout    timeout</p><p>点击outer盒子,  结果  click    promise    mutate    timeout</p><p>分析 </p><ul><li>点击inner 触发点击事件,打印click, 异步宏任务setTimeout加入队列</li><li>Promise微任务执行 打印promise,</li><li>设置属性,触发MutationObserver 打印mutate</li><li>外层outer触发事件, 打印click</li><li>异步宏任务setTimeout加入队列</li><li>Promise微任务执行 打印promise</li><li>设置属性,触发MutationObserver 打印mutate</li><li>setTimeout 打印timeout</li><li>setTimeout 打印timeout</li></ul></blockquote><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise1&#x27;</span>)  <br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout2&#x27;</span>)<br>  &#125;,<span class="hljs-number">0</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout1&#x27;</span>)<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise2&#x27;</span>)    <br>  &#125;)<br>&#125;,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><blockquote><p>结果：Promise1、setTimeout1、Promise2、setTimeout2</p><p>分析：</p><ol><li>没有同步任务，先执行微任务，打印Promise1</li><li>执行异步宏任务回调函数setTimeout1</li><li>执行微任务 打印Promise2</li><li>执行异步宏任务回调函数setTimeout2</li></ol></blockquote><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>    <span class="hljs-keyword">await</span> async2();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>async1();<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);<br>    resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script end&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>结果：script start、async1 start、async2、promise1、script end、promise2、async1 end、setTimeout</p><p>分析：</p><ol><li>同步：script start、async1 start、async2、promise1、script end</li><li>微任务：promise2</li><li>同步：async1 end、setTimeout</li></ol><p>tip: </p><ul><li>await 阻塞后面的代码,其后的相当于异步宏任务setTimeout</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS修改滚动条样式</title>
    <link href="/2021/11/25/css%E4%BF%AE%E6%94%B9%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/11/25/css%E4%BF%AE%E6%94%B9%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS修改滚动条样式"><a href="#CSS修改滚动条样式" class="headerlink" title="CSS修改滚动条样式"></a>CSS修改滚动条样式</h2><h2 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*修改滚动条样式*/</span><br><span class="hljs-selector-tag">div</span>::-webkit-scrollbar&#123;<br>  width:<span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">10px</span>;<br>  <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-selector-tag">div</span>::-webkit-scrollbar-track&#123;<br>  background: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">239</span>, <span class="hljs-number">239</span>, <span class="hljs-number">239</span>);<br>  <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">2px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span>::-webkit-scrollbar-thumb&#123;<br>  background: <span class="hljs-number">#bfbfbf</span>;<br>  <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">10px</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span>::-webkit-scrollbar-thumb:hover&#123;<br>  background: <span class="hljs-number">#333</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span>::-webkit-scrollbar-corner&#123;<br>  background: <span class="hljs-number">#179a16</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">:</span><span class="hljs-symbol">:-webkit-scrollbar</span> 滚动条整体部分<br><span class="hljs-symbol">:</span><span class="hljs-symbol">:-webkit-scrollbar-thumb</span>  滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）<br><span class="hljs-symbol">:</span><span class="hljs-symbol">:-webkit-scrollbar-track</span>  滚动条的轨道（里面装有Thumb）<br><span class="hljs-symbol">:</span><span class="hljs-symbol">:-webkit-scrollbar-button</span> 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。<br><span class="hljs-symbol">:</span><span class="hljs-symbol">:-webkit-scrollbar-track-piece</span> 内层轨道，滚动条中间部分（除去）<br><span class="hljs-symbol">:</span><span class="hljs-symbol">:-webkit-scrollbar-corner</span> 边角，即两个滚动条的交汇处<br><span class="hljs-symbol">:</span><span class="hljs-symbol">:-webkit-resizer</span> 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数作用域,闭包</title>
    <link href="/2021/11/12/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F,%E9%97%AD%E5%8C%85/"/>
    <url>/2021/11/12/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F,%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript的作用域分为？</p><ul><li>全局作用域：在最外层定义、未定义直接赋值、window对象属性定义的变量拥有全局作用域</li><li>函数作用域：指声明在函数内部的变量</li><li>块级作用域：ES6引入的let/const</li></ul><p>函数作用域有诸多弊端，故ES6引入了let/const声明块级作用域让变量的生命周期更可控</p></blockquote><blockquote><p>块级作用域在什么时候被创建？</p><ul><li>函数内部</li><li>代码块(花括号{})内部</li></ul></blockquote><blockquote><p>let/const声明的变量有什么特点？</p><ul><li>声明的变量不会被提升</li><li>重复声明被禁止</li><li>块级作用域，作用域被限制在函数/代码块内部</li></ul></blockquote><blockquote><p>什么叫作用域链？</p><p>当在当前作用域未找到该变量，则会通过作用域链向父级继续寻找该变量，直到全局作用域。这种一层层寻找的关系，就叫作用域链。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">200</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F2</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> c = <span class="hljs-number">300</span><br>        <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// 沿着作用域链向父作用域找</span><br>        <span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 沿着作用域链向父作用域找</span><br>        <span class="hljs-built_in">console</span>.log(c) <span class="hljs-comment">// 本地变量</span><br>    &#125;<br>    F2()<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>JavaScript的作用域是<code>静态作用域</code>，即变量取值是从<code>创建函数</code>的域中取而不是从<code>调用的地方取</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 根据函数创建的地方的作用域来获取变量而不是通过调用它的地方</span><br>        <span class="hljs-built_in">console</span>.log(a + b + c) <span class="hljs-comment">// 10 + 20 + 40 = 70</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> bar()<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">200</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">1000</span><br>fn()<br></code></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>为什么会出现闭包？</p><p>闭包的出现是因为JavaScript可以将<code>函数作为返回值</code>，这时候就出现了一个问题：父作用域已经被销毁了，子函数要使用父函数作用域内的变量怎么办？所以出现了闭包。</p></blockquote><blockquote><p>闭包的原理</p><p>当返回的函数里面有父作用域变量时，肯定不能保留父作用域所有变量，那肯定会出问题。所以取了一个折中的办法：</p><p>再创建一个对象[[Scopes]]存放函数需要的环境</p></blockquote><p><strong>闭包就是能够读取其他函数内部变量的函数。</strong></p><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p><strong>闭包的用途</strong></p><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br><br>　　　　nAdd=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;n+=<span class="hljs-number">1</span>&#125;<br><br>　　　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　alert(n);<br>　　　　&#125;<br><br>　　　　<span class="hljs-keyword">return</span> f2;<br><br>　　&#125;<br><br>　　<span class="hljs-keyword">var</span> result=f1();<br><br>　　result(); <span class="hljs-comment">// 999</span><br><br>　　nAdd();<br><br>　　result(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><p><strong>使用闭包的注意点</strong></p><ul><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p></li><li><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">　　<span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><br>　　<span class="hljs-keyword">var</span> object = &#123;<br>　　　　<span class="hljs-attr">name</span> : <span class="hljs-string">&quot;My Object&quot;</span>,<br><br>　　　　<span class="hljs-attr">getNameFunc</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>　　　　　　&#125;;<br><br>　　　　&#125;<br><br>　　&#125;;<br><br>　　alert(object.getNameFunc()());  <span class="hljs-comment">// The Window</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">　　<span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><br>　　<span class="hljs-keyword">var</span> object = &#123;<br>　　　　<span class="hljs-attr">name</span> : <span class="hljs-string">&quot;My Object&quot;</span>,<br><br>　　　　<span class="hljs-attr">getNameFunc</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　<span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　　　　　　<span class="hljs-keyword">return</span> that.name;<br>　　　　　　&#125;;<br><br>　　　　&#125;<br><br>　　&#125;;<br><br>　　alert(object.getNameFunc()());   <span class="hljs-comment">// My Object</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack实战</title>
    <link href="/2021/11/10/webpack%E5%AE%9E%E6%88%98/"/>
    <url>/2021/11/10/webpack%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1-1-初始化项目"><a href="#1-1-初始化项目" class="headerlink" title="1.1 初始化项目"></a>1.1 初始化项目</h4><p>新建一个目录，初始化npm</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br></code></pre></td></tr></table></figure><p>webpack是运行在node环境中的,我们需要安装以下两个npm包</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i -D webpack webpack-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ul><li>npm i -D 为npm install –save-dev的缩写</li><li>npm i -S 为npm install –save的缩写</li></ul><p>新建一个文件夹<code>src</code> ,然后新建一个文件<code>main.js</code>,写一点代码测试一下</p><p>​    <img src="http://lxandzjy.top:9003/2021/11/17/0e1611dd10763.png"></p><h3 id="1-2-开始我们自己的配置"><a href="#1-2-开始我们自己的配置" class="headerlink" title="1.2 开始我们自己的配置"></a>1.2 开始我们自己的配置</h3><p>上面一个简单的例子只是webpack自己默认的配置，下面我们要实现更加丰富的自定义配置<br>新建一个<code>build</code>文件夹,里面新建一个<code>webpack.config.js</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br><br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>module.exports = &#123;<br>    mode:<span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-regexp">//</span> 开发模式<br>    entry: path.resolve(__dirname,<span class="hljs-string">&#x27;../src/main.js&#x27;</span>),    <span class="hljs-regexp">//</span> 入口文件<br>    output: &#123;<br>        filename: <span class="hljs-string">&#x27;output.js&#x27;</span>,      <span class="hljs-regexp">//</span> 打包后的文件名称<br>        path: path.resolve(__dirname,<span class="hljs-string">&#x27;../dist&#x27;</span>)  <span class="hljs-regexp">//</span> 打包后的目录<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-3-配置html模板"><a href="#1-3-配置html模板" class="headerlink" title="1.3 配置html模板"></a>1.3 配置html模板</h3><p>js文件打包好了,但是我们不可能每次在<code>html</code>文件中手动引入打包好的js</p><blockquote><p>这里可能有的朋友会认为我们打包js文件名称不是一直是固定的嘛(output.js)？这样每次就不用改动引入文件名称了呀？实际上我们日常开发中往往会这样配置:</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">module.exports = &#123;<br>    <span class="hljs-regexp">//</span> 省略其他配置<br>    output: &#123;<br>      filename: <span class="hljs-string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="hljs-regexp">//</span> 打包后的文件名称<br>      path: path.resolve(__dirname,<span class="hljs-string">&#x27;../dist&#x27;</span>)  <span class="hljs-regexp">//</span> 打包后的目录<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了缓存，你会发现打包好的js文件的名称每次都不一样。webpack打包出来的js文件我们需要引入到html中，但是每次我们都手动修改js文件名显得很麻烦，因此我们需要一个插件来帮我们完成这件事情</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm <span class="hljs-selector-tag">i</span> -D <span class="hljs-selector-tag">html</span>-webpack-plugin<br></code></pre></td></tr></table></figure><p>新建一个<code>build</code>同级的文件夹<code>public</code>,里面新建一个index.html<br> 具体配置文件如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-comment">// 开发模式</span><br>    <span class="hljs-attr">entry</span>: path.resolve(__dirname,<span class="hljs-string">&#x27;../src/main.js&#x27;</span>),    <span class="hljs-comment">// 入口文件</span><br>    <span class="hljs-attr">output</span>: &#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="hljs-comment">// 打包后的文件名称</span><br>      <span class="hljs-attr">path</span>: path.resolve(__dirname,<span class="hljs-string">&#x27;../dist&#x27;</span>)  <span class="hljs-comment">// 打包后的目录</span><br>    &#125;,<br>    <span class="hljs-attr">plugins</span>:[<br>      <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>        <span class="hljs-attr">template</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;../public/index.html&#x27;</span>)<br>      &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-1-多入口文件如何开发"><a href="#1-3-1-多入口文件如何开发" class="headerlink" title="1.3.1 多入口文件如何开发"></a>1.3.1 多入口文件如何开发</h4><blockquote><p>生成多个html-webpack-plugin实例来解决这个问题</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-comment">// 开发模式</span><br>    <span class="hljs-attr">entry</span>: &#123;<br>      <span class="hljs-attr">main</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;../src/main.js&#x27;</span>),<br>      <span class="hljs-attr">header</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;../src/header.js&#x27;</span>)<br>  &#125;, <br>    <span class="hljs-attr">output</span>: &#123;<br>      <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="hljs-comment">// 打包后的文件名称</span><br>      <span class="hljs-attr">path</span>: path.resolve(__dirname,<span class="hljs-string">&#x27;../dist&#x27;</span>)  <span class="hljs-comment">// 打包后的目录</span><br>    &#125;,<br>    <span class="hljs-attr">plugins</span>:[<br>      <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>        <span class="hljs-attr">template</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;../public/index.html&#x27;</span>),<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;index.html&#x27;</span>,<br>        <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;main&#x27;</span>] <span class="hljs-comment">// 与入口文件对应的模块名</span><br>      &#125;),<br>      <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>        <span class="hljs-attr">template</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;../public/header.html&#x27;</span>),<br>        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;header.html&#x27;</span>,<br>        <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;header&#x27;</span>] <span class="hljs-comment">// 与入口文件对应的模块名</span><br>      &#125;),<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-clean-webpack-plugin"><a href="#1-3-2-clean-webpack-plugin" class="headerlink" title="1.3.2 clean-webpack-plugin"></a>1.3.2 clean-webpack-plugin</h4><blockquote><p>每次执行npm run build 会发现dist文件夹里会残留上次打包的文件，这里我们推荐一个plugin来帮我们在打包输出前清空文件夹<code>clean-webpack-plugin</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">const</span> &#123;CleanWebpackPlugin&#125; = require(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>    <span class="hljs-comment">// ...省略其他配置</span><br>    plugins:[<span class="hljs-keyword">new</span> CleanWebpackPlugin()]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-引用CSS"><a href="#1-4-引用CSS" class="headerlink" title="1.4 引用CSS"></a>1.4 引用CSS</h3><p>我们的入口文件是js，所以我们在入口js中引入我们的css文件</p><p><img src="http://lxandzjy.top:9003/2021/11/17/55834c91a5e45.png"></p><p>同时我们也需要一些loader来解析我们的css文件 scss文件</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install -D sass-loader <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> style-loader css-loader<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>test:<span class="hljs-regexp">/\.css$/</span>,<br>use:[<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>] <span class="hljs-regexp">//</span> 从右向左解析原则<br>&#125;,<br>&#123;<br>    test: <span class="hljs-regexp">/\.scss$/</span>,<br>    use:[ <span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>,<span class="hljs-string">&#x27;postcss-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>],<br>&#125;,<br>&#123;<br>    test: <span class="hljs-regexp">/\.(jpe?g|png|gif)$/i</span>, <span class="hljs-regexp">//</span>图片文件<br>    use: [<br>      &#123;<br>        loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>        options: &#123;<br>          limit: <span class="hljs-number">10240</span>,<br>          fallback: &#123;<br>            loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>            options: &#123;<br>                name: <span class="hljs-string">&#x27;img/[name].[hash:8].[ext]&#x27;</span><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    ]<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="1-5-打包-图片、字体、媒体、等文件"><a href="#1-5-打包-图片、字体、媒体、等文件" class="headerlink" title="1.5 打包 图片、字体、媒体、等文件"></a>1.5 打包 图片、字体、媒体、等文件</h3><p><code>file-loader</code>就是将文件在进行一些处理后（主要是处理文件名和路径、解析文件url），并将文件移动到输出的目录中<br> <code>url-loader</code> 一般与<code>file-loader</code>搭配使用，功能与 file-loader 类似，如果文件小于限制的大小。则会返回 base64 编码，否则使用 file-loader 将文件移动到输出的目录中</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">//</span> <span class="hljs-string">webpack.config.js</span><br><span class="hljs-meta">module.exports</span> = <span class="hljs-string">&#123;</span><br>  <span class="hljs-meta">//</span> <span class="hljs-string">省略其它配置 ...</span><br>  <span class="hljs-attr">module</span>: <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">rules</span>: <span class="hljs-string">[</span><br>      <span class="hljs-meta">//</span> <span class="hljs-string">...</span><br>      <span class="hljs-attr">&#123;</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-string">/\.(jpe?g|png|gif)$/i, //图片文件</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">[</span><br>          <span class="hljs-attr">&#123;</span><br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;,</span><br>            <span class="hljs-attr">options</span>: <span class="hljs-string">&#123;</span><br>              <span class="hljs-attr">limit</span>: <span class="hljs-string">10240,</span><br>              <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#123;</span><br>                <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;,</span><br>                <span class="hljs-attr">options</span>: <span class="hljs-string">&#123;</span><br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;img/[name].[hash:8].[ext]&#x27;</span><br>                <span class="hljs-attr">&#125;</span><br>              <span class="hljs-attr">&#125;</span><br>            <span class="hljs-attr">&#125;</span><br>          <span class="hljs-attr">&#125;</span><br>        <span class="hljs-attr">]</span><br>      <span class="hljs-attr">&#125;,</span><br>      <span class="hljs-attr">&#123;</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-string">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/, //媒体文件</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">[</span><br>          <span class="hljs-attr">&#123;</span><br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;,</span><br>            <span class="hljs-attr">options</span>: <span class="hljs-string">&#123;</span><br>              <span class="hljs-attr">limit</span>: <span class="hljs-string">10240,</span><br>              <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#123;</span><br>                <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;,</span><br>                <span class="hljs-attr">options</span>: <span class="hljs-string">&#123;</span><br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;media/[name].[hash:8].[ext]&#x27;</span><br>                <span class="hljs-attr">&#125;</span><br>              <span class="hljs-attr">&#125;</span><br>            <span class="hljs-attr">&#125;</span><br>          <span class="hljs-attr">&#125;</span><br>        <span class="hljs-attr">]</span><br>      <span class="hljs-attr">&#125;,</span><br>      <span class="hljs-attr">&#123;</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-string">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i, // 字体</span><br>        <span class="hljs-attr">use</span>: <span class="hljs-string">[</span><br>          <span class="hljs-attr">&#123;</span><br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;,</span><br>            <span class="hljs-attr">options</span>: <span class="hljs-string">&#123;</span><br>              <span class="hljs-attr">limit</span>: <span class="hljs-string">10240,</span><br>              <span class="hljs-attr">fallback</span>: <span class="hljs-string">&#123;</span><br>                <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;,</span><br>                <span class="hljs-attr">options</span>: <span class="hljs-string">&#123;</span><br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;fonts/[name].[hash:8].[ext]&#x27;</span><br>                <span class="hljs-attr">&#125;</span><br>              <span class="hljs-attr">&#125;</span><br>            <span class="hljs-attr">&#125;</span><br>          <span class="hljs-attr">&#125;</span><br>        <span class="hljs-attr">]</span><br>      <span class="hljs-attr">&#125;,</span><br>    <span class="hljs-attr">]</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-用babel转义js文件"><a href="#1-6-用babel转义js文件" class="headerlink" title="1.6 用babel转义js文件"></a>1.6 用babel转义js文件</h3><p>为了使我们的js代码兼容更多的环境我们需要安装依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D babel-loader @babel/preset-env @babel/core<br></code></pre></td></tr></table></figure><ul><li>注意 <code>babel-loader</code>与<code>babel-core</code>的版本对应关系</li></ul><ol><li><code>babel-loader</code> 8.x 对应<code>babel-core</code> 7.x</li><li><code>babel-loader</code> 7.x 对应<code>babel-core</code> 6.x<br> 配置如下</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br>module.exports = &#123;<br>    <span class="hljs-regexp">//</span> 省略其它配置 ...<br>    module:&#123;<br>        rules:[<br>          &#123;<br>            test:<span class="hljs-regexp">/\.js$/</span>,<br>            use:&#123;<br>              loader:<span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>              options:&#123;<br>                presets:[<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>              &#125;<br>            &#125;,<br>            exclude:<span class="hljs-regexp">/node_modules/</span><br>          &#125;,<br>       ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code>babel-loader</code>只会将 ES6/7/8语法转换为ES5语法，但是对新api并不会转换 例如(promise、Generator、Set、Maps、Proxy等)<br> 此时我们需要借助babel-polyfill来帮助我们转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">npm i <span class="hljs-meta">@babel</span>/polyfill<br><br><span class="hljs-comment">// webpack.config.js</span><br><span class="hljs-keyword">const</span> path = require(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>    entry: [<span class="hljs-string">&quot;@babel/polyfill&quot;</span>,path.resolve(__dirname,<span class="hljs-string">&#x27;../src/index.js&#x27;</span>)],    <span class="hljs-comment">// 入口文件</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-搭建vue开发环境"><a href="#2-搭建vue开发环境" class="headerlink" title="2 搭建vue开发环境"></a>2 搭建vue开发环境</h2><p>上面的小例子已经帮助而我们实现了打包css、图片、js、html等文件。 但是我们还需要以下几种配置</p><h4 id="2-1-解析-vue文件"><a href="#2-1-解析-vue文件" class="headerlink" title="2.1 解析.vue文件"></a>2.1 解析.vue文件</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D vue-loader vue-template-compiler vue-style-loader<br><span class="hljs-built_in">npm</span> i -S vue<br></code></pre></td></tr></table></figure><p><code>vue-loader</code> 用于解析<code>.vue</code>文件<br> <code>vue-template-compiler</code> 用于编译模板 配置如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">const vueLoaderPlugin = require(<span class="hljs-string">&#x27;vue-loader/lib/plugin&#x27;</span>)<br>module.exports = &#123;<br>    module:&#123;<br>        rule<span class="hljs-variable">s:</span>[&#123;<br>            tes<span class="hljs-variable">t:</span>/\.vue$/,<br>            use:[<span class="hljs-string">&#x27;vue-loader&#x27;</span>]<br>        &#125;,]<br>     &#125;,<br>    <span class="hljs-built_in">resolve</span>:&#123;<br>        alia<span class="hljs-variable">s:</span>&#123;<br>          <span class="hljs-string">&#x27;vue$&#x27;</span>:<span class="hljs-string">&#x27;vue/dist/vue.runtime.esm.js&#x27;</span>,<br>          <span class="hljs-string">&#x27; @&#x27;</span>:path.<span class="hljs-built_in">resolve</span>(__dirname,<span class="hljs-string">&#x27;../src&#x27;</span>)<br>        &#125;,<br>        extension<span class="hljs-variable">s:</span>[<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;.js&#x27;</span>,<span class="hljs-string">&#x27;.json&#x27;</span>,<span class="hljs-string">&#x27;.vue&#x27;</span>]<br>   &#125;,<br>   plugin<span class="hljs-variable">s:</span>[<br>        <span class="hljs-keyword">new</span> vueLoaderPlugin()<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-配置webpack-dev-server进行热更新"><a href="#2-2-配置webpack-dev-server进行热更新" class="headerlink" title="2.2 配置webpack-dev-server进行热更新"></a>2.2 配置webpack-dev-server进行热更新</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm i -D webpack-dev-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>配置如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">const</span> Webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  <span class="hljs-comment">// ...省略其他配置</span><br>  devServer:&#123;<br>    port:<span class="hljs-number">3000</span>,<br>    hot:<span class="hljs-keyword">true</span>,<br>    contentBase:<span class="hljs-string">&#x27;../dist&#x27;</span><br>  &#125;,<br>  plugins:[<br>    <span class="hljs-keyword">new</span> Webpack.HotModuleReplacementPlugin()<br>  ]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>完整配置如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.config.js<br><br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br>const &#123;CleanWebpackPlugin&#125; = require(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br>const vueLoaderPlugin = require(<span class="hljs-string">&#x27;vue-loader/lib/plugin&#x27;</span>)<br>const Webpack = require(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><br><br>module.exports = &#123;<br>    mode:<span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-regexp">//</span> 开发模式<br>    entry: &#123;<br>        main:path.resolve(__dirname,<span class="hljs-string">&#x27;./src/main.js&#x27;</span>),<br>        <span class="hljs-regexp">//</span> header:path.resolve(__dirname,<span class="hljs-string">&#x27;./src/header.js&#x27;</span>)<br>    &#125;,    <span class="hljs-regexp">//</span> 入口文件<br>    output: &#123;<br>        filename: <span class="hljs-string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="hljs-regexp">//</span> 打包后的文件名称<br>        path: path.resolve(__dirname,<span class="hljs-string">&#x27;./dist&#x27;</span>)  <span class="hljs-regexp">//</span> 打包后的目录<br>    &#125;,<br>    devServer:&#123;<br>        port:<span class="hljs-number">3000</span>,<br>        hot:true,<br>    &#125;,<br>    plugins:[<br>        <span class="hljs-regexp">//</span> new HtmlWebpackPlugin(&#123;<br>        <span class="hljs-regexp">//</span>     filename:<span class="hljs-string">&#x27;index.html&#x27;</span>,<br>        <span class="hljs-regexp">//</span>     chunks:[<span class="hljs-string">&#x27;main&#x27;</span>] <span class="hljs-regexp">//</span> 与入口文件对应的模块名<br>        <span class="hljs-regexp">//</span> &#125;),<br>        <span class="hljs-regexp">//</span> new HtmlWebpackPlugin(&#123;<br>        <span class="hljs-regexp">//</span>     filename:<span class="hljs-string">&#x27;header.html&#x27;</span>,<br>        <span class="hljs-regexp">//</span>     chunks:[<span class="hljs-string">&#x27;header&#x27;</span>] <span class="hljs-regexp">//</span> 与入口文件对应的模块名<br>        <span class="hljs-regexp">//</span> &#125;),<br>        new HtmlWebpackPlugin(&#123;<br>          template:path.resolve(__dirname,<span class="hljs-string">&#x27;./public/index.html&#x27;</span>),<br>          filename:<span class="hljs-string">&#x27;index.html&#x27;</span><br>        &#125;),<br>        new CleanWebpackPlugin(),<br>        new vueLoaderPlugin(),<br>        new Webpack.HotModuleReplacementPlugin()<br>    ],<br>    module:&#123;<br>        rules:[<br>            &#123;<br>            test:<span class="hljs-regexp">/\.css$/</span>,<br>            use:[<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>] <span class="hljs-regexp">//</span> 从右向左解析原则<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.scss$/</span>,<br>                use:[ <span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>,<span class="hljs-string">&#x27;postcss-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>],<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(jpe?g|png|gif)$/i</span>, <span class="hljs-regexp">//</span>图片文件<br>                use: [<br>                  &#123;<br>                    loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>                    options: &#123;<br>                      limit: <span class="hljs-number">10240</span>,<br>                      fallback: &#123;<br>                        loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>                        options: &#123;<br>                            name: <span class="hljs-string">&#x27;img/[name].[hash:8].[ext]&#x27;</span><br>                        &#125;<br>                      &#125;<br>                    &#125;<br>                  &#125;<br>                ]<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>, <span class="hljs-regexp">//</span>媒体文件<br>                use: [<br>                  &#123;<br>                    loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>                    options: &#123;<br>                      limit: <span class="hljs-number">10240</span>,<br>                      fallback: &#123;<br>                        loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>                        options: &#123;<br>                          name: <span class="hljs-string">&#x27;media/[name].[hash:8].[ext]&#x27;</span><br>                        &#125;<br>                      &#125;<br>                    &#125;<br>                  &#125;<br>                ]<br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>, <span class="hljs-regexp">//</span> 字体<br>                use: [<br>                  &#123;<br>                    loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>                    options: &#123;<br>                      limit: <span class="hljs-number">10240</span>,<br>                      fallback: &#123;<br>                        loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>                        options: &#123;<br>                          name: <span class="hljs-string">&#x27;fonts/[name].[hash:8].[ext]&#x27;</span><br>                        &#125;<br>                      &#125;<br>                    &#125;<br>                  &#125;<br>                ]<br>            &#125;,<br>            &#123;<br>                test:<span class="hljs-regexp">/\.js$/</span>,<br>                use:&#123;<br>                  loader:<span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>                  options:&#123;<br>                    presets:[<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]<br>                  &#125;<br>                &#125;,<br>                exclude:<span class="hljs-regexp">/node_modules/</span><br>            &#125;,<br>            &#123;<br>                test: <span class="hljs-regexp">/\.vue$/</span>,<br>                use: [<span class="hljs-string">&#x27;vue-loader&#x27;</span>]<br>            &#125;,<br>        ]<br>    &#125;,<br>    resolve:&#123;<br>        alias:&#123;<br>          <span class="hljs-string">&#x27;vue$&#x27;</span>:<span class="hljs-string">&#x27;vue/dist/vue.runtime.esm.js&#x27;</span>,<br>          <span class="hljs-string">&#x27; @&#x27;</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;./src&#x27;</span>)<br>        &#125;,<br>        extensions:[<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;.js&#x27;</span>,<span class="hljs-string">&#x27;.json&#x27;</span>,<span class="hljs-string">&#x27;.vue&#x27;</span>]<br>   &#125;,<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.dev.js</span><br><br><span class="hljs-keyword">const</span> Webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.js&#x27;</span>)<br><span class="hljs-keyword">const</span> WebpackMerge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>)<br><span class="hljs-built_in">module</span>.exports = WebpackMerge(webpackConfig,&#123;<br>  <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;development&#x27;</span>,<br>  <span class="hljs-attr">devtool</span>:<span class="hljs-string">&#x27;cheap-module-eval-source-map&#x27;</span>,<br>  <span class="hljs-attr">devServer</span>:&#123;<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">3000</span>,<br>    <span class="hljs-attr">hot</span>:<span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> Webpack.HotModuleReplacementPlugin()<br>  ]<br>&#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.prod.js</span><br><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.js&#x27;</span>)<br><span class="hljs-keyword">const</span> WebpackMerge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>)<br><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;copy-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> OptimizeCssAssetsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> UglifyJsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)<br><span class="hljs-built_in">module</span>.exports = WebpackMerge(webpackConfig,&#123;<br>  <span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;production&#x27;</span>,<br>  <span class="hljs-attr">devtool</span>:<span class="hljs-string">&#x27;cheap-module-source-map&#x27;</span>,<br>  <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-keyword">new</span> CopyWebpackPlugin([&#123;<br>      <span class="hljs-attr">from</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;./public&#x27;</span>),<br>      <span class="hljs-attr">to</span>:path.resolve(__dirname,<span class="hljs-string">&#x27;./dist&#x27;</span>)<br>    &#125;]),<br>  ],<br>  <span class="hljs-attr">optimization</span>:&#123;<br>    <span class="hljs-attr">minimizer</span>:[<br>      <span class="hljs-keyword">new</span> UglifyJsPlugin(&#123;<span class="hljs-comment">//压缩js</span><br>        <span class="hljs-attr">cache</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">parallel</span>:<span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">sourceMap</span>:<span class="hljs-literal">true</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> OptimizeCssAssetsPlugin(&#123;&#125;)<br>    ],<br>    <span class="hljs-attr">splitChunks</span>:&#123;<br>      <span class="hljs-attr">chunks</span>:<span class="hljs-string">&#x27;all&#x27;</span>,<br>      <span class="hljs-attr">cacheGroups</span>:&#123;<br>        <span class="hljs-attr">libs</span>: &#123;<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chunk-libs&quot;</span>,<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>          priority: <span class="hljs-number">10</span>,<br>          <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;initial&quot;</span> <span class="hljs-comment">// 只打包初始时依赖的第三方</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="2-4-区分开发环境与生产环境"><a href="#2-4-区分开发环境与生产环境" class="headerlink" title="2.4 区分开发环境与生产环境"></a>2.4 区分开发环境与生产环境</h3><p>实际应用到项目中，我们需要区分开发环境与生产环境，我们在原来webpack.config.js的基础上再新增两个文件</p><ul><li><p><code>webpack.dev.js</code> 开发环境配置文件</p><ul><li>开发环境主要实现的是热更新,不要压缩代码，完整的sourceMap</li></ul></li><li><p><code>webpack.prod.js</code> 生产环境配置文件</p><ul><li>生产环境主要实现的是压缩代码、提取css文件、合理的sourceMap、分割代码<br>需要安装以下模块:<br>npm i -D  webpack-merge copy-webpack-plugin optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin</li></ul></li><li><p><code>webpack-merge</code> 合并配置</p></li><li><p><code>copy-webpack-plugin</code> 拷贝静态资源</p></li><li><p><code>optimize-css-assets-webpack-plugin</code> 压缩css</p></li><li><p><code>uglifyjs-webpack-plugin</code> 压缩js</p></li></ul><h2 id="2-5-优化webpack配置"><a href="#2-5-优化webpack配置" class="headerlink" title="2.5 优化webpack配置"></a>2.5 优化webpack配置</h2><p>优化配置对我们来说非常有实际意义，这实际关系到你打包出来文件的大小，打包的速度等。 具体优化可以分为以下几点：</p><h3 id="2-5-1-优化打包速度"><a href="#2-5-1-优化打包速度" class="headerlink" title="2.5.1 优化打包速度"></a>2.5.1 优化打包速度</h3><blockquote><p>构建速度指的是我们每次修改代码后热更新的速度以及发布前打包文件的速度。</p></blockquote><h4 id="2-5-1-2-缩小文件的搜索范围-配置include-exclude-alias-noParse-extensions"><a href="#2-5-1-2-缩小文件的搜索范围-配置include-exclude-alias-noParse-extensions" class="headerlink" title="2.5.1.2 缩小文件的搜索范围(配置include exclude alias noParse extensions)"></a>2.5.1.2 缩小文件的搜索范围(配置include exclude alias noParse extensions)</h4><ul><li><code>alias</code>: 当我们代码中出现 <code>import &#39;vue&#39;</code>时， webpack会采用向上递归搜索的方式去<code>node_modules</code> 目录下找。为了减少搜索范围我们可以直接告诉webpack去哪个路径下查找。也就是别名(<code>alias</code>)的配置。</li><li><code>include exclude</code> 同样配置<code>include exclude</code>也可以减少<code>webpack loader</code>的搜索转换时间。</li><li><code>noParse </code> 当我们代码中使用到<code>import jq from &#39;jquery&#39;</code>时，<code>webpack</code>会去解析jq这个库是否有依赖其他的包。但是我们对类似<code>jquery</code>这类依赖库，一般会认为不会引用其他的包(特殊除外,自行判断)。增加<code>noParse</code>属性,告诉<code>webpack</code>不必解析，以此增加打包速度。</li><li><code>extensions ``webpack</code>会根据<code>extensions</code>定义的后缀查找文件(频率较高的文件类型优先写在前面)</li></ul><h4 id="2-5-1-3-使用HappyPack开启多进程Loader转换"><a href="#2-5-1-3-使用HappyPack开启多进程Loader转换" class="headerlink" title="2.5.1.3 使用HappyPack开启多进程Loader转换"></a>2.5.1.3 使用HappyPack开启多进程Loader转换</h4><blockquote><p>在webpack构建过程中，实际上耗费时间大多数用在loader解析转换以及代码的压缩中。日常开发中我们需要使用Loader对js，css，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大。由于js单线程的特性使得这些转换操作不能并发处理文件，而是需要一个个文件进行处理。HappyPack的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间</p></blockquote><h4 id="2-5-1-4-使用webpack-parallel-uglify-plugin-增强代码压缩"><a href="#2-5-1-4-使用webpack-parallel-uglify-plugin-增强代码压缩" class="headerlink" title="2.5.1.4 使用webpack-parallel-uglify-plugin 增强代码压缩"></a>2.5.1.4 使用webpack-parallel-uglify-plugin 增强代码压缩</h4><blockquote><p>上面对于loader转换已经做优化，那么下面还有另一个难点就是优化代码的压缩时间</p></blockquote><h4 id="2-5-1-5-抽离第三方模块"><a href="#2-5-1-5-抽离第三方模块" class="headerlink" title="2.5.1.5 抽离第三方模块"></a>2.5.1.5 抽离第三方模块</h4><blockquote><p>对于开发项目中不经常会变更的静态依赖文件。类似于我们的<code>elementUi、vue</code>全家桶等等。因为很少会变更，所以我们不希望这些依赖要被集成到每一次的构建逻辑中去。 这样做的好处是每次更改我本地代码的文件的时候，<code>webpack</code>只需要打包我项目本身的文件代码，而不会再去编译第三方库。以后只要我们不升级第三方包的时候，那么<code>webpack</code>就不会对这些库去打包，这样可以快速的提高打包的速度。</p></blockquote><p>这里我们使用<code>webpack</code>内置的<code>DllPlugin DllReferencePlugin</code>进行抽离<br> 在与<code>webpack</code>配置文件同级目录下新建<code>webpack.dll.config.js</code> 代码如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua">// webpack.dll.<span class="hljs-built_in">config</span>.js<br>const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>const webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack&quot;</span>);<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  // 你想要打包的模块的数组<br>  entry: &#123;<br>    vendor: [<span class="hljs-string">&#x27;vue&#x27;</span>,<span class="hljs-string">&#x27;element-ui&#x27;</span>] <br>  &#125;,<br>  <span class="hljs-built_in">output</span>: &#123;<br>    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;static/js&#x27;</span>), // 打包后文件输出的位置<br>    filename: <span class="hljs-string">&#x27;[name].dll.js&#x27;</span>,<br>    library: <span class="hljs-string">&#x27;[name]_library&#x27;</span> <br>     // 这里需要和webpack.DllPlugin中的`name: <span class="hljs-string">&#x27;[name]_library&#x27;</span>,`保持一致。<br>  &#125;,<br>  plugins: [<br>    new webpack.DllPlugin(&#123;<br>      <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;[name]-manifest.json&#x27;</span>),<br>      name: <span class="hljs-string">&#x27;[name]_library&#x27;</span>, <br>      context: __dirname<br>    &#125;)<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><p>在<code>package.json</code>中配置如下命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;dll&quot;</span>: <span class="hljs-string">&quot;webpack --config build/webpack.dll.config.js&quot;</span><br></code></pre></td></tr></table></figure><p>接下来在我们的<code>webpack.config.js</code>中增加以下代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">module.exports = &#123;<br>  plugins: <span class="hljs-type"></span>[<br>    <span class="hljs-keyword">new</span> <span class="hljs-type">webpack</span>.DllReferencePlugin(&#123;<br>      context: <span class="hljs-type">__dirname</span>,<br>      manifest: <span class="hljs-type">require</span>(<span class="hljs-string">&#x27;./vendor-manifest.json&#x27;</span>)<br>    &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-type">CopyWebpackPlugin</span>([ <span class="hljs-comment">// 拷贝生成的文件到dist目录 这样每次不必手动去cv</span><br>      &#123;from: <span class="hljs-type"></span>&#x27;<span class="hljs-keyword">static</span><span class="hljs-string">&#x27;, to:&#x27;</span><span class="hljs-keyword">static</span><span class="hljs-string">&#x27;&#125;</span><br><span class="hljs-string">    ]),</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;;</span><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> dll<br></code></pre></td></tr></table></figure><p>会发现生成了我们需要的集合第三地方 代码的<code>vendor.dll.js</code> 我们需要在<code>html</code>文件中手动引入这个<code>js</code>文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>老yuan<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;static/js/vendor.dll.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样如果我们没有更新第三方依赖包，就不必<code>npm run dll</code>。直接执行<code>npm run dev npm run build</code>的时候会发现我们的打包速度明显有所提升。因为我们已经通过<code>dllPlugin</code>将第三方依赖包抽离出来了</p><h4 id="2-5-1-6-配置缓存"><a href="#2-5-1-6-配置缓存" class="headerlink" title="2.5.1.6 配置缓存"></a>2.5.1.6 配置缓存</h4><blockquote><p>我们每次执行构建都会把所有的文件都重复编译一遍，这样的重复工作是否可以被缓存下来呢，答案是可以的，目前大部分 <code>loader</code> 都提供了<code>cache</code> 配置项。比如在 <code>babel-loader</code> 中，可以通过设置<code>cacheDirectory</code> 来开启缓存，<code>babel-loader?cacheDirectory=true</code> 就会将每次的编译结果写进硬盘文件（默认是在项目根目录下的<code>node_modules/.cache/babel-loader</code>目录内，当然你也可以自定义）</p></blockquote><p>但如果 <code>loader</code> 不支持缓存呢？我们也有方法,我们可以通过<code>cache-loader</code> ，它所做的事情很简单，就是 <code>babel-loader</code> 开启 <code>cache </code>后做的事情，将 <code>loader</code> 的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。使用方法如官方 demo 所示，在一些性能开销较大的 loader 之前添加此 loader即可</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D cache-loader<br></code></pre></td></tr></table></figure><p><img src="http://lxandzjy.top:9003/2021/11/17/eccbd354b1c97.png"></p><h3 id="2-5-2-优化打包文件体积"><a href="#2-5-2-优化打包文件体积" class="headerlink" title="2.5.2 优化打包文件体积"></a>2.5.2 优化打包文件体积</h3><blockquote><p>打包的速度我们是进行了优化，但是打包后的文件体积却是十分大，造成了页面加载缓慢，浪费流量等，接下来让我们从文件体积上继续优化</p></blockquote><h4 id="2-5-2-1-引入webpack-bundle-analyzer分析打包后的文件"><a href="#2-5-2-1-引入webpack-bundle-analyzer分析打包后的文件" class="headerlink" title="2.5.2.1 引入webpack-bundle-analyzer分析打包后的文件"></a>2.5.2.1 引入webpack-bundle-analyzer分析打包后的文件</h4><p><code>webpack-bundle-analyzer</code>将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D webpack-bundle-analyzer<br></code></pre></td></tr></table></figure><p>接下来在<code>package.json</code>里配置启动命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;analyz&quot;</span>: <span class="hljs-string">&quot;NODE_ENV=production npm_config_report=true npm run build&quot;</span> <br></code></pre></td></tr></table></figure><p>windows请安装<code>npm i -D cross-env</code></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;analyz&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=production npm_config_report=true npm run build&quot;</span> <br></code></pre></td></tr></table></figure><h4 id="2-5-2-3-externals"><a href="#2-5-2-3-externals" class="headerlink" title="2.5.2.3 externals"></a>2.5.2.3 externals</h4><blockquote><p>按照官方文档的解释，如果我们想引用一个库，但是又不想让<code>webpack</code>打包，并且又不影响我们在程序中以<code>CMD、AMD</code>或者<code>window/global</code>全局等方式进行使用，那就可以通过配置<code>Externals</code>。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用 <code>Externals</code>的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 <code>CDN</code> 的方式，去引用它们。</p></blockquote><p>有时我们希望我们通过<code>script</code>引入的库，如用CDN的方式引入的<code>jquery</code>，我们在使用时，依旧用<code>require</code>的方式来使用，但是却不希望<code>webpack</code>将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解  </p><p><a href="https://link.juejin.cn/?target=https://webpack.js.org/configuration/externals/%23root">webpack</a> 官网案例如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script<br>  src=<span class="hljs-string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span><br>  integrity=<span class="hljs-string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span><br>  crossorigin=<span class="hljs-string">&quot;anonymous&quot;</span>&gt;<br>&lt;/script&gt;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">externals</span>: &#123;<br>    <span class="hljs-attr">jquery</span>: <span class="hljs-string">&#x27;jQuery&#x27;</span><br>  &#125;<br>&#125;;<br>复制代码<br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>;<br>$(<span class="hljs-string">&#x27;.my-element&#x27;</span>).animate(<span class="hljs-comment">/* ... */</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>loader</code>从本质上来说其实就是一个<code>node</code>模块。相当于一台榨汁机<code>(loader)</code>将相关类型的文件代码<code>(code)</code>给它。根据我们设置的规则，经过它的一系列加工后还给我们加工好的果汁<code>(code)</code>。</p></blockquote><blockquote><p>知识点普及之<code>AST</code>。<code>AST</code>通俗的来说，假设我们有一个文件<code>a.js</code>,我们对<code>a.js</code>里面的1000行进行一些操作处理,比如为所有的<code>await</code> 增加<code>try catch</code>,以及其他操作，但是<code>a.js</code>里面的代码本质上来说就是一堆字符串。那我们怎么办呢，那就是转换为带标记信息的对象(抽象语法树)我们方便进行增删改查。这个带标记的对象(抽象语法树)就是<code>AST</code>。这里推荐一篇不错的AST文章 <a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000016231512">AST快速入门</a></p></blockquote><blockquote><p>在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过<code>Webpack</code>提供的<code>API</code>改变输出结果。通俗来说：一盘美味的 <a href="https://link.juejin.cn/?target=https://www.meishij.net/zuofa/yandouchaojidan.html">盐豆炒鸡蛋</a> 需要经历烧油 炒制 调味到最后的装盘等过程，而<code>plugin</code>相当于可以监控每个环节并进行操作，比如可以写一个少放胡椒粉<code>plugin</code>,监控<code>webpack</code>暴露出的生命周期事件(调味)，在调味的时候执行少放胡椒粉操作。那么它与<code>loader</code>的区别是什么呢？上面我们也提到了<code>loader</code>的单一原则,<code>loader</code>只能一件事，比如说<code>less-loader</code>,只能解析<code>less</code>文件，<code>plugin</code>则是针对整个流程执行广泛的任务。</p></blockquote><p>动手实践学习于 <a href="https://juejin.cn/post/6844904031240863758">https://juejin.cn/post/6844904031240863758</a> ,来源：稀土掘金</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this、apply、call、bind的理解</title>
    <link href="/2021/11/10/this%E3%80%81apply%E3%80%81call%E3%80%81bind/"/>
    <url>/2021/11/10/this%E3%80%81apply%E3%80%81call%E3%80%81bind/</url>
    
    <content type="html"><![CDATA[<h1 id="this、apply、call、bind的理解"><a href="#this、apply、call、bind的理解" class="headerlink" title="this、apply、call、bind的理解"></a>this、apply、call、bind的理解</h1><h1 id="this-永远指向最后调用它的那个对象"><a href="#this-永远指向最后调用它的那个对象" class="headerlink" title="this 永远指向最后调用它的那个对象"></a><strong>this 永远指向最后调用它的那个对象</strong></h1><h6 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;windows&quot;</span>;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;test&quot;</span>;</span><br><span class="javascript"></span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);          <span class="hljs-comment">// windows</span></span><br><span class="javascript"></span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;inner:&quot;</span> + <span class="hljs-built_in">this</span>);    <span class="hljs-comment">// inner: Window</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">        a();</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;outer:&quot;</span> + <span class="hljs-built_in">this</span>)         <span class="hljs-comment">// outer: Window</span></span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里  <strong>console.log(this.name)</strong>   打印结果并不是    <strong>test **  ,而是windows,因为</strong>this永远指向最后调用它的那个对象**,我们调用  <strong>a()</strong>  的地方就是在全局对象  <strong>window</strong>  ;注意这里没有使用严格模式,如果使用严格模式的话全局对象就是 <strong>undefined</strong>,那么就会报错 <code>Uncaught TypeError: Cannot read property &#39;name&#39; of undefined</code>。</p><h6 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>    <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">// test</span><br>    &#125;<br>&#125;<br>a.fn()<br></code></pre></td></tr></table></figure><p>这里fn函数,就是a对象调用的,所以打印的值就是     a     中name 的值</p><h6 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>    <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br>a.fn()  <span class="hljs-comment">// test</span><br><span class="hljs-built_in">window</span>.a.fn()   <span class="hljs-comment">// testthis 永远指向最后调用它的那个对象,最后调用它的对象仍然是对象 a。</span><br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-comment">// name: &quot;test&quot;,</span><br>    <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br>a.fn()  <span class="hljs-comment">// undefined   原因是因为这里a中并没有对test进行定义,所以是undefined</span><br><span class="hljs-built_in">window</span>.a.fn()   <span class="hljs-comment">// undefined  this 永远指向最后调用它的那个对象,最后调用它的对象仍然是对象 a。</span><br></code></pre></td></tr></table></figure><h6 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;name,name&quot;</span>;<br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>    <span class="hljs-attr">fn</span> : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);      <span class="hljs-comment">// windowsName</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> f = a.fn;<br>f();<span class="hljs-comment">// name,name</span><br>a.fn() <span class="hljs-comment">//test</span><br></code></pre></td></tr></table></figure><p> a 对象的 fn 方法赋值给变量 f 了，但是没有调用,<strong>this 永远指向最后调用它的那个对象</strong>由于刚刚的 f 并没有调用，所以 <code>fn()</code> 最后仍然是被 window 调用的。所以 this 指向的也就是 window.</p><h1 id="怎么改变-this-的指向"><a href="#怎么改变-this-的指向" class="headerlink" title="怎么改变 this 的指向"></a>怎么改变 this 的指向</h1><p>改变 this 的指向我总结有以下几种方法：</p><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li><li>new 实例化一个对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;windowsName&quot;</span>;<br><br>   <span class="hljs-keyword">var</span> a = &#123;<br>       <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;test&quot;</span>,<br><br>       <span class="hljs-attr">func1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)     <br>       &#125;,<br><br>       <span class="hljs-attr">func2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">setTimeout</span>(  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>               <span class="hljs-built_in">this</span>.func1()<br>           &#125;,<span class="hljs-number">100</span>);<br>       &#125;<br><br>   &#125;;<br><br>   a.func2()     <span class="hljs-comment">// this.func1 is not a function</span><br><span class="hljs-comment">// 最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li><strong>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</strong>，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;windowsName&quot;</span>;<br><br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;test&quot;</span>,<br><br>    <span class="hljs-attr">func1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)     <br>    &#125;,<br><br>    <span class="hljs-attr">func2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.func1()<br>        &#125;,<span class="hljs-number">100</span>);<br>    &#125;<br><br>&#125;;<br><br>a.func2() <span class="hljs-comment">// test</span><br></code></pre></td></tr></table></figure><h3 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 <code>_this = this</code></h3><ul><li>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 <code>_this</code> 中，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;windowsName&quot;</span>;<br><br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;test&quot;</span>,<br><br>    <span class="hljs-attr">func1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)     <br>    &#125;,<br><br>    <span class="hljs-attr">func2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> that = <span class="hljs-built_in">this</span><br>        <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            that.func1()<br>        &#125;,<span class="hljs-number">100</span>);<br>    &#125;<br><br>&#125;;<br><br>a.func2() <span class="hljs-comment">// test</span><br></code></pre></td></tr></table></figure><h3 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h3><ul><li>使用 apply、call、bind 函数也是可以改变 this 的指向的.</li></ul><h4 id="使用apply"><a href="#使用apply" class="headerlink" title="使用apply"></a>使用apply</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>    <span class="hljs-attr">func1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;,<br>    <span class="hljs-attr">func2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">this</span>.func1()<br>        &#125;.apply(a),<span class="hljs-number">100</span>)<br>    &#125;<br>&#125;;<br>a.func2()<span class="hljs-comment">// test</span><br></code></pre></td></tr></table></figure><h4 id="使用call"><a href="#使用call" class="headerlink" title="使用call"></a>使用call</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>    <span class="hljs-attr">func1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;,<br>    <span class="hljs-attr">func2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">this</span>.func1()<br>        &#125;.call(a),<span class="hljs-number">100</span>)<br>    &#125;<br>&#125;;<br>a.func2()<span class="hljs-comment">// test</span><br></code></pre></td></tr></table></figure><h4 id="使用bind"><a href="#使用bind" class="headerlink" title="使用bind"></a>使用bind</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span>,<br>    <span class="hljs-attr">func1</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;,<br>    <span class="hljs-attr">func2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">this</span>.func1()<br>        &#125;.bind(a),<span class="hljs-number">100</span>)<br>    &#125;<br>&#125;;<br>a.func2()<span class="hljs-comment">// test</span><br></code></pre></td></tr></table></figure><ul><li>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</li><li>其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li><li>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</li></ul><h2 id="手写-apply、call、bind"><a href="#手写-apply、call、bind" class="headerlink" title="手写 apply、call、bind"></a>手写 apply、call、bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行fn,使this为obj,并将args数组参数传递给fn(功能等同于函数对象的apply方法)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>fn </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>obj </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>args </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author <span class="hljs-variable">zhujingyang</span></span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apply</span>(<span class="hljs-params">fn, obj, args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(obj === <span class="hljs-literal">undefined</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>        obj = globalThis; <span class="hljs-comment">/// globalThis 指向全局对象</span><br>    &#125;<br>    obj.temp = fn;<br>    <span class="hljs-keyword">let</span> result = obj.temp(...args);<br>    <span class="hljs-keyword">delete</span> obj.temp;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行fn,使this为obj,并将后面的参数传递给fn(功能等同于函数对象的call方法)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>fn </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>obj </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;...any&#125;</span> </span>args </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author <span class="hljs-variable">zhujingyang</span></span></span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/** */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">call</span>(<span class="hljs-params">fn, obj, ...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(obj === <span class="hljs-literal">undefined</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>        obj = globalThis; <span class="hljs-comment">/// globalThis 指向全局对象</span><br>    &#125;<br>    obj.temp = fn;<br>    <span class="hljs-keyword">let</span> result = obj.temp(...args);<br>    <span class="hljs-keyword">delete</span> obj.temp;<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行fn,使this为obj,并指定参数为后面的n个参数(功能等同于函数对象的bind方法)</span><br><span class="hljs-comment"> * call 会执行目标函数</span><br><span class="hljs-comment"> * bind 不会去执行目标函数,它会创建一个新的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> </span>fn </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>obj </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param  <span class="hljs-type">&#123;...any&#125;</span> </span>args </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author <span class="hljs-variable">zhujingyang</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123;call&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./call&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">fn, obj, ...args</span>) </span>&#123;<br>    <span class="hljs-comment">// bind函数返回一个新的函数</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>         <span class="hljs-keyword">return</span> call(fn, obj, ...args, ...args2)<br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="自定义工具库-lz-tool-http-lxandzjy-top-9009"><a href="#自定义工具库-lz-tool-http-lxandzjy-top-9009" class="headerlink" title="自定义工具库 lz-tool  http://lxandzjy.top:9009/"></a>自定义工具库 lz-tool  <a href="http://lxandzjy.top:9009/">http://lxandzjy.top:9009/</a></h2><p><img src="http://lxandzjy.top:9003/2021/11/29/4576f03180dda.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS动画</title>
    <link href="/2021/10/25/css%E5%8A%A8%E7%94%BB/"/>
    <url>/2021/10/25/css%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="animation、transition、transform、translate"><a href="#animation、transition、transform、translate" class="headerlink" title="animation、transition、transform、translate"></a>animation、transition、transform、translate</h1><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>animation（动画）</td><td>用于设置动画属性，他是一个简写的属性，包含6个属性</td></tr><tr><td>transition（过渡）</td><td>用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同</td></tr><tr><td>transform（变形）</td><td>用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表”</td></tr><tr><td>translate（移动）</td><td>translate只是transform的一个属性值，即移动。</td></tr></tbody></table><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>什么叫过渡？字面意思上来讲，就是元素从这个属性(color)的某个值(red)过渡到这个属性(color)的另外一个值(green)，这是一个状态的转变，需要一种条件来触发这种转变，比如我们平时用到的:hoever、:focus、:checked、媒体查询或者JavaScript。</p><p>先从一个简单的demo来看看transition的效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>transition<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#box</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background</span>: green;</span><br><span class="css">      <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">1s</span> ease-in <span class="hljs-number">1s</span>;</span><br><span class="css">    &#125;</span><br><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#box</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">scale</span>(.<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>);</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先transition给元素设置的过渡属性是transform，当鼠标移入元素时，元素的transform发生变化，那么这个时候就触发了transition，产生了动画，当鼠标移出时，transform又发生变化，这个时候还是会触发transition，产生动画，所以transition产生动画的条件是transition设置的property发生变化，这种动画的特点是需要“一个驱动力去触发”，有着以下几个不足：</p><ol><li>需要事件触发，所以没法在网页加载时自动发生</li><li>是一次性的，不能重复发生，除非一再触发</li><li>只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态</li><li>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</li></ol><p>语法：<strong>transition: property duration timing-function delay;</strong></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>transition-property</td><td>规定设置过渡效果的 CSS 属性的名称</td></tr><tr><td>transition-duration</td><td>规定完成过渡效果需要多少秒或毫秒</td></tr><tr><td>transition-timing-function</td><td>规定速度效果的速度曲线</td></tr><tr><td>transition-delay</td><td>定义过渡效果何时开始</td></tr></tbody></table><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>在官方的介绍上介绍这个属性是transition属性的扩展，弥补了transition的很多不足，我理解为animation是由多个transition的效果叠加，并且可操作性更强，能够做出复杂酷炫的效果(前提是你爱折腾)，我们以一个例子来介绍animation的威力：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>animation<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid black;</span><br><span class="css">      <span class="hljs-attribute">animation</span>: changebox <span class="hljs-number">1s</span> ease-in-out <span class="hljs-number">1s</span> infinite alternate running forwards;</span><br><span class="css">    &#125;</span><br><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">animation-play-state</span>: paused;</span><br><span class="css">    &#125;</span><br><span class="css"></span><br><span class="css">    <span class="hljs-keyword">@keyframes</span> changebox &#123;</span><br><span class="css">      <span class="hljs-number">10%</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">background</span>: red;</span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-number">50%</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;</span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-number">70%</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid yellow;</span><br><span class="css">      &#125;</span><br><span class="css">      <span class="hljs-number">100%</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">180px</span>;</span><br><span class="css">      &#125;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们先来看看keyframes这个关键点，它定义了一个动画组合叫changebox，里面的10%，50%，70%，100%代表在变化中不同时间点的属性值，比如这个动画的总时间是1s，那么10%就是在0-0.1s中的动画，通过这个我们可以较精确的控制动画变化中任何一个时间点的属性效果，这大大提高了我们对动画的把控，是做复杂动画的基础，我们再回来看animation中整整八个值，是不是有点夸张，还没见过这么长的值，通过控制animation的每个值，控制动画变得非常灵活，我们来具体了解它的语法以及各个值代表着什么：</p><p>语法：<strong>animation: name duration timing-function delay iteration-count direction play-state fill-mode;</strong></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>用来调用@keyframes定义好的动画，与@keyframes定义的动画名称一致</td></tr><tr><td>duration</td><td>指定元素播放动画所持续的时间</td></tr><tr><td>timing-function</td><td>规定速度效果的速度曲线，是针对每一个小动画所在时间范围的变换速率</td></tr><tr><td>delay</td><td>定义在浏览器开始执行动画之前等待的时间，值整个animation执行之前等待的时间</td></tr><tr><td>iteration-count</td><td>定义动画的播放次数，可选具体次数或者无限(infinite)</td></tr><tr><td>direction</td><td>设置动画播放方向：normal(按时间轴顺序),reverse(时间轴反方向运行),alternate(轮流，即来回往复进行),alternate-reverse(动画先反运行再正方向运行，并持续交替运行)</td></tr><tr><td>play-state</td><td>控制元素动画的播放状态，通过此来控制动画的暂停和继续，两个值：running(继续)，paused(暂停)</td></tr><tr><td>fill-mode</td><td>控制动画结束后，元素的样式，有四个值：none(回到动画没开始时的状态)，forwards(动画结束后动画停留在结束状态)，backwords(动画回到第一帧的状态)，both(根据animation-direction轮流应用forwards和backwards规则)，注意与iteration-count不要冲突(动画执行无限次)</td></tr></tbody></table><p>animation与transition 不同的是，keyframes提供更多的控制，尤其是时间轴的控制，这点让css animation更加强大.</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中使用svg图标</title>
    <link href="/2021/10/20/vue%E4%B8%AD%E4%BD%BF%E7%94%A8svg%E5%9B%BE%E6%A0%87/"/>
    <url>/2021/10/20/vue%E4%B8%AD%E4%BD%BF%E7%94%A8svg%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue中使用svg图标"><a href="#Vue中使用svg图标" class="headerlink" title="Vue中使用svg图标"></a>Vue中使用svg图标</h2><h3 id="遇到这个问题，是我在学习vue-admin-template-模板的时候学习到的。"><a href="#遇到这个问题，是我在学习vue-admin-template-模板的时候学习到的。" class="headerlink" title="遇到这个问题，是我在学习vue-admin-template 模板的时候学习到的。"></a>遇到这个问题，是我在学习vue-admin-template 模板的时候学习到的。</h3><h4 id="花裤衩大佬"><a href="#花裤衩大佬" class="headerlink" title="花裤衩大佬"></a>花裤衩大佬</h4><p>手摸手，带你优雅的使用 icon 文章地址<strong><a href="https://juejin.cn/post/6844903517564436493">https://juejin.cn/post/6844903517564436493</a></strong></p><p>手摸手，带你用vue撸后台系列   文章地址 <strong><a href="https://juejin.cn/post/6844903476661583880">https://juejin.cn/post/6844903476661583880</a></strong></p><h3 id="使用-svg-sprite"><a href="#使用-svg-sprite" class="headerlink" title="使用 svg-sprite"></a>使用 svg-sprite</h3><p>接下来我们就要自己来制作 <code>svg-sprite</code> 了。这里要使用到 <a href="https://link.juejin.cn/?target=https://github.com/kisenka/svg-sprite-loader">svg-sprite-loader</a> 这个神器了， 它是一个 webpack loader ，可以将多个 svg 打包成 <code>svg-sprite</code> 。</p><p>我们来介绍如何在 <code>vue-cli</code> 的基础上进行改造，加入 <code>svg-sprite-loader</code>。</p><p>我们发现<code>vue-cli</code>默认情况下会使用 <code>url-loader</code> 对svg进行处理，会将它放在<code>/img</code> 目录下，所以这时候我们引入<code>svg-sprite-loader</code> 会引发一些冲突。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>默认`vue-cli` 对svg做的处理，正则匹配后缀名为.svg的文件，匹配成功之后使用 url-loader 进行处理。<br> &#123;<br>    test: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,<br>    loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>    options: &#123;<br>      limit: <span class="hljs-number">10000</span>,<br>      name: utils.assetsPath(<span class="hljs-string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>解决方案有两种，最简单的就是你可以将 test 的 svg 去掉，这样就不会对svg做处理了，当然这样做是很不友善的。</p><ul><li>你不能保证你所有的 svg 都是用来当做 icon的，有些真的可能只是用来当做图片资源的。</li><li>不能确保你使用的一些第三方类库会使用到 svg。</li></ul><p>所以最安全合理的做法是使用 webpack 的 <a href="https://link.juejin.cn/?target=https://webpack.js.org/configuration/module/%23rule-exclude">exclude</a> 和 <a href="https://link.juejin.cn/?target=https://webpack.js.org/configuration/module/%23rule-include">include</a> ，让<code>svg-sprite-loader</code>只处理你指定文件夹下面的 svg，<code>url-loaer</code>只处理除此文件夹之外的所以 svg，这样就完美解决了之前冲突的问题。 代码如下</p><h3 id="我觉得重要的是vue-config-js-对svg的处理（放前面）"><a href="#我觉得重要的是vue-config-js-对svg的处理（放前面）" class="headerlink" title="我觉得重要的是vue.config.js 对svg的处理（放前面）"></a>我觉得重要的是vue.config.js 对svg的处理（放前面）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-function"><span class="hljs-title">chainWebpack</span>(<span class="hljs-params">config</span>)</span> &#123;<br>    config.plugin(<span class="hljs-string">&#x27;preload&#x27;</span>).tap(<span class="hljs-function">() =&gt;</span> [<br>      &#123;<br>        <span class="hljs-attr">rel</span>: <span class="hljs-string">&#x27;preload&#x27;</span>,<br>        <span class="hljs-attr">fileBlacklist</span>: [<span class="hljs-regexp">/\.map$/</span>, <span class="hljs-regexp">/hot-update\.js$/</span>, <span class="hljs-regexp">/runtime\..*\.js$/</span>],<br>        <span class="hljs-attr">include</span>: <span class="hljs-string">&#x27;initial&#x27;</span><br>      &#125;<br>    ])<br><br>    <span class="hljs-comment">// 当页面特别的多的时候会有很多不必要的请求</span><br>    config.plugins.delete(<span class="hljs-string">&#x27;prefetch&#x27;</span>)<br><br>    <span class="hljs-comment">// 设置svg-sprite-loader 处理svg这样就可以使用封装的svg组件</span><br>    config.module<br>      .rule(<span class="hljs-string">&#x27;svg&#x27;</span>)<br>      .exclude.add(resolve(<span class="hljs-string">&#x27;src/icons&#x27;</span>))<br>      .end()<br>    config.module<br>      .rule(<span class="hljs-string">&#x27;icons&#x27;</span>)<br>      .test(<span class="hljs-regexp">/\.svg$/</span>)<br>      .include.add(resolve(<span class="hljs-string">&#x27;src/icons&#x27;</span>))<br>      .end()<br>      .use(<span class="hljs-string">&#x27;svg-sprite-loader&#x27;</span>)<br>      .loader(<span class="hljs-string">&#x27;svg-sprite-loader&#x27;</span>)<br>      .options(&#123;<br>        <span class="hljs-attr">symbolId</span>: <span class="hljs-string">&#x27;icon-[name]&#x27;</span><br>      &#125;)<br>      .end()<br><br>    <span class="hljs-comment">// 目前上不清楚作用</span><br>    config<br>      .when(process.env.NODE_ENV !== <span class="hljs-string">&#x27;development&#x27;</span>,<br>        <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>          config<br>            .plugin(<span class="hljs-string">&#x27;ScriptExtHtmlWebpackPlugin&#x27;</span>)<br>            .after(<span class="hljs-string">&#x27;html&#x27;</span>)<br>            .use(<span class="hljs-string">&#x27;script-ext-html-webpack-plugin&#x27;</span>, [&#123;<br>            <span class="hljs-comment">// `runtime` must same as runtimeChunk name. default is `runtime`</span><br>              <span class="hljs-attr">inline</span>: <span class="hljs-regexp">/runtime\..*\.js$/</span><br>            &#125;])<br>            .end()<br>          config<br>            .optimization.splitChunks(&#123;<br>              <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,<br>              <span class="hljs-attr">cacheGroups</span>: &#123;<br>                <span class="hljs-attr">libs</span>: &#123;<br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chunk-libs&#x27;</span>,<br>                  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>                  priority: <span class="hljs-number">10</span>,<br>                  <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span> <span class="hljs-comment">// only package third parties that are initially dependent</span><br>                &#125;,<br>                <span class="hljs-attr">elementUI</span>: &#123;<br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chunk-elementUI&#x27;</span>, <span class="hljs-comment">// split elementUI into a single package</span><br>                  <span class="hljs-attr">priority</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">// the weight needs to be larger than libs and app or it will be packaged into libs or app</span><br>                  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_modules[\\/]_?element-ui(.*)/</span> <span class="hljs-comment">// in order to adapt to cnpm</span><br>                &#125;,<br>                <span class="hljs-attr">commons</span>: &#123;<br>                  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chunk-commons&#x27;</span>,<br>                  <span class="hljs-attr">test</span>: resolve(<span class="hljs-string">&#x27;src/components&#x27;</span>), <span class="hljs-comment">// can customize your rules</span><br>                  <span class="hljs-attr">minChunks</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">//  minimum common number</span><br>                  <span class="hljs-attr">priority</span>: <span class="hljs-number">5</span>,<br>                  <span class="hljs-attr">reuseExistingChunk</span>: <span class="hljs-literal">true</span><br>                &#125;<br>              &#125;<br>            &#125;)<br>          <span class="hljs-comment">// https:// webpack.js.org/configuration/optimization/#optimizationruntimechunk</span><br>          config.optimization.runtimeChunk(<span class="hljs-string">&#x27;single&#x27;</span>)<br>        &#125;<br>      )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="封装svg-icon-组件"><a href="#封装svg-icon-组件" class="headerlink" title="封装svg-icon 组件"></a>封装svg-icon 组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;<br>    &lt;use :xlink:href=&quot;iconName&quot; /&gt;<br>  &lt;/svg&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;SvgIcon&#x27;,<br>  props: &#123;<br>    iconClass: &#123;<br>      type: String,<br>      required: true<br>    &#125;,<br>    className: &#123;<br>      type: String,<br>      default: &#x27;&#x27;<br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    iconName() &#123;<br>      return `#icon-$&#123;this.iconClass&#125;`<br>    &#125;,<br>    svgClass() &#123;<br>      if (this.className) &#123;<br>        return &#x27;svg-icon &#x27; + this.className<br>      &#125; else &#123;<br>        return &#x27;svg-icon&#x27;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="全局挂载"><a href="#全局挂载" class="headerlink" title="全局挂载"></a>全局挂载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> SvgIcon <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/SvgIcon/index.vue&#x27;</span><br><br>Vue.component(<span class="hljs-string">&#x27;svg-icon&#x27;</span>, SvgIcon)<br><br><span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#x27;./svg&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>)<br><span class="hljs-keyword">const</span> requireAll = <span class="hljs-function"><span class="hljs-params">requireContext</span> =&gt;</span> requireContext.keys().map(requireContext)<br>requireAll(req)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>svg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>element 导航菜单折叠动画，文字不隐藏</title>
    <link href="/2021/10/12/element%20%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95%E6%8A%98%E5%8F%A0%E5%8A%A8%E7%94%BB%EF%BC%8C%E6%96%87%E5%AD%97%E4%B8%8D%E9%9A%90%E8%97%8F/"/>
    <url>/2021/10/12/element%20%E5%AF%BC%E8%88%AA%E8%8F%9C%E5%8D%95%E6%8A%98%E5%8F%A0%E5%8A%A8%E7%94%BB%EF%BC%8C%E6%96%87%E5%AD%97%E4%B8%8D%E9%9A%90%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="element-导航菜单折叠动画，文字不隐藏问题"><a href="#element-导航菜单折叠动画，文字不隐藏问题" class="headerlink" title="element 导航菜单折叠动画，文字不隐藏问题"></a>element 导航菜单折叠动画，文字不隐藏问题</h3><p>记录一下留着自己好找</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>修改css样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*隐藏文字*/</span><br>  <span class="hljs-selector-class">.el-menu--collapse</span>  <span class="hljs-selector-class">.el-submenu__title</span> <span class="hljs-selector-tag">span</span>&#123;<br>    <span class="hljs-attribute">display</span>: none;<br>  &#125;<br>  <span class="hljs-comment">/*隐藏 &gt; */</span><br>  <span class="hljs-selector-class">.el-menu--collapse</span>  <span class="hljs-selector-class">.el-submenu__title</span> <span class="hljs-selector-class">.el-submenu__icon-arrow</span>&#123;<br>    <span class="hljs-attribute">display</span>: none;<br>  &#125;<br>  <span class="hljs-comment">/* .sub-el-icon[data-v-31ea41b3]&#123;</span><br><span class="hljs-comment">    margin-right: 12px !important;</span><br><span class="hljs-comment">    margin-left: -6px;</span><br><span class="hljs-comment">  &#125; */</span><br>  <span class="hljs-selector-class">.sub-el-icon</span>&#123;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">12px</span> <span class="hljs-meta">!important</span>;<br>    m<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>element-ui</tag>
      
      <tag>asdasdas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序简单封装 wx.request</title>
    <link href="/2021/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85wx.request/"/>
    <url>/2021/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85wx.request/</url>
    
    <content type="html"><![CDATA[<h3 id="微信小程序简单封装-wx-request-Object-object"><a href="#微信小程序简单封装-wx-request-Object-object" class="headerlink" title="微信小程序简单封装 wx.request(Object object)"></a>微信小程序简单封装 wx.request(Object object)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简单封装wx.request</span><br><span class="hljs-keyword">const</span> app = getApp();<br><span class="hljs-comment">// 请求的基本路径</span><br><span class="hljs-keyword">const</span> baseUrl= <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">const</span> GET = <span class="hljs-string">&#x27;GET&#x27;</span>;<br><span class="hljs-keyword">const</span> POST = <span class="hljs-string">&#x27;POST&#x27;</span>;<br><span class="hljs-keyword">const</span> PUT = <span class="hljs-string">&#x27;PUT&#x27;</span>;<br><span class="hljs-keyword">const</span> FORM = <span class="hljs-string">&#x27;FORM&#x27;</span>;<br><span class="hljs-keyword">const</span> DELETE = <span class="hljs-string">&#x27;DELETE&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">&#123;method= GET, url, data&#125;</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> header = &#123;<br>            <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>            <span class="hljs-string">&#x27;token&#x27;</span>: app.globalData.userInfo.token || <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;;<br>        wx.request(&#123;<br>            <span class="hljs-attr">url</span>: baseUrl + url,<br>            <span class="hljs-attr">method</span>: method,<br>            <span class="hljs-attr">data</span>: method === POST ? <span class="hljs-built_in">JSON</span>.stringify(data) : data,<br>            <span class="hljs-attr">header</span>: header,<br>            <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span> &#123;<br>                resolve(res);<br>            &#125;,<br>            <span class="hljs-function"><span class="hljs-title">fail</span>(<span class="hljs-params">err</span>)</span> &#123;<br>                reject(err)<br>            &#125;<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span>  &#123;request&#125;;<br></code></pre></td></tr></table></figure><p>// api中调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;request&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/request.js&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sign</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> request(&#123;<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>      <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>      data<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="picker-选择器渲染对象数组Object-Array问题-range-key"><a href="#picker-选择器渲染对象数组Object-Array问题-range-key" class="headerlink" title="picker  选择器渲染对象数组Object Array问题         range-key"></a>picker  选择器渲染对象数组Object Array问题         range-key</h4><table><thead><tr><th>range-key</th><th>string</th><th></th><th>当 range 是一个 Object Array 时，通过 range-key 来指定 Object 中 key 的值作为选择器显</th></tr></thead></table><h4 id="微信小程序事件传递参数问题-dataset-target-触发事件的源组件。"><a href="#微信小程序事件传递参数问题-dataset-target-触发事件的源组件。" class="headerlink" title="微信小程序事件传递参数问题   dataset     target    触发事件的源组件。"></a>微信小程序事件传递参数问题   dataset     target    触发事件的源组件。</h4><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">String</td><td align="left">事件源组件的id</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td><td align="left">Object</td><td align="left">事件源组件上由<code>data-</code>开头的自定义属性组成的集合</td></tr></tbody></table><h4 id="currentTarget-事件绑定的当前组件。"><a href="#currentTarget-事件绑定的当前组件。" class="headerlink" title="currentTarget   事件绑定的当前组件。"></a>currentTarget   事件绑定的当前组件。</h4><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">String</td><td align="left">当前组件的id</td></tr><tr><td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td><td align="left">Object</td><td align="left">当前组件上由<code>data-</code>开头的自定义属性组成的集合</td></tr></tbody></table><h3 id="cover-view-滚动视图"><a href="#cover-view-滚动视图" class="headerlink" title="cover-view 滚动视图"></a>cover-view 滚动视图</h3><h4 id="onReachBottom-function-页面上拉触底事件的处理函数-监听page页面的触底事件"><a href="#onReachBottom-function-页面上拉触底事件的处理函数-监听page页面的触底事件" class="headerlink" title="onReachBottom    function    页面上拉触底事件的处理函数   监听page页面的触底事件"></a>onReachBottom    function    页面上拉触底事件的处理函数   监听page页面的触底事件</h4>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序版本自动更新的方法</title>
    <link href="/2021/09/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2021/09/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="微信小程序版本自动更新的方法"><a href="#微信小程序版本自动更新的方法" class="headerlink" title="微信小程序版本自动更新的方法"></a>微信小程序版本自动更新的方法</h1><h4 id="实践于实验室考勤项目"><a href="#实践于实验室考勤项目" class="headerlink" title="实践于实验室考勤项目"></a>实践于实验室考勤项目</h4><p><strong>知识点1</strong>: 当用户点击左上角关闭，或者按了设备Home 键离开微信，小程序并没有直接销毁，而是进入了后台；<br> 当再次进入微信或再次打开小程序，又会从后台进入前台，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p><p>**知识点2: **小程序的启动分为”冷启动” 和 “热启动”.</p><p>热启动是指: 小程序打开后，在一段时间内（目前：5分钟）再次被打开，此时会将后台的小程序切换到前台。</p><p>冷启动是指: 小程序首次打开或销毁后再次被打开</p><p><strong>知识点3:</strong> 更新版本</p><p>冷启动时, 如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。</p><p>如果要马上应用最新版本，使用<a href="https://links.jianshu.com/go?to=https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html">wx.getUpdateManager </a>API 进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在app.js里写下以下代码</span><br> onLaunch () &#123;<br>  <span class="hljs-keyword">if</span> (wx.canIUse(<span class="hljs-string">&#x27;getUpdateManager&#x27;</span>)) &#123;<br>   <span class="hljs-keyword">const</span> updateManager = wx.getUpdateManager()<br>   updateManager.onCheckForUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;onCheckForUpdate====&#x27;</span>, res)<br>    <span class="hljs-comment">// 请求完新版本信息的回调</span><br>    <span class="hljs-keyword">if</span> (res.hasUpdate) &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;res.hasUpdate====&#x27;</span>)<br>     updateManager.onUpdateReady(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      wx.showModal(&#123;<br>       <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;更新提示&#x27;</span>,<br>       <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;新版本已经准备好，是否重启应用？&#x27;</span>,<br>       <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;success====&#x27;</span>, res)<br>        <span class="hljs-comment">// res: &#123;errMsg: &quot;showModal: ok&quot;, cancel: false, confirm: true&#125;</span><br>        <span class="hljs-keyword">if</span> (res.confirm) &#123;<br>         <span class="hljs-comment">// 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span><br>         updateManager.applyUpdate()<br>        &#125;<br>       &#125;<br>      &#125;)<br>     &#125;)<br>     updateManager.onUpdateFailed(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">// 新的版本下载失败</span><br>      wx.showModal(&#123;<br>       <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;已经有新版本了哟~&#x27;</span>,<br>       <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~&#x27;</span><br>      &#125;)<br>     &#125;)<br>    &#125;<br>   &#125;)<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>知识点4</strong>: 小程序重新初始化时会触发onLaunch事件. onLaunch事件会触发在页面onShow事件之前.获取小程序更新版本可以写在onLaunch里.</p><p><strong>知识点5</strong>: 随着小程序的不断更新, 部分功能可能需要最新版的微信客户端才能使用. 这时候可以弹窗提示用户更新到最新版本微信</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript">onLaunch () &#123;<br> <span class="hljs-keyword">if</span> (wx.canIUse(<span class="hljs-string">&#x27;getUpdateManager&#x27;</span>)) &#123;<br>  <span class="hljs-keyword">const</span> updateManager = wx.getUpdateManager()<br>  updateManager.onCheckForUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>   <span class="hljs-keyword">if</span> (res.hasUpdate) &#123;<br>    updateManager.onUpdateReady(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>     wx.showModal(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;更新提示&#x27;</span>,<br>      <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;新版本已经准备好，是否重启应用？&#x27;</span>,<br>      <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>       <span class="hljs-keyword">if</span> (res.confirm) &#123;<br>        updateManager.applyUpdate()<br>       &#125;<br>      &#125;<br>     &#125;)<br>    &#125;)<br>    updateManager.onUpdateFailed(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>     wx.showModal(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;已经有新版本了哟~&#x27;</span>,<br>      <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~&#x27;</span><br>     &#125;)<br>    &#125;)<br>   &#125;<br>  &#125;)<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>  wx.showModal(&#123;<br>   <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;提示&#x27;</span>,<br>   <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&#x27;</span><br>  &#125;)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序订阅消息推送</title>
    <link href="/2021/09/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    <url>/2021/09/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
    
    <content type="html"><![CDATA[<h3 id="微信小程序做订阅消息"><a href="#微信小程序做订阅消息" class="headerlink" title="微信小程序做订阅消息"></a>微信小程序做订阅消息</h3><p>先放上官方文档的位置 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html</a></p><p>消息能力是小程序能力中的重要组成，我们为开发者提供了订阅消息能力，以便实现服务的闭环和更优的体验。</p><ul><li>订阅消息推送位置：服务通知</li><li>订阅消息下发条件：用户自主订阅</li><li>订阅消息卡片跳转能力：点击查看详情可跳转至该小程序的页面</li></ul><p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/request-subscribe-message.3851318e.jpg" alt="intro"></p><h3 id="消息类型分为两种"><a href="#消息类型分为两种" class="headerlink" title="消息类型分为两种"></a>消息类型分为两种</h3><p><strong>1. 一次性订阅消息</strong></p><p>一次性订阅消息用于解决用户使用小程序后，后续服务环节的通知问题。用户自主订阅后，开发者可<strong>不限时间</strong>地下发<strong>一条对应的服务消息</strong>；每条消息可单独订阅或退订。</p><p><strong>2. 长期订阅消息</strong></p><p>一次性订阅消息可满足小程序的大部分服务场景需求，但线下公共服务领域存在一次性订阅无法满足的场景，如航班延误，需根据航班实时动态来多次发送消息提醒。为便于服务，我们提供了长期性订阅消息，用户订阅一次后，开发者可长期下发多条消息。</p><p>目前长期性订阅消息仅向政务民生、医疗、交通、金融、教育等线下公共服务开放，后期将逐步支持到其他线下公共服务业务。</p><p>本人只使用过第一种</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol><li>先去微信公众平台手动配置 获取模板ID</li><li>小程序端  调取下发权限  详见小程序端消息订阅接口 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html">wx.requestSubscribeMessage</a><ul><li>参数需要有刚刚订阅的ID</li></ul></li><li>最后需要服务端去调用 详见服务端消息发送接口 <a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html">subscribeMessage.send</a><ul><li>参数 需要接口调用凭证</li><li>接受者（订阅者）的openId</li><li>想要下发的模板ID</li><li>可选参数 用户点击消息跳转到的页面</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>wx.requestSubscribeMessage(&#123;<br>  <span class="hljs-attr">tmplIds</span>: [<br>      <span class="hljs-string">&#x27;hrnc0VOS_KB4VvKIB9V8zRkkV7q_vZ7KoxBPRFUWDMk&#x27;</span>,<br>      <span class="hljs-string">&#x27;jtay-u_B1HgxMnlLlw4oskdJOXlzWcPasSnXqFVVqW0&#x27;</span><br>  ],<br>  success (res) &#123;<br>    <span class="hljs-comment">// console.log(res);</span><br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序登录鉴权</title>
    <link href="/2021/09/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/"/>
    <url>/2021/09/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h3 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h3><p>为了方便小程序应用使用微信登录态进行授权登录，微信小程序提供了登录授权的开放接口。乍一看文档，感觉文档上讲的非常有道理，但是实现起来又真的是摸不着头脑，不知道如何管理和维护登录态。本文就来手把手的教会大家在业务里如何接入和维护微信登录态。</p><h3 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h3><p>这里官方文档上的流程图已经足够清晰，我们直接就该图展开详述和补充。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/8/162a3f3836b2adae~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>首先大家看到这张图，肯定会注意到小程序进行通信交互的不止是小程序前端和我们自己的服务端，微信第三方服务端也参与其中，那么微信服务端在其中扮演着怎样的角色呢？我们一起来串一遍登录鉴权的流程就明白了。</p><p><strong>1. 调用wx.login生成code</strong></p><p>wx.login()这个API的作用就是为当前用户生成一个临时的登录凭证，这个临时登录凭证的有效期只有五分钟。我们拿到这个登录凭证后就可以进行下一步操作：获取<code>openid</code>和<code>session_key</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">wx.login(&#123;<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(loginRes)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (loginRes.code) &#123;<br>            <span class="hljs-comment">// example: 081LXytJ1Xq1Y40sg3uJ1FWntJ1LXyth</span><br>        &#125;<br>    &#125;<br>&#125;);<br><br>复制代码<br></code></pre></td></tr></table></figure><p><strong>2. 获取openid和session_key</strong></p><p>我们先来介绍下openid，用过公众号的童鞋应该对这个标识都不陌生了，在公众平台里，用来标识每个用户在订阅号、服务号、小程序这三种不同应用的唯一标识，也就是说每个用户在每个应用的openid都是不一致的，所以在小程序里，我们可以用openid来标识用户的唯一性。</p><p>那么session_key是用来干嘛的呢？有了用户标识，我们就需要让该用户进行登录，那么<code>session_key</code>就保证了当前用户进行会话操作的有效性，这个session_key是微信服务端给我们派发的。也就是说，我们可以用这个标识来间接地维护我们小程序用户的登录态，那么这个session_key是怎么拿到的呢？我们需要在自己的服务端请求微信提供的第三方接口<code>https://api.weixin.qq.com/sns/jscode2session</code>，这个接口需要带上四个参数字段：</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>appid</td><td>小程序的appid</td></tr><tr><td>secret</td><td>小程序的secret</td></tr><tr><td>js_code</td><td>前面调用wx.login派发的code</td></tr><tr><td>grant_type</td><td>‘authorization_code’</td></tr></tbody></table><p>从这几个参数，我们可以看出，要请求这个接口必须先调用wx.login()来获取到用户当前会话的code。那么为什么我们要在服务端来请求这个接口呢？其实是出于安全性的考量，如果我们在前端通过request调用此接口，就不可避免的需要将我们小程序的appid和小程序的secret暴露在外部，同时也将微信服务端下发的session_key暴露给“有心之人”，这就给我们的业务安全带来极大的风险。除了需要在服务端进行session_key的获取，我们还需要注意两点：</p><ul><li>session_key和微信派发的code是一一对应的，同一code只能换取一次session_key。每次调用wx.login()，都会下发一个新的code和对应的session_key，为了保证用户体验和登录态的有效性，开发者需要清楚用户需要重新登录时才去调用wx.login()</li><li>session_key是有时效性的，即便是不调用wx.login，session_key也会过期，过期时间跟用户使用小程序的频率成正相关，但具体的时间长短开发者和用户都是获取不到的</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function getSessionKey (code, appid, appSecret) &#123;<br>    <span class="hljs-keyword">var</span> opt = &#123;<br>        method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>        url: <span class="hljs-string">&#x27;https://api.weixin.qq.com/sns/jscode2session&#x27;</span>,<br>        params: &#123;<br>            appid: appid,<br>            secret: appSecret,<br>            js_code: code,<br>            grant_type: <span class="hljs-string">&#x27;authorization_code&#x27;</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> http(opt).then(function (response) &#123;<br>        <span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span> = response.<span class="hljs-keyword">data</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">data</span>.openid || !<span class="hljs-keyword">data</span>.session_key || <span class="hljs-keyword">data</span>.errcode) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                result: -<span class="hljs-number">2</span>,<br>                errmsg: <span class="hljs-keyword">data</span>.errmsg || <span class="hljs-string">&#x27;返回数据字段不完整&#x27;</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span><br>        &#125;<br>    &#125;);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>3. 生成3rd_session</strong></p><p>前面说过通过<code>session_key</code>来“间接”地维护登录态，所谓间接，也就是我们需要<strong>自己维护用户的登录态信息</strong>，这里也是考虑到安全性因素，如果直接使用微信服务端派发的session_key来作为业务方的登录态使用，会被“有心之人”用来获取用户的敏感信息，比如wx.getUserInfo()这个接口呢，就需要session_key来配合解密微信用户的敏感信息。</p><p>那么我们如果生成自己的登录态标识呢，这里可以使用几种常见的不可逆的哈希算法，比如md5、sha1等，将生成后的登录态标识（这里我们统称为’skey’）返回给前端，并在前端维护这份登录态标识(一般是存入storage)。而在服务端呢，我们会把生成的skey存在用户对应的数据表中，前端通过传递skey来存取用户的信息。</p><p>可以看到这里我们使用了sha1算法来生成了一个skey：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<br><br><span class="hljs-keyword">return</span> getSessionKey(code, appid, secret)<br>    .then(<span class="hljs-function"><span class="hljs-params">resData</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 选择加密算法生成自己的登录态标识</span><br>        <span class="hljs-keyword">const</span> &#123; session_key &#125; = resData;<br>        <span class="hljs-keyword">const</span> skey = encryptSha1(session_key);<br>    &#125;);<br>    <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encryptSha1</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> crypto.createHash(<span class="hljs-string">&#x27;sha1&#x27;</span>).update(data, <span class="hljs-string">&#x27;utf8&#x27;</span>).digest(<span class="hljs-string">&#x27;hex&#x27;</span>)<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>4. checkSession</strong></p><p>前面我们将skey存入前端的storage里，每次进行用户数据请求时会带上skey，那么如果此时session_key过期呢？所以我们需要调用到wx.checkSession()这个API来校验当前session_key是否已经过期，这个API并不需要传入任何有关session_key的信息参数，而是微信小程序自己去调自己的服务来查询用户最近一次生成的session_key是否过期。如果当前session_key过期，就让用户来重新登录，更新session_key，并将最新的skey存入用户数据表中。</p><p>checkSession这个步骤呢，我们一般是放在小程序启动时就校验登录态的逻辑处，这里贴个校验登录态的流程图：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/8/162a3f3836d66f11~tplv-t2oaga2asx-watermark.awebp" alt="img2"></p><p>下面代码即校验登录态的简单流程：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">let loginFlag = wx.getStorageSync(<span class="hljs-string">&#x27;skey&#x27;</span>);<br><span class="hljs-keyword">if</span> (loginFlag) &#123;<br>    <span class="hljs-regexp">//</span> 检查 session_key 是否过期<br>    wx.checkSession(&#123;<br>        <span class="hljs-regexp">//</span> session_key 有效(未过期)<br>        success: <span class="hljs-keyword">function</span>() &#123;<br>            <span class="hljs-regexp">//</span> 业务逻辑处理<br>        &#125;,<br>    <br>        <span class="hljs-regexp">//</span> session_key 过期<br>        fail: <span class="hljs-keyword">function</span>() &#123;<br>            <span class="hljs-regexp">//</span> session_key过期，重新登录<br>            doLogin();<br>        &#125;<br>    &#125;);<br>) <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-regexp">//</span> 无skey，作为首次登录<br>    doLogin();<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><strong>5. 支持emoji表情存储</strong></p><p>如果需要将用户微信名存入数据表中，那么就确认数据表及数据列的编码格式。因为用户微信名可能会包含emoji图标，而常用的UTF8编码只支持1-3个字节，emoji图标刚好是4个字节的编码进行存储。</p><p>这里有两种方式(以mysql为例)：</p><p>1.设置存储字符集</p><p>在mysql5.5.3版本后，支持将数据库及数据表和数据列的字符集设置为<code>utf8mb4</code>，因此可在<code>/etc/my.cnf</code>设置默认字符集编码及服务端编码格式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// my.cnf<br><br>[client]<br><span class="hljs-keyword">default</span>-<span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>=utf8mb4<br>[mysql]<br><span class="hljs-keyword">default</span>-<span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>=utf8mb4<br>[mysqld]<br><span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>-client-handshake = <span class="hljs-keyword">FALSE</span><br><span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>-<span class="hljs-keyword">server</span>=utf8mb4<br><span class="hljs-keyword">collation</span>-<span class="hljs-keyword">server</span>=utf8mb4_unicode_ci<br>复制代码<br></code></pre></td></tr></table></figure><p>设置完默认字符集编码及服务端字符集编码，如果是对已经存在的表和字段进行编码转换，需要执行下面几个步骤：</p><ul><li>设置数据库字符集为<code>utf8mb4</code></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> 数据库名称 <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> = utf8mb4 <span class="hljs-keyword">COLLATE</span> = utf8mb4_unicode_ci;<br><br>复制代码<br></code></pre></td></tr></table></figure><ul><li>设置数据表字符集为<code>utf8mb4</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 数据表名称 <span class="hljs-keyword">CONVERT</span> <span class="hljs-keyword">TO</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci;<br><br>复制代码<br></code></pre></td></tr></table></figure><ul><li>设置数据列字段字符集为<code>utf8mb4</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 数据表名称 CHANGE 字段列名称 <span class="hljs-type">VARCHAR</span>(n) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci;<br><br>复制代码<br></code></pre></td></tr></table></figure><p>这里的<code>COLLATE</code>指的是排序字符集，也就是用来对存储的字符进行排序和比较的，<code>utf8mb4</code>常用的collation有两种：<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_general_ci</code>，一般建议使用<code>utf8mb4_unicode_ci</code>，因为它是基于标准的<code>Unicode Collation Algorithm(UCA)</code>来排序的，可以在各种语言进行精确排序。这两种排序方式的具体区别可以参考：<a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/766809/whats-the-difference-between-utf8-general-ci-and-utf8-unicode-ci">What’s the difference between utf8_general_ci and utf8_unicode_ci</a></p><ol><li>通过使用sequelize对emoji字符进行编码入库，使用时再进行解码</li></ol><p>这里是sequelize的配置，可参考<a href="https://link.juejin.cn/?target=http://docs.sequelizejs.com/class/lib/sequelize.js~Sequelize.html">Sequelize文档</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">&#123;<br>       dialec<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;mysql&#x27;</span>,    // 数据库类型<br>       dialectOption<span class="hljs-variable">s:</span> &#123;    <br>         charse<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;utf8mb4&#x27;</span>,<br>         collate: <span class="hljs-string">&quot;utf8mb4_unicode_ci&quot;</span><br>      &#125;,<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>前面讲了微信小程序如何接入微信登录态标识的详细流程，那么如何获取小程序中的用户数据以及对用户敏感数据进行解密，并保证用户数据的完整性，我将在下一篇文章给大家做一个详细地介绍。</p><p>作者：腾讯IVWEB团队<br>链接：<a href="https://juejin.cn/post/6844903588498522120">https://juejin.cn/post/6844903588498522120</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组去重的方法</title>
    <link href="/2021/09/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <url>/2021/09/05/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> arr =  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h3 id="0、-new-Set-扩展运算符-Array-from-gt-gt-gt-important"><a href="#0、-new-Set-扩展运算符-Array-from-gt-gt-gt-important" class="headerlink" title="0、 new Set + 扩展运算符 || Array.from  ===&gt;&gt;&gt;important"></a><strong>0、 new Set + 扩展运算符 || Array.from</strong>  ===&gt;&gt;&gt;important</h3><p>ES6 提供了新的数据结构 Set。类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，可以接受一个具有 iterable 接口数据结构作为参数（如数组，字符串），用来初始化。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> = [...<span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>(arr)];      <span class="hljs-comment">// [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]</span><br><br>let <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> = <span class="hljs-keyword">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>(arr));      <span class="hljs-comment">// [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]</span><br><br>let <span class="hljs-keyword">new</span><span class="hljs-type">Str</span> = [...<span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>(<span class="hljs-string">&#x27;ababbc&#x27;</span>)].join(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">//  &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="1、利用对象的-key-唯一"><a href="#1、利用对象的-key-唯一" class="headerlink" title="1、利用对象的 key 唯一"></a><strong>1、利用对象的 key 唯一</strong></h3><p>众所周知，对象的key不可重复，否则后者将覆盖前者。利用该特性，实现数组去重，遍历数组，将数组的每一项做为对象的key值。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span> = &#123;&#125;;<br>for (<span class="hljs-keyword">let</span> <span class="hljs-attr">i</span> = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">item</span> = arr[i]<br>  <span class="hljs-keyword">if</span> (obj[item] !== undefined) &#123;<br>    arr.splice(i, <span class="hljs-number">1</span>);<br>    i--; // 解决删除元素后，数组塌陷问题<br>    continue;<br>  &#125;<br>  obj[item] = item<br>&#125;<br><br>// arr: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h3 id="2、交换元素位置从而替换调-splice方法"><a href="#2、交换元素位置从而替换调-splice方法" class="headerlink" title="2、交换元素位置从而替换调 splice方法"></a><strong>2、交换元素位置从而替换调 splice方法</strong></h3><p>上述方法存在一定的性能问题，也就是说，基于splice实现删除性能不太好，当前项被删除后，随后每一项的索引都要向前移动一位，数据量较庞大时，一定会影响性能。基于以上考虑，交换元素的位置，效率会更高一点，若当前元素重复，则与数组最后一位元素交换位置，i–再次进行判断即可，同时length–,操作数组的长度实现删除数组的最后一个元素，这样便不会影响到数组中其他元素。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript">let obj = &#123;&#125;;<br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>  let <span class="hljs-built_in">item</span> = arr[i]<br>  <span class="hljs-keyword">if</span> (obj[<span class="hljs-built_in">item</span>] !== undefined) &#123;<br>    arr[i] = arr[arr.<span class="hljs-built_in">length</span><span class="hljs-number">-1</span>]<br>    arr.<span class="hljs-built_in">length</span><span class="hljs-comment">--;</span><br>    i<span class="hljs-comment">--; </span><br>    <span class="hljs-keyword">continue</span>;<br>  &#125;<br>  obj[<span class="hljs-built_in">item</span>] = <span class="hljs-built_in">item</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、Array-filter-Array-indexOf"><a href="#3、Array-filter-Array-indexOf" class="headerlink" title="3、Array.filter + Array.indexOf"></a><strong>3、Array.filter + Array.indexOf</strong></h3><p>filter() 方法：创建一个新数组，新数组中的元素是指定数组中符合某种条件的所有元素。如果没有符合条件的元素则返回空数组。语法：array.filter(function(item,index,arr))</p><p>*<strong>filter() 不会对空数组进行检测。*</strong></p><p>*<strong>filter() 不会改变原始数组。*</strong></p><p>原理：返回 item 第一次出现的位置等于当前的index的元素</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> newArr = arr<span class="hljs-built_in">.filter</span>((<span class="hljs-type">item</span>, index) =&gt; arr.indexOf(<span class="hljs-type">item</span>) === index);  <br></code></pre></td></tr></table></figure><h3 id="4、Array-indexOf"><a href="#4、Array-indexOf" class="headerlink" title="4、Array.indexOf"></a><strong>4、Array.indexOf</strong></h3><p>indexOf() 方法：返回数组中某个指定的元素位置。该方法遍历数组，查找有无对应元素并返回元素第一次出现的索引，未找到指定元素则返回 -1。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> = []<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.indexOf(arr[i]) === <span class="hljs-number">-1</span>) <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.push(arr[i])  <br>&#125;<br><br><span class="hljs-comment">//等同于 forEach 写法</span><br>arr.forEach( item =&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.indexOf(item) === <span class="hljs-number">-1</span> ? <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.push(item) : <span class="hljs-type"></span>&#x27;<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">console.log(newArr)  // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]</span><br></code></pre></td></tr></table></figure><h3 id="5、-Array-includes"><a href="#5、-Array-includes" class="headerlink" title="5、 Array.includes"></a><strong>5、 Array.includes</strong></h3><p>includes() 方法：用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> = []<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.includes(arr[i]))  <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.push(arr[i])<br>&#125;<br><br><span class="hljs-comment">//等同于 forEach 写法</span><br>arr.forEach( item =&gt; !<span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.includes(item) ? <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.push(item) : <span class="hljs-type"></span>&#x27;<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">console.log(newArr)  // [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]</span><br></code></pre></td></tr></table></figure><h3 id="6、-new-Set-扩展运算符-Array-from"><a href="#6、-new-Set-扩展运算符-Array-from" class="headerlink" title="6、 new Set + 扩展运算符 || Array.from"></a><strong>6、 new Set + 扩展运算符 || Array.from</strong></h3><p>ES6 提供了新的数据结构 Set。类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，可以接受一个具有 iterable 接口数据结构作为参数（如数组，字符串），用来初始化。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">let <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> = [...<span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>(arr)];      <span class="hljs-comment">// [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]</span><br><br>let <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> = <span class="hljs-keyword">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>(arr));      <span class="hljs-comment">// [1, 2, 4, null, &quot;3&quot;, &quot;abc&quot;, 3, 5]</span><br><br>let <span class="hljs-keyword">new</span><span class="hljs-type">Str</span> = [...<span class="hljs-keyword">new</span> <span class="hljs-type">Set</span>(<span class="hljs-string">&#x27;ababbc&#x27;</span>)].join(<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment">//  &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="7、new-Map"><a href="#7、new-Map" class="headerlink" title="7、new Map"></a><strong>7、new Map</strong></h3><p>ES6 提供了新的数据结构 Map 。类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。get方法读取key对应的键值，如果找不到key，返回undefined。has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> Map();<br><span class="hljs-built_in">let</span> newStr = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">map</span>.has(arr[i])) &#123;<br>        <span class="hljs-built_in">map</span>.set(arr[i], <span class="hljs-literal">true</span>);<br>        newStr.<span class="hljs-built_in">push</span>(arr[i]);<br>    &#125;<br>&#125;<br>console.<span class="hljs-built_in">log</span>(newArr)  // [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, null, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios学习记录</title>
    <link href="/2021/09/01/Axios%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/09/01/Axios%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="axios学习记录"><a href="#axios学习记录" class="headerlink" title="axios学习记录"></a>axios学习记录</h3><p>官方地址 <a href="https://axios-http.com/zh/docs/intro">https://axios-http.com/zh/docs/intro</a></p><p>Axios 是一个基于 <em><a href="https://javascript.info/promise-basics">promise</a></em> 网络请求库，作用于<a href="https://nodejs.org/"><code>node.js</code></a> 和浏览器中。 它是 <em><a href="https://www.lullabot.com/articles/what-is-an-isomorphic-application">isomorphic</a></em> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>从浏览器创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a></li><li>从 node.js 创建 <a href="http://nodejs.org/api/http.html">http</a> 请求</li><li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用 npm:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install axios<br></code></pre></td></tr></table></figure><p>使用 bower:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ bower install axios<br></code></pre></td></tr></table></figure><p>使用 yarn:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yarn add axios<br></code></pre></td></tr></table></figure><p>使用 jsDelivr CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 unpkg CDN:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="执行get请求"><a href="#执行get请求" class="headerlink" title="执行get请求"></a>执行get请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 上述请求也可以按以下方式完成（可选）</span><br>axios.get(<span class="hljs-string">&#x27;/user&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;<br>      <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span><br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(response);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 总是会执行</span><br>  &#125;);  <br><br><span class="hljs-comment">// 支持async/await用法</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUser</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;/user?ID=12345&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(response);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-built_in">console</span>.error(error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="发起一个-POST-请求"><a href="#发起一个-POST-请求" class="headerlink" title="发起一个 POST 请求"></a>发起一个 <code>POST</code> 请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.post(<span class="hljs-string">&#x27;/user&#x27;</span>, &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Fred&#x27;</span>,<br>    <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Flintstone&#x27;</span><br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(response);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><h3 id="发起多个并发请求"><a href="#发起多个并发请求" class="headerlink" title="发起多个并发请求"></a>发起多个并发请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserAccount</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">&#x27;/user/12345&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUserPermissions</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> axios.get(<span class="hljs-string">&#x27;/user/12345/permissions&#x27;</span>);<br>&#125;<br><br><span class="hljs-built_in">Promise</span>.all([getUserAccount(), getUserPermissions()])<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> acct = results[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> perm = results[<span class="hljs-number">1</span>];<br>  &#125;);<br><br><br><br></code></pre></td></tr></table></figure><h3 id="也可以通过向-axios-传递相关配置来创建请求"><a href="#也可以通过向-axios-传递相关配置来创建请求" class="headerlink" title="也可以通过向 axios 传递相关配置来创建请求"></a>也可以通过向 <code>axios</code> 传递相关配置来创建请求</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 发起一个post请求</span><br>axios(&#123;<br>  method: &#x27;post&#x27;,<br>  url: &#x27;/user/<span class="hljs-number">1234</span>5&#x27;,<br>  data: &#123;<br>    firstName: &#x27;Fred&#x27;,<br>    lastName: &#x27;Flintstone&#x27;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h2><p>参见官网<a href="https://axios-http.com/zh/docs/req_config">https://axios-http.com/zh/docs/req_config</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-comment">// `url` 是用于请求的服务器 URL</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br><br>  <span class="hljs-comment">// `method` 是创建请求时使用的方法</span><br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-comment">// 默认值</span><br><br>  <span class="hljs-comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span><br>  <span class="hljs-comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span><br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://some-domain.com/api/&#x27;</span>,<br><br>  <span class="hljs-comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span><br>  <span class="hljs-comment">// 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span><br>  <span class="hljs-comment">// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream</span><br>  <span class="hljs-comment">// 你可以修改请求头。</span><br>  <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, headers</span>) </span>&#123;<br>    <span class="hljs-comment">// 对发送的 data 进行任意转换处理</span><br><br>    <span class="hljs-keyword">return</span> data;<br>  &#125;],<br><br>  <span class="hljs-comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br>  <span class="hljs-attr">transformResponse</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// 对接收的 data 进行任意转换处理</span><br><br>    <span class="hljs-keyword">return</span> data;<br>  &#125;],<br><br>  <span class="hljs-comment">// 自定义请求头</span><br>  <span class="hljs-attr">headers</span>: &#123;<span class="hljs-string">&#x27;X-Requested-With&#x27;</span>: <span class="hljs-string">&#x27;XMLHttpRequest&#x27;</span>&#125;,<br><br>  <span class="hljs-comment">// `params` 是与请求一起发送的 URL 参数</span><br>  <span class="hljs-comment">// 必须是一个简单对象或 URLSearchParams 对象</span><br>  <span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span><br>  &#125;,<br><br>  <span class="hljs-comment">// `paramsSerializer`是可选方法，主要用于序列化`params`</span><br>  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br>  <span class="hljs-attr">paramsSerializer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> Qs.stringify(params, &#123;<span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">&#x27;brackets&#x27;</span>&#125;)<br>  &#125;,<br><br>  <span class="hljs-comment">// `data` 是作为请求体被发送的数据</span><br>  <span class="hljs-comment">// 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法</span><br>  <span class="hljs-comment">// 在没有设置 `transformRequest` 时，则必须是以下类型之一:</span><br>  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br>  <span class="hljs-comment">// - 浏览器专属: FormData, File, Blob</span><br>  <span class="hljs-comment">// - Node 专属: Stream, Buffer</span><br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Fred&#x27;</span><br>  &#125;,<br>  <br>  <span class="hljs-comment">// 发送请求体数据的可选语法</span><br>  <span class="hljs-comment">// 请求方式 post</span><br>  <span class="hljs-comment">// 只有 value 会被发送，key 则不会</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;</span>,<br><br>  <span class="hljs-comment">// `timeout` 指定请求超时的毫秒数。</span><br>  <span class="hljs-comment">// 如果请求时间超过 `timeout` 的值，则请求会被中断</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>, <span class="hljs-comment">// 默认值是 `0` (永不超时)</span><br><br>  <span class="hljs-comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span><br>  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// default</span><br><br>  <span class="hljs-comment">// `adapter` 允许自定义处理请求，这使测试更加容易。</span><br>  <span class="hljs-comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。</span><br>  <span class="hljs-attr">adapter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>&#123;<br>    <span class="hljs-comment">/* ... */</span><br>  &#125;,<br><br>  <span class="hljs-comment">// `auth` HTTP Basic Auth</span><br>  <span class="hljs-attr">auth</span>: &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;janedoe&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;s00pers3cret&#x27;</span><br>  &#125;,<br><br>  <span class="hljs-comment">// `responseType` 表示浏览器将要响应的数据类型</span><br>  <span class="hljs-comment">// 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span><br>  <span class="hljs-comment">// 浏览器专属：&#x27;blob&#x27;</span><br>  <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 默认值</span><br><br>  <span class="hljs-comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span><br>  <span class="hljs-comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span><br>  <span class="hljs-comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span><br>  <span class="hljs-attr">responseEncoding</span>: <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-comment">// 默认值</span><br><br>  <span class="hljs-comment">// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称</span><br>  <span class="hljs-attr">xsrfCookieName</span>: <span class="hljs-string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// 默认值</span><br><br>  <span class="hljs-comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span><br>  <span class="hljs-attr">xsrfHeaderName</span>: <span class="hljs-string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="hljs-comment">// 默认值</span><br><br>  <span class="hljs-comment">// `onUploadProgress` 允许为上传处理进度事件</span><br>  <span class="hljs-comment">// 浏览器专属</span><br>  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;<br>    <span class="hljs-comment">// 处理原生进度事件</span><br>  &#125;,<br><br>  <span class="hljs-comment">// `onDownloadProgress` 允许为下载处理进度事件</span><br>  <span class="hljs-comment">// 浏览器专属</span><br>  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>&#123;<br>    <span class="hljs-comment">// 处理原生进度事件</span><br>  &#125;,<br><br>  <span class="hljs-comment">// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数</span><br>  <span class="hljs-attr">maxContentLength</span>: <span class="hljs-number">2000</span>,<br><br>  <span class="hljs-comment">// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数</span><br>  <span class="hljs-attr">maxBodyLength</span>: <span class="hljs-number">2000</span>,<br><br>  <span class="hljs-comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span><br>  <span class="hljs-comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span><br>  <span class="hljs-comment">// 则promise 将会 resolved，否则是 rejected。</span><br>  <span class="hljs-attr">validateStatus</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// 默认值</span><br>  &#125;,<br><br>  <span class="hljs-comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span><br>  <span class="hljs-comment">// 如果设置为0，则不会进行重定向</span><br>  <span class="hljs-attr">maxRedirects</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 默认值</span><br><br>  <span class="hljs-comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span><br>  <span class="hljs-comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span><br>  <span class="hljs-comment">// 只能指定 `socketPath` 或 `proxy` 。</span><br>  <span class="hljs-comment">// 若都指定，这使用 `socketPath` 。</span><br>  <span class="hljs-attr">socketPath</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// default</span><br><br>  <span class="hljs-comment">// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span><br>  <span class="hljs-comment">// and https requests, respectively, in node.js. This allows options to be added like</span><br>  <span class="hljs-comment">// `keepAlive` that are not enabled by default.</span><br>  <span class="hljs-attr">httpAgent</span>: <span class="hljs-keyword">new</span> http.Agent(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),<br>  <span class="hljs-attr">httpsAgent</span>: <span class="hljs-keyword">new</span> https.Agent(&#123; <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> &#125;),<br><br>  <span class="hljs-comment">// `proxy` 定义了代理服务器的主机名，端口和协议。</span><br>  <span class="hljs-comment">// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。</span><br>  <span class="hljs-comment">// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。</span><br>  <span class="hljs-comment">// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。</span><br>  <span class="hljs-comment">// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。</span><br>  <span class="hljs-comment">// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`</span><br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-attr">protocol</span>: <span class="hljs-string">&#x27;https&#x27;</span>,<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,<br>    <span class="hljs-attr">auth</span>: &#123;<br>      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;mikeymike&#x27;</span>,<br>      <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;rapunz3l&#x27;</span><br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// see https://axios-http.com/zh/docs/cancellation</span><br>  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) </span>&#123;<br>  &#125;),<br><br>  <span class="hljs-comment">// `decompress` indicates whether or not the response body should be decompressed </span><br>  <span class="hljs-comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header </span><br>  <span class="hljs-comment">// from the responses objects of all decompressed responses</span><br>  <span class="hljs-comment">// - Node only (XHR cannot turn off decompression)</span><br>  <span class="hljs-attr">decompress</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 默认值</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在请求或响应被 then 或 catch 处理前拦截它们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加请求拦截器</span><br>axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>&#123;<br>    <span class="hljs-comment">// 在发送请求之前做些什么</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>  &#125;);<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-comment">// 2xx 范围内的状态码都会触发该函数。</span><br>    <span class="hljs-comment">// 对响应数据做点什么</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-comment">// 超出 2xx 范围的状态码都会触发该函数。</span><br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="取消请求（还没用过。。）"><a href="#取消请求（还没用过。。）" class="headerlink" title="取消请求（还没用过。。）"></a>取消请求（还没用过。。）</h2><p>使用 <em>cancel token</em> 取消一个请求。</p><blockquote><p>Axios 的 cancel token API 是基于被撤销 <a href="https://github.com/tc39/proposal-cancelable-promises">cancelable promises proposal</a>。</p></blockquote><p>可以使用 <code>CancelToken.source</code> 工厂方法创建一个 cancel token ，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<br><span class="hljs-keyword">const</span> source = CancelToken.source();<br><br>axios.get(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;<br>  <span class="hljs-attr">cancelToken</span>: source.token<br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thrown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (axios.isCancel(thrown)) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Request canceled&#x27;</span>, thrown.message);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>  &#125;<br>&#125;);<br><br>axios.post(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;new name&#x27;</span><br>&#125;, &#123;<br>  <span class="hljs-attr">cancelToken</span>: source.token<br>&#125;)<br><br><span class="hljs-comment">// 取消请求（message 参数是可选的）</span><br>source.cancel(<span class="hljs-string">&#x27;Operation canceled by the user.&#x27;</span>);<br></code></pre></td></tr></table></figure><p>也可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建一个 cancel token：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<br><span class="hljs-keyword">let</span> cancel;<br><br>axios.get(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;<br>  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>) </span>&#123;<br>    <span class="hljs-comment">// executor 函数接收一个 cancel 函数作为参数</span><br>    cancel = c;<br>  &#125;)<br>&#125;);<br><br><span class="hljs-comment">// 取消请求</span><br>cancel();<br></code></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 封装axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-comment">// import &#123; Message &#125; from &#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><br><span class="hljs-keyword">import</span> &#123; getToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span><br><br><span class="hljs-keyword">const</span> service = axios.create(&#123;<br>  <span class="hljs-comment">// baseURL: process.env.BASE_API, // api的base_url</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span> <span class="hljs-comment">// 请求超时时间</span><br>&#125;)<br><br><span class="hljs-comment">// 请求拦截器,通过vuex查询是否有token,有则对每一个请求头部加上 token字段,error则通过Promise返回error</span><br>service.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (store.getters.token) &#123;<br>    config.headers[<span class="hljs-string">&#x27;X-token&#x27;</span>] = getToken()<br>  &#125;<br>  <span class="hljs-keyword">return</span> config<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(error)<br>  <span class="hljs-built_in">Promise</span>.reject(error)<br>&#125;)<br><br><span class="hljs-comment">// 响应拦截器,通过 response定义的code来标志请求的状态,you can do something</span><br>service.interceptors.response.use(<br>  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response,<br>  <span class="hljs-comment">//  const res = response.data;</span><br>  <span class="hljs-comment">//     if (res.code !== 20000) &#123;</span><br>  <span class="hljs-comment">//       Message(&#123;</span><br>  <span class="hljs-comment">//         message: res.message,</span><br>  <span class="hljs-comment">//         type: &#x27;error&#x27;,</span><br>  <span class="hljs-comment">//         duration: 5 * 1000</span><br>  <span class="hljs-comment">//       &#125;);</span><br>  <span class="hljs-comment">//       // 50008:非法的token; 50012:其他客户端登录了;  50014:Token 过期了;</span><br>  <span class="hljs-comment">//       if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123;</span><br>  <span class="hljs-comment">//         MessageBox.confirm(&#x27;你已被登出，可以取消继续留在该页面，或者重新登录&#x27;, &#x27;确定登出&#x27;, &#123;</span><br>  <span class="hljs-comment">//           confirmButtonText: &#x27;重新登录&#x27;,</span><br>  <span class="hljs-comment">//           cancelButtonText: &#x27;取消&#x27;,</span><br>  <span class="hljs-comment">//           type: &#x27;warning&#x27;</span><br>  <span class="hljs-comment">//         &#125;).then(() =&gt; &#123;</span><br>  <span class="hljs-comment">//           store.dispatch(&#x27;FedLogOut&#x27;).then(() =&gt; &#123;</span><br>  <span class="hljs-comment">//             location.reload();// 为了重新实例化vue-router对象 避免bug</span><br>  <span class="hljs-comment">//           &#125;);</span><br>  <span class="hljs-comment">//         &#125;)</span><br>  <span class="hljs-comment">//       &#125;</span><br>  <span class="hljs-comment">//       return Promise.reject(&#x27;error&#x27;);</span><br>  <span class="hljs-comment">//     &#125; else &#123;</span><br>  <span class="hljs-comment">//       return response.data;</span><br>  <span class="hljs-comment">//     &#125;</span><br><br>  <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">Promise</span>.reject(err)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见网站攻击 （未完成）</title>
    <link href="/2021/08/21/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%AB%99%E6%94%BB%E5%87%BB/"/>
    <url>/2021/08/21/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%AB%99%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="1、SQL-注入"><a href="#1、SQL-注入" class="headerlink" title="1、SQL 注入"></a>1、SQL 注入</h2><p>SQL注入攻击的核心在于让Web服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。</p><p>而如何让Web服务器执行攻击者的SQL语句呢？SQL注入的常规套路在于将SQL语句放置于Form表单或请求参数之中提交到后端服务器，后端服务器如果未做输入安全校验，直接将变量取出进行数据库查询，则极易中招。</p><h2 id="2、XSS-攻击"><a href="#2、XSS-攻击" class="headerlink" title="2、XSS 攻击"></a>2、XSS 攻击</h2><p>XSS全称跨站脚本攻击（Cross Site Scripting），为了与重叠样式表CSS区分，换了另一个缩写XSS。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue中引入markdown编辑器</title>
    <link href="/2021/08/20/vue%E4%B8%AD%E5%BC%95%E5%85%A5markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2021/08/20/vue%E4%B8%AD%E5%BC%95%E5%85%A5markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p><p>Markdown 语法很简单，可以直接上手使用。教程 <a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p><h2 id="我在vue的项目中想引入MarkDown编辑器"><a href="#我在vue的项目中想引入MarkDown编辑器" class="headerlink" title="我在vue的项目中想引入MarkDown编辑器"></a>我在vue的项目中想引入MarkDown编辑器</h2><h4 id="在自己搭建的后台模板中的-效果展示如下"><a href="#在自己搭建的后台模板中的-效果展示如下" class="headerlink" title="在自己搭建的后台模板中的 效果展示如下"></a>在自己搭建的后台模板中的 效果展示如下</h4><p><img src="http://101.200.87.232:9000/test/Snipaste_2021-10-23_13-49-56.png"></p><p><strong>Markdown用途</strong>  Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 用于编写说明文档，并且以“README.md”的文件名保存在软件的目录下面。 除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p><h3 id="项目中使用方法"><a href="#项目中使用方法" class="headerlink" title="项目中使用方法"></a>项目中使用方法</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install mavon-editor<span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br><span class="hljs-comment">// 导入组件 及 组件样式</span><br><span class="hljs-keyword">import</span> &#123; mavonEditor &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mavon-editor&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;mavon-editor/dist/css/index.css&#x27;</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;mavon-editor <br>            v-model=&quot;content&quot; <br>            ref=&quot;md&quot; <br>            @change=&quot;change&quot; <br>            style=&quot;min-height: 600px&quot;<br>        /&gt;<br><br>        &lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br><br><br>&lt;script&gt;<br>export default &#123;<br>    // 注册<br>    components: &#123;<br>        mavonEditor,<br>    &#125;,<br>    data() &#123;<br>        return &#123;<br>            content:&#x27;&#x27;, // 输入的markdown<br>            html:&#x27;&#x27;,    // 及时转的html<br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        // 所有操作都会被解析重新渲染<br>        change(value, render)&#123;<br>            // render 为 markdown 解析后的结果[html]<br>            this.html = render;<br>        &#125;,<br>        // 提交<br>        submit()&#123;<br>            console.log(this.content);<br>            console.log(this.html);<br>        &#125;<br>    &#125;,<br>    mounted() &#123;<br><br>    &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>怎么支持添加图片<ul><li>首先监听输入框的变化，如果遇到图片的话，把图片上传到服务器，获取到线上地址，对其进行展示</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mavon-editor</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;md&quot;</span> @<span class="hljs-attr">imgAdd</span>=<span class="hljs-string">&quot;$imgAdd&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;change&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;min-height: 600px&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 将图片上传到服务器，返回地址替换到md中</span></span><br><span class="javascript">    $imgAdd(pos, $file)&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> formdata = <span class="hljs-keyword">new</span> FormData();</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">this</span>.$upload.post(<span class="hljs-string">&#x27;/上传接口地址&#x27;</span>, formdata).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(res.data);</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.$refs.md.$img2Url(pos, res.data);</span><br><span class="javascript">    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(err)</span><br><span class="javascript">    &#125;)</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>感谢包的创作者！！！</p><p>npm 包地址  <a href="https://www.npmjs.com/package/mavon-editor">https://www.npmjs.com/package/mavon-editor</a> </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>MarkDown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>path.join()和path.resolve()的区别</title>
    <link href="/2021/08/15/path.join()%E5%92%8Cpath.resolve()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/08/15/path.join()%E5%92%8Cpath.resolve()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="path-join-和path-resolve-的区别"><a href="#path-join-和path-resolve-的区别" class="headerlink" title="path.join()和path.resolve()的区别"></a>path.join()和path.resolve()的区别</h1><h5 id="path-join"><a href="#path-join" class="headerlink" title="path.join()"></a>path.join()</h5><p>path.join():方法使用平台特定的分隔符[Unix系统是/，Windows系统是\ ]把全部给定的 path 片段连接到一起，并规范化生成的路径。若任意一个路径片段类型错误，会报错。 例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle">__dirname<br><span class="hljs-comment">// __dirname返回当前文件所在的绝对路径</span><br>const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br>const path1 = path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">&#x27;/foo&#x27;</span>);<br>const path2 = path.<span class="hljs-keyword">join</span>(__dirname, <span class="hljs-string">&#x27;./foo/bar&#x27;</span>);<br>const path3 = path.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;/baz/apple&#x27;</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>);<br>const path4 = path.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>);<br><br><br>console.log(path1);<br>console.log(path2);<br>console.log(path3);<br>console.log(path4);<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test/foo<br><span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test<span class="hljs-regexp">/foo/</span>bar<br><span class="hljs-regexp">/foo/</span>bar<span class="hljs-regexp">/baz/</span>apple<br>foo<span class="hljs-regexp">/bar/</span>baz<br>复制代码<br></code></pre></td></tr></table></figure><p>不合法的字符串将抛出异常</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const path5 = <span class="hljs-type">path</span>.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, &#123;&#125;, <span class="hljs-string">&#x27;bar&#x27;</span>);<br>// TypeError [ERR_INVALID_ARG_TYPE]: The &quot;path&quot; argument must be <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> string. Received <span class="hljs-keyword">type</span> <span class="hljs-keyword">object</span><br>复制代码<br></code></pre></td></tr></table></figure><p>如果连接后的路径字符串是一个长度为零的字符串，则返回 ‘.’，表示当前工作目录。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">path.join(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>)<br><span class="hljs-regexp">//</span> 返回结果为<br><span class="hljs-string">&#x27;.&#x27;</span><br>复制代码<br></code></pre></td></tr></table></figure><h5 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve()"></a>path.resolve()</h5><p>path.resolve:方法会把一个路径或路径片段的序列解析为一个绝对路径。 例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">const path = require(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br>const path1 = path.resolve(<span class="hljs-string">&#x27;/a/b&#x27;</span>, <span class="hljs-string">&#x27;/c/d&#x27;</span>);<br><span class="hljs-regexp">//</span> 结果： <span class="hljs-regexp">/c/</span>d<br>const path2 = path.resolve(<span class="hljs-string">&#x27;/a/b&#x27;</span>, <span class="hljs-string">&#x27;c/d&#x27;</span>);<br><span class="hljs-regexp">//</span> 输出： <span class="hljs-regexp">/a/</span>b<span class="hljs-regexp">/c/</span>d<br>const path3 = path.resolve(<span class="hljs-string">&#x27;/a/b&#x27;</span>, <span class="hljs-string">&#x27;../c/d&#x27;</span>);<br><span class="hljs-regexp">//</span> 输出： <span class="hljs-regexp">/a/</span>c/d<br>const path4 = path.resolve(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-regexp">//</span> 输出： <span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test<span class="hljs-regexp">/a/</span>b<br>复制代码<br></code></pre></td></tr></table></figure><blockquote><p>resolve把‘／’当成根目录 path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，与cd操作不同的是，这引起路径可以是文件，并且可不必实际存在（resolve()方法不会利用底层的文件系统判断路径是否存在，而只是进行路径字符串操作）;</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">path.resolve(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;../public&#x27;</span>, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>);<br><span class="hljs-regexp">//</span> cd www  <span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test/www<br><span class="hljs-regexp">//</span> cd static <span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test<span class="hljs-regexp">/www/</span>static<br><span class="hljs-regexp">//</span> cd ..<span class="hljs-regexp">/public /</span>Users<span class="hljs-regexp">/xiao/</span>work<span class="hljs-regexp">/test/</span>www/public<br><span class="hljs-regexp">//</span> cd src <span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test<span class="hljs-regexp">/www/</span>public/src<br><span class="hljs-regexp">//</span> cd .. <span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test<span class="hljs-regexp">/www/</span>public<br>复制代码<br></code></pre></td></tr></table></figure><p>resolve操作相当于进行了一系列的cd操作，</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>1、join是把各个path片段连接在一起， resolve把‘／’当成根目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">path.join(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-string">&#x27;/b&#x27;</span>); <br><span class="hljs-regexp">//</span> <span class="hljs-regexp">/a/</span>b<br>path.resolve(<span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-string">&#x27;/b&#x27;</span>);<br><span class="hljs-regexp">//</span> /b<br>复制代码<br></code></pre></td></tr></table></figure><p>2、resolve在传入非/路径时，会自动加上当前目录形成一个绝对路径，而join仅仅用于路径拼接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 当前路径为<br><span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test<br>path.join(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>);<br><span class="hljs-regexp">//</span> a/d<br>path.resolve(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>);<br><span class="hljs-regexp">//</span> <span class="hljs-regexp">/Users/</span>xiao<span class="hljs-regexp">/work/</span>test<span class="hljs-regexp">/a/</span>d<br>复制代码<br></code></pre></td></tr></table></figure><p>可以看出resolve在传入的第一参数为非根路径时，会返回一个带当前目录路径的绝对路径。</p><p>学习于 <a href="https://juejin.cn/post/6844903861920989198">https://juejin.cn/post/6844903861920989198</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue在created钩子函数请求异步数据，在mounted钩子获取不到？</title>
    <link href="/2021/08/15/created%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/15/created%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="vue在created钩子函数请求异步数据，在mounted钩子获取不到？"><a href="#vue在created钩子函数请求异步数据，在mounted钩子获取不到？" class="headerlink" title="vue在created钩子函数请求异步数据，在mounted钩子获取不到？"></a>vue在created钩子函数请求异步数据，在mounted钩子获取不到？</h1><h3 id="恢复现场-我们在created-周期中调用了一个methods-此方法为异步请求获取数据"><a href="#恢复现场-我们在created-周期中调用了一个methods-此方法为异步请求获取数据" class="headerlink" title="恢复现场,我们在created,周期中调用了一个methods,此方法为异步请求获取数据"></a>恢复现场,我们在created,周期中调用了一个methods,此方法为异步请求获取数据</h3><p><img src="http://lxandzjy.top:9003/2021/11/11/501ac6f4e7de8.png"></p><p><img src="http://lxandzjy.top:9003/2021/11/11/05724cfc4d3d3.png"></p><p>在created周期,实例已经完成数据观测,属性,方法的运算,watch/event事件的回调,完成data数据的初始化el并没有。mounted是模板挂载</p><h3 id="在mounted周期中调用"><a href="#在mounted周期中调用" class="headerlink" title="在mounted周期中调用"></a>在mounted周期中调用</h3><p><img src="http://lxandzjy.top:9003/2021/11/11/a69e002f69161.png"></p><p>结果如下，长度为零，拿不到返回值</p><p><img src="http://lxandzjy.top:9003/2021/11/11/0e61f98183f68.png"></p><h3 id="解决方法，原因因为我们是异步请求初始化数据导致"><a href="#解决方法，原因因为我们是异步请求初始化数据导致" class="headerlink" title="解决方法，原因因为我们是异步请求初始化数据导致"></a>解决方法，原因因为我们是异步请求初始化数据导致</h3><p>  （1） 可以通过setTimeOut()设定等待一个时间，确保你的初始值都已经被初始化了，但是问题是不知道需要延迟多久，况且这个方法也不是很好。<strong>在mounted当中使用 this.$nextTick 也不好用；使用setTimeout，设置延时可以，但是在网速不好的情况下还是有问题。所以不推荐；</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mounted () &#123;<br>  <span class="hljs-keyword">this</span>.getCateTypeList()<br>  setTimeout(<span class="hljs-keyword">this</span>.getCateTypeList,<span class="hljs-number">1000</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>  （2） 通过watch，去监听这个 categoryList，再通过nextTick渲染</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">watch: &#123;<br>  categoryList(e)&#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-built_in">console</span>.log(e, <span class="hljs-string">&#x27;e&#x27;</span>);<br>    <span class="hljs-built_in">this</span>.$nextTick( <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.categoryList = e<br>      <span class="hljs-built_in">this</span>.getCateTypeList()<br>    &#125;)<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>下面了解下<code>nextTick</code>的主要应用的场景及原因。</p><ul><li>在Vue生命周期的<code>created()</code>钩子函数进行的DOM操作一定要放在<code>Vue.nextTick()</code>的回调函数中</li></ul><p>在<code>created()</code>钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进<code>Vue.nextTick()</code>的回调函数中。与之对应的就是<code>mounted()</code>钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。</p><ul><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进<code>Vue.nextTick()</code>的回调函数中。</li></ul><blockquote><p>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 <code>Promise.then</code> 和<code>MessageChannel</code>，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code>代替。</p></blockquote><blockquote><p>例如，当你设置<code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用<code>Vue.nextTick(callback)</code> 。这样回调函数在 DOM 更新完成后就会调用。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">new Vue(&#123;<br>  <span class="hljs-regexp">//</span> ...<br>  methods: &#123;<br>    <span class="hljs-regexp">//</span> ...<br>    example: <span class="hljs-keyword">function</span> () &#123;<br>      <span class="hljs-regexp">//</span> 修改数据<br>      this.message = <span class="hljs-string">&#x27;changed&#x27;</span><br>      <span class="hljs-regexp">//</span> DOM 还没有更新<br>      this.<span class="hljs-variable">$nextTick</span>(<span class="hljs-keyword">function</span> () &#123;<br>        <span class="hljs-regexp">//</span> DOM 现在更新了<br>        <span class="hljs-regexp">//</span> `this` 绑定到当前实例<br>        this.doSomethingElse()<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>必备的flex布局</title>
    <link href="/2021/08/06/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2021/08/06/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h5 id="布局的传统解决方案，基于盒状模型，依赖-display属性-position属性-float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。"><a href="#布局的传统解决方案，基于盒状模型，依赖-display属性-position属性-float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。" class="headerlink" title="布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。"></a>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display">display</a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position">position</a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float">float</a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</h5><hr><h3 id="什么是Flex布局"><a href="#什么是Flex布局" class="headerlink" title="什么是Flex布局?"></a>什么是Flex布局?</h3><p>​        Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><blockquote><p>只需要 display: flex 即可使用 felx布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​        采用flex布局的元素,被叫做 felx容器,  他的 每一个子元素 都被称为 flex的项目  (flex  item)</p><p>​                                                                                                                        图片来自菜鸟教程</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png"></p><h3 id="容器常用属性"><a href="#容器常用属性" class="headerlink" title="容器常用属性"></a>容器常用属性</h3><ol><li><p>flex-direction属性决定主轴的方向（即项目的排列方向）。            </p><ul><li>```<br>.box {<br>  flex-direction: row | row-reverse | column | column-reverse;<br>}<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">   -</span> row（默认值）：主轴为水平方向，起点在左端。<br><br><span class="hljs-bullet">   -</span> row-reverse：主轴为水平方向，起点在右端。<br><br><span class="hljs-bullet">   -</span> column：主轴为垂直方向，起点在上沿。<br><br><span class="hljs-bullet">   -</span> column-reverse：主轴为垂直方向，起点在下沿。<br><br>------<br><br><br><br><span class="hljs-bullet">2.</span> flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><span class="hljs-bullet">   -</span> nowrap（默认）：不换行。<br><span class="hljs-bullet">   -</span> wrap：换行，第一行在上方。<br><span class="hljs-bullet">   -</span> wrap-reverse：换行，第一行在下方。<br><span class="hljs-bullet">3.</span> flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，<br><br>---<br><br><span class="hljs-bullet">4.</span> justify-content属性定义了项目在主轴上的对齐方式。 在 x轴上的对齐方式<br><br><span class="hljs-bullet">   -</span> <span class="hljs-code">```</span><br><span class="hljs-code">     justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>align-items属性定义项目在交叉轴上如何对齐。  在Y轴上的对齐方式</p><ul><li><pre><code>align-items: flex-start | flex-end | center | baseline | stretch;</code></pre></li></ul></li></ol><h3 id="项目常用属性"><a href="#项目常用属性" class="headerlink" title="项目常用属性"></a>项目常用属性</h3><ol><li><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p></li><li><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p></li><li><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p></li><li><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p></li><li><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p></li><li><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VUE---前端---权限的学习笔记</title>
    <link href="/2021/08/03/vue%E6%9D%83%E9%99%90%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/08/03/vue%E6%9D%83%E9%99%90%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/harsima/article/details/77949448Vue">https://blog.csdn.net/harsima/article/details/77949448Vue</a> + ElementUI 手撸后台管理网站基本框架(二)权限控制</p><p><a href="https://zhuanlan.zhihu.com/p/227833652Vue">https://zhuanlan.zhihu.com/p/227833652Vue</a> +利用 addRoutes     动态创建路由，并在页面刷新后保留动态路由的完整 Demo</p><p><a href="https://juejin.cn/post/6844903478880370701">https://juejin.cn/post/6844903478880370701</a>  + 花裤衩  手摸手，带你用vue撸后台 系列二(登录权限篇)</p><p><a href="https://juejin.cn/post/6844903816593145864">https://juejin.cn/post/6844903816593145864</a>  +Vue中后台鉴权的另一种方案 - 动态路由</p><h3 id="权限接口的控制"><a href="#权限接口的控制" class="headerlink" title="权限接口的控制"></a>权限接口的控制</h3><p>一般来说,正常登录后,后端会返回一个token,之后的用户每次请求都应该携带者token;</p><p>对axios 进行简单的设置,增加请求拦截器,为每个请求的 header 都添加   token</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">const</span> service = axios.<span class="hljs-built_in">create</span>()<br><br><span class="hljs-comment">// http request 拦截器</span><br><span class="hljs-comment">// 每次请求都为http头增加Authorization字段，其内容为token</span><br>service.interceptors.request.<span class="hljs-built_in">use</span>(<br>    config =&gt; &#123;<br>        config.headers.Authorization = `$&#123;token&#125;`<br>        <span class="hljs-keyword">return</span> config<br>    &#125;<br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service<br></code></pre></td></tr></table></figure><h3 id="创建路由表"><a href="#创建路由表" class="headerlink" title="创建路由表"></a>创建路由表</h3><p>在创建路由表前，我们先总结一下前端路由表构成的两种模式：</p><p>同时拥有静态路由和动态路由。<br>只拥有静态路由<br>在第一种模式中，将系统中不需要权限的页面构成静态路由，需要权限的页面构成动态路由。当用户登录后，根据返回数据匹配动态路由表，将结果通过addRoutes方法添加到静态路由中。完整的路由中将只包含当前用户能访问的页面，用户无权访问的页面将直接跳转到404。（这也是我之前一直使用的模式）</p><p>第二种模式则直接将所有页面都配置到静态路由中。用户正常登录，系统将返回数据记录下来作为权限数据。当页面跳转时，判断跳转的页面是否在用户的权限列表中，如果在则正常跳转，如果不在则可以跳转到任意其他页面。</p><p>在经过不断的实践和改进后，个人认为第二种模式相对简单，只有单一的路由表，方便以后的管理和维护。同时又因无论哪种模式都不能避免所谓的“安全”问题——个别情况下跳过前端路由情况的发生，所以第二种模式无论怎么看都比第一种要好很多。</p><p>需要注意的是，在第二种模式中，因为只有单一的静态路由，所以一定要使用vue-router的懒加载策略对路由组件进行加载行为优化，防止首次加载时直接加载全部页面组件的尴尬问题。当然，你可以对那些不需要权限的固定页面不使用懒加载策略，这些页面包括登录页、注册页等。</p><p>而实现它则需要使用<code>vue</code>的自定义指令。你可以戳这里查看<code>vue</code>自定义指令的说明：<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">自定义指令</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const hasPermission = &#123;<br>    install (Vue, options)&#123;<br>        Vue<span class="hljs-selector-class">.directive</span>(<span class="hljs-string">&#x27;hasPermission&#x27;</span>, &#123;<br>            bind(el, binding, vnode)&#123;<br>                let permissionList = vnode<span class="hljs-selector-class">.context</span>.<span class="hljs-variable">$route</span><span class="hljs-selector-class">.meta</span><span class="hljs-selector-class">.permission</span><br>                <span class="hljs-keyword">if</span>(permissionList &amp;&amp; permissionList<span class="hljs-selector-class">.length</span> &amp;&amp; !permissionList<span class="hljs-selector-class">.includes</span>(binding.value))&#123;<br>                    el<span class="hljs-selector-class">.parentNode</span><span class="hljs-selector-class">.removeChild</span>(el)<br>                &#125;<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br><br>export default hasPermission<br></code></pre></td></tr></table></figure><h3 id="权限策略"><a href="#权限策略" class="headerlink" title="权限策略"></a>权限策略</h3><p>在理解了前端权限的本质后，我们说一下前端的权限策略。依照我目前的了解，大致上把权限策略分为以下两种：</p><p>前端记录所有的权限。用户登录后，后端返回用户角色，前端根据角色自行分配页面<br>前端仅记录页面，后端记录权限。用户登陆后，后端返回用户权限列表，前端根据该列表生成可访问页面<br>第一种的优点是前端完全控制，想怎么改就怎么改；缺点是当角色越来越多时，可能会给前端路由编写上带来一定的麻烦。</p><p>第二种的优点是前端完全基于后端数据，后期几乎没有维护成本；缺点是为了降低维护成本，必须拥有菜单配置页面及权限分配页面，否则就是噩梦。</p><p>接下来，将一点一点带你实现前端权限控制。</p><ol><li>路由跳转 先判断是否登录 未登录只能访问白名单页面,访问其他页面全部重定向到登录页面</li><li>登录行为触发,获取动态路由,递归解析动态路由信息,并且addRouter,同时存储到Vuex,并且记录获取路由的状态</li><li>跳转页面不会获取动态路由,刷新页面重新获取动态路由</li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/2/8/17024767cfd6c8b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="前端权限思路一"><a href="#前端权限思路一" class="headerlink" title="前端权限思路一"></a>前端权限思路一</h2><p>先mock出 用户的信息</p><h3 id="编写-mock-js"><a href="#编写-mock-js" class="headerlink" title="编写 mock.js"></a>编写 mock.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 用户信息</span><br><span class="hljs-keyword">const</span> users = [<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;student&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>    <span class="hljs-attr">photo</span>: <span class="hljs-string">&#x27;http://www.lxandzjy.top:9002/2021/06/05/f570fcf9ad636.png&#x27;</span>,<br>    <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;student-token&#x27;</span>,<br>    <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;student&#x27;</span>,<br>    <span class="hljs-attr">rights</span>: []<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<br>    <span class="hljs-attr">photo</span>: <span class="hljs-string">&#x27;http://www.lxandzjy.top:9002/2021/06/05/f570fcf9ad636.png&#x27;</span>,<br>    <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;admin-token&#x27;</span>,<br>    <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>    <span class="hljs-attr">rights</span>: []<br>  &#125;<br>  <br>  <br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript">后端响应回来不同的角色能看的 路由  ,通过 addrouters ,动态渲染上路由<br><span class="hljs-keyword">const</span> roles = &#123;<br>  <span class="hljs-attr">student</span>: [<br>    &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;基本页面&#x27;</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-connection&#x27;</span>,<br>      <span class="hljs-attr">children</span>: [<br>        &#123;<br>          <span class="hljs-attr">id</span>: <span class="hljs-number">11</span>,<br>          <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;表格页面&#x27;</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-grid&#x27;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;table&#x27;</span>,<br>          <span class="hljs-attr">rights</span>: [<span class="hljs-string">&#x27;view&#x27;</span>]<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>,<br>          <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;素材页面&#x27;</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-marketing&#x27;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;image&#x27;</span>,<br>          <span class="hljs-attr">rights</span>: [<span class="hljs-string">&#x27;view&#x27;</span>]<br>        &#125;<br>      ]<br>    &#125;<br>  ],<br>  <span class="hljs-attr">admin</span>: [<br>    &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;基本页面&#x27;</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-connection&#x27;</span>,<br>      <span class="hljs-attr">children</span>: [<br>        &#123;<br>          <span class="hljs-attr">id</span>: <span class="hljs-number">11</span>,<br>          <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;表格页面&#x27;</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-grid&#x27;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;table&#x27;</span>,<br>          <span class="hljs-attr">rights</span>: [<span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-string">&#x27;edit&#x27;</span>, <span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;delete&#x27;</span>]<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">id</span>: <span class="hljs-number">12</span>,<br>          <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;素材页面&#x27;</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-marketing&#x27;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;image&#x27;</span>,<br>          <span class="hljs-attr">rights</span>: [<span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-string">&#x27;edit&#x27;</span>, <span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;delete&#x27;</span>]<br>        &#125;<br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;用户权限&#x27;</span>,<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-set-up&#x27;</span>,<br>      <span class="hljs-attr">children</span>: [<br>        &#123;<br>          <span class="hljs-attr">id</span>: <span class="hljs-number">21</span>,<br>          <span class="hljs-attr">authName</span>: <span class="hljs-string">&#x27;权限页面&#x27;</span>,<br>          <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-custom&#x27;</span>,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;users&#x27;</span>,<br>          <span class="hljs-attr">rights</span>: [<span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-string">&#x27;edit&#x27;</span>, <span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-string">&#x27;delete&#x27;</span>]<br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写-router-js"><a href="#编写-router-js" class="headerlink" title="编写 router.js"></a>编写 router.js</h3><ul><li><p>定义一些基本路由,所有用户都能看的路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/login&#x27;</span>)<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Layout,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/image&#x27;</span>)<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/chart&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/chart&#x27;</span>)<br>      &#125;<br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/404&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/404.vue&#x27;</span>)<br>  &#125;<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  <span class="hljs-attr">base</span>: process.env.BASE_URL,<br>  routes<br>&#125;)<br><br><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>定义动态路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> tableRule = &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/table&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;table&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/table/ceshi.vue&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> imageRule = &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/image&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;image&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/image&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> userRule = &#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;users&#x27;</span>,<br>  <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/users&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 路由规则和字符串的映射关系</span><br><span class="hljs-keyword">const</span> ruleMapping = &#123;<br>  <span class="hljs-attr">table</span>: tableRule,<br>  <span class="hljs-attr">users</span>: userRule,<br>  <span class="hljs-attr">image</span>: imageRule<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>初始化动态路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initDynamicRoutes</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// console.log(router.options,&#x27;.....初始化的路由&#x27;);</span><br><br>  <span class="hljs-keyword">const</span> currentRoutes = router.options.routes<br>  <span class="hljs-built_in">console</span>.log(currentRoutes,<span class="hljs-string">&#x27;当前路由&#x27;</span>);<br>  <span class="hljs-comment">// 刷新 页面 动态添加的路由消失</span><br>  <span class="hljs-comment">// 使用  vuex 时的也会消失</span><br>  <span class="hljs-keyword">const</span> rightList = <span class="hljs-built_in">JSON</span>.parse(sessionStorage.getItem(<span class="hljs-string">&#x27;rightList&#x27;</span>) || <span class="hljs-string">&#x27;[]&#x27;</span>)<br>  rightList.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123; <span class="hljs-comment">// 如果是没有子路由的话 就直接添加进去 如果有子路由的话就进入二级权限遍历</span><br>    <span class="hljs-comment">// console.log(item, &#x27;item,rightList&#x27;)</span><br>    <span class="hljs-comment">// console.log(item.path);</span><br>    <span class="hljs-comment">// 如果没有二级路由 的话</span><br>    <span class="hljs-keyword">if</span> (item.children.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">const</span> temp = ruleMapping[item.path]<br>      <span class="hljs-comment">// 路由规则中添加元数据meta</span><br>      temp.meta = item.rights<br>      currentRoutes.push(temp)<br>      <span class="hljs-comment">// currentRoutes[1].children.push(temp)</span><br>    &#125;<br>    item.children.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// item 二级权限</span><br>      <span class="hljs-comment">// console.log(item, &#x27;item-2&#x27;)</span><br>      <span class="hljs-keyword">const</span> temp = ruleMapping[item.path]<br>      <span class="hljs-comment">// 路由规则中添加元数据meta</span><br>      temp.meta = item.rights<br>      currentRoutes[<span class="hljs-number">1</span>].children.push(temp)<br>    &#125;)<br>  &#125;)<br>  router.addRoutes(currentRoutes)<br>  <span class="hljs-comment">// console.log(router.options.routes,&#x27;用户登录后的路由&#x27;)</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过自定义指令来, 实现按钮级别的权限管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自定义指令的注册</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span><br>Vue.directive(<span class="hljs-string">&#x27;permission&#x27;</span>, &#123;<br>  inserted (el, binding) &#123;<br>    <span class="hljs-comment">// console.log(el)</span><br>    <span class="hljs-comment">// console.log(binding)</span><br>    <span class="hljs-keyword">const</span> action = binding.value.action<br>    <span class="hljs-keyword">const</span> effect = binding.value.effect<br>    <span class="hljs-comment">// 判断 当前的路由所对应的组件中 如何判断用户是否具备action的权限</span><br>    <span class="hljs-comment">// console.log(router.currentRoute.meta, &#x27;按钮权限&#x27;)</span><br>    <span class="hljs-keyword">if</span> (router.currentRoute.meta.indexOf(action) === -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 等于-1说明没找到 不具备权限</span><br>      <span class="hljs-keyword">if</span> (effect === <span class="hljs-string">&#x27;disabled&#x27;</span>) &#123;<br>        el.disabled = <span class="hljs-literal">true</span><br>        el.classList.add(<span class="hljs-string">&#x27;is-disabled&#x27;</span>)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        el.parentNode.removeChild(el)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="前端权限思路二"><a href="#前端权限思路二" class="headerlink" title="前端权限思路二"></a>前端权限思路二</h2><ul><li><p>mock 后端返回来的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">定义token 假定 admin 的token就是<span class="hljs-string">&#x27;admin-token&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> tokens = &#123;<br>  <span class="hljs-attr">admin</span>: &#123;<br>    <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;admin-token&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">student</span>: &#123;<br>    <span class="hljs-attr">token</span>: <span class="hljs-string">&#x27;student-token&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>```javascript<br>token 对应的信息<br>export const users = {<br>  ‘admin-token’: {</p><pre><code>role: &#39;admin&#39;,name: &#39;管理员&#39;,photo: &#39;https://dss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1709216491,2536617744&amp;fm=26&amp;gp=0.jpg&#39;</code></pre><p>  },<br>  ‘student-token’: {</p><pre><code>role: &#39;student&#39;,name: &#39;学生&#39;,photo: &#39;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2364244149,3298797080&amp;fm=26&amp;gp=0.jpg&#39;</code></pre><p>  }<br>}</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>- 登录<br><br>  ```<span class="javascript">javascript</span><br><span class="javascript">      <span class="hljs-keyword">async</span> onSubmit (form) &#123;</span><br><span class="javascript">        <span class="hljs-comment">// console.log(&#x27;form&#x27;, form)</span></span><br><span class="javascript">        <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: token &#125; = <span class="hljs-keyword">await</span> login(form)</span><br><span class="javascript">        setToken(token.token)</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;SET_TOKEN&#x27;</span>, token.token)</span><br><span class="javascript">  </span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$router.push(&#123;</span><br><span class="javascript">          <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span></span><br><span class="javascript">        &#125;)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">  <span class="hljs-comment">// 导入</span></span><br><span class="javascript">      <span class="hljs-keyword">import</span> &#123; setToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span></span><br><span class="javascript">      setToken(token.token)  这个方法</span><br><span class="javascript">      <span class="hljs-comment">// auth.js</span></span><br><span class="javascript">      <span class="hljs-keyword">import</span> Cookies <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;js-cookie&#x27;</span></span><br><span class="javascript">  <span class="hljs-comment">// 个方法  存取token ,把toekn存到cookies中</span></span><br><span class="javascript">      <span class="hljs-comment">// 设置 token 的键名</span></span><br><span class="javascript">      <span class="hljs-keyword">const</span> TokenKey = <span class="hljs-string">&#x27;vue_admin_token&#x27;</span></span><br><span class="javascript">  </span><br><span class="javascript">      <span class="hljs-comment">// 从缓存中获取token</span></span><br><span class="javascript">      <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getToken</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> Cookies.get(TokenKey)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">  </span><br><span class="javascript">      <span class="hljs-comment">// 在缓存中存入token</span></span><br><span class="javascript">      <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setToken</span> (<span class="hljs-params">token</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> Cookies.set(TokenKey, token)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">  </span><br><span class="javascript">      <span class="hljs-comment">// 清除缓存中的token</span></span><br><span class="javascript">      <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeToken</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> Cookies.remove(TokenKey)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">  </span><br></code></pre></td></tr></table></figure></li><li><h3 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把所有 的路由 都写出来,不必动态添加路由</span><br><span class="hljs-comment">// 对于 需要权限的路由,在路由的元信息meta中进行添加</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/login&#x27;</span>),<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Layout,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 这里如果注释掉 则无法通过按钮跳转到首页</span><br>    <span class="hljs-comment">// redirect: &#123;</span><br>    <span class="hljs-comment">//   name: &#x27;home&#x27;</span><br>    <span class="hljs-comment">// &#125;,</span><br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-home&#x27;</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;首页&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/home&#x27;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;首页&#x27;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dataCenter&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;dataCenter&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Layout,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/dataCenter/form&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-data&#x27;</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;数据中心&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dataCenter/form&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;form&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/form&#x27;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;表单&#x27;</span><br>        &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dataCenter/table&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;table&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/table&#x27;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;表格&#x27;</span><br>        &#125;<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dataCenter/echart&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;echart&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/echart&#x27;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;可视化&#x27;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/power&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Power&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Layout,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/power&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;el-icon-s-custom&#x27;</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;权限页面&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/power&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;power&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/power&#x27;</span>),<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;权限页面&#x27;</span>,<br>          <span class="hljs-attr">roles</span>: [<span class="hljs-string">&#x27;admin&#x27;</span>]<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/404&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/404&#x27;</span>),<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/404&#x27;</span>,<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure></li></ul><ul><li><h3 id="permission-js"><a href="#permission-js" class="headerlink" title="permission.js"></a>permission.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-keyword">import</span> NProgress <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nprogress&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;nprogress/nprogress.css&#x27;</span><br><span class="hljs-keyword">import</span> &#123; Message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> &#123; getToken, removeToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/auth&#x27;</span><br><span class="hljs-keyword">import</span> &#123; findUserByToken &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/user&#x27;</span><br><br>NProgress.configure(&#123; <span class="hljs-attr">showSpinner</span>: <span class="hljs-literal">false</span> &#125;)<br><br><span class="hljs-keyword">const</span> whiteList = [<span class="hljs-string">&#x27;/login&#x27;</span>] <span class="hljs-comment">// 不重定向白名单</span><br><br>router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  NProgress.start()<br>  <span class="hljs-keyword">if</span> (getToken()) &#123;<br>    <span class="hljs-comment">// 如果有token 则没必要再去登录页面 直接跳到首页</span><br>    <span class="hljs-keyword">if</span> (to.path === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;<br>      next(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 去其它页面</span><br>      <span class="hljs-comment">// console.log(&#x27;getToken()&#x27;, getToken())</span><br>      <span class="hljs-comment">// 将用户信息存入缓存不安全 所以存入vuex 然而每次刷新页面vuex都会清空 所以每次路由跳转时重新获取信息存入vuex</span><br>      findUserByToken(getToken()).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(&#x27;findUserByToken res&#x27;, res)</span><br>        <span class="hljs-comment">// 如果返回的信息为空 则说明token不匹配 清除token 刷新页面 返回登录页面</span><br>        <span class="hljs-keyword">if</span> (res.data === <span class="hljs-literal">undefined</span>) &#123;<br>          Message.error(<span class="hljs-string">&#x27;无效的token&#x27;</span>)<br>          removeToken()<br>          <span class="hljs-built_in">window</span>.location.reload()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是有效token 将信息用户信息存入vuex</span><br>          <span class="hljs-keyword">const</span> userInfo = res.data<br>          store.commit(<span class="hljs-string">&#x27;SET_ROLE&#x27;</span>, userInfo.role)<br>          store.commit(<span class="hljs-string">&#x27;SET_NAME&#x27;</span>, userInfo.name)<br>          store.commit(<span class="hljs-string">&#x27;SET_PHOTO&#x27;</span>, userInfo.photo)<br><br>          <span class="hljs-keyword">const</span> userRole = store.getters.GET_ROLE<br>          <span class="hljs-comment">// console.log(&#x27;userRole&#x27;, userRole)</span><br>          <span class="hljs-comment">// console.log(&#x27;to&#x27;, to)</span><br>          <span class="hljs-comment">// 判断正在跳转的路由是否需要权限 如果不需要权限 则直接放行</span><br>          <span class="hljs-comment">// 如果没有没有定义的meta.roles, 则(to.meta.roles)值为undefined; ===&gt;&gt;&gt;undefined 取非是true</span><br>          <span class="hljs-keyword">if</span> (!(to.meta.roles) &#123;<br>            <span class="hljs-comment">// console.log(&#x27;to.meta.roles&#x27;, to.meta.roles)</span><br>            next()<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果需要权限 判断用户的role是否在可跳转roles数组中</span><br>            <span class="hljs-keyword">if</span> (to.meta.roles.indexOf(userRole) !== -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 有权限 放行</span><br>              next()<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// // 没有权限 清空用户信息 返回登录页面</span><br>              <span class="hljs-comment">// Message.error(&#x27;非法访问&#x27;)</span><br>              <span class="hljs-comment">// removeToken()</span><br>              <span class="hljs-comment">// window.location.reload() // 刷新vuex</span><br>              <span class="hljs-comment">// next(&#x27;/login&#x27;)</span><br><br>              <span class="hljs-comment">// 没有权限 去404</span><br>              next(<span class="hljs-string">&#x27;/404&#x27;</span>)<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;findUserByToken&#x27;</span>, err)<br>      &#125;)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 没有token 先判断是否在白名单 在白名单则放行 比如未登录时 是可以去登录页面的</span><br>    <span class="hljs-keyword">if</span> (whiteList.indexOf(to.path) !== -<span class="hljs-number">1</span>) &#123;<br>      next()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 要去的页面没有在白名单 则不让跳转 而是去登录页面</span><br>      next(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;)<br><br>router.afterEach(<span class="hljs-function">() =&gt;</span> &#123;<br>  NProgress.done()<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>按钮级别的思路</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store/index&#x27;</span><br><br>Vue.directive(<span class="hljs-string">&#x27;permission&#x27;</span>, &#123;<br>  inserted (el, binding) &#123;<br>    <span class="hljs-keyword">const</span> role = binding.value.role<br>    <span class="hljs-keyword">const</span> userRole = store.getters.GET_ROLE<br>    <span class="hljs-comment">// 假如用户没有相关权限则不显示</span><br>    <span class="hljs-keyword">if</span> (role.indexOf(userRole) === -<span class="hljs-number">1</span>) &#123;<br>      el.parentElement.removeChild(el)<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="前端权限实现思路三"><a href="#前端权限实现思路三" class="headerlink" title="前端权限实现思路三"></a>前端权限实现思路三</h2><ul><li><p>所有的路由,页面都写好,有前端完全控制,先定义好某个 角色的能访问的页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  前端权限思路：</span><br><span class="hljs-comment">  1.前端自己写出权限映射,后端传来权限等级即可</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 隐藏路由</span><br><span class="hljs-keyword">const</span> main = [<span class="hljs-string">&#x27;main&#x27;</span>, <span class="hljs-string">&#x27;mainF&#x27;</span>, <span class="hljs-string">&#x27;404&#x27;</span>]<br><br><span class="hljs-comment">// 工艺流程</span><br><span class="hljs-keyword">const</span> process = [<span class="hljs-string">&#x27;process&#x27;</span>, <span class="hljs-string">&#x27;forming&#x27;</span>, <span class="hljs-string">&#x27;dipping&#x27;</span>, <span class="hljs-string">&#x27;graphiting&#x27;</span>, <span class="hljs-string">&#x27;tunnelKiln&#x27;</span>]<br><br><span class="hljs-comment">// 数据中心</span><br><span class="hljs-keyword">const</span> dataCenter = [<span class="hljs-string">&#x27;dataCenter&#x27;</span>, <span class="hljs-string">&#x27;cargo&#x27;</span>, <span class="hljs-string">&#x27;warehouse&#x27;</span>, <span class="hljs-string">&#x27;formCheck&#x27;</span>, <span class="hljs-string">&#x27;formCheckKiln&#x27;</span>, <span class="hljs-string">&#x27;process&#x27;</span>, <span class="hljs-string">&#x27;forming&#x27;</span>, <span class="hljs-string">&#x27;dipping&#x27;</span>, <span class="hljs-string">&#x27;graphiting&#x27;</span>, <span class="hljs-string">&#x27;form&#x27;</span>, <span class="hljs-string">&#x27;formCheckDip&#x27;</span>]<br><br><span class="hljs-comment">// 配置中心</span><br><span class="hljs-keyword">const</span> configCenter = [<span class="hljs-string">&#x27;configCenter&#x27;</span>, <span class="hljs-string">&#x27;formTemplate&#x27;</span>, <span class="hljs-string">&#x27;processManage&#x27;</span>, <span class="hljs-string">&#x27;employeeInfo&#x27;</span>, <span class="hljs-string">&#x27;platform&#x27;</span>, <span class="hljs-string">&#x27;parameter&#x27;</span>, <span class="hljs-string">&#x27;analysis&#x27;</span>]<br><br><span class="hljs-comment">// 权限中心</span><br><span class="hljs-keyword">const</span> powerManage = [<span class="hljs-string">&#x27;powerManage&#x27;</span>, <span class="hljs-string">&#x27;api&#x27;</span>, <span class="hljs-string">&#x27;auth&#x27;</span>, <span class="hljs-string">&#x27;role&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>]<br><br><span class="hljs-comment">// 个人中心</span><br><span class="hljs-keyword">const</span> person = [<span class="hljs-string">&#x27;person&#x27;</span>, <span class="hljs-string">&#x27;personF&#x27;</span>, <span class="hljs-string">&#x27;modifyPwd&#x27;</span>]<br><br><span class="hljs-comment">// 经过测试，Array.toString()并不会输出//背后的内容</span><br><br><span class="hljs-comment">// 抽离直接使用</span><br><br><span class="hljs-comment">// 0 管理员</span><br><span class="hljs-keyword">const</span> role0 = [<br>  main,<br>  process, <span class="hljs-comment">// 工艺流程</span><br>  dataCenter, <span class="hljs-comment">// 数据中心</span><br>  configCenter, <span class="hljs-comment">// 配置中心</span><br>  powerManage, <span class="hljs-comment">// 权限中心</span><br>  person <span class="hljs-comment">// 个人中心</span><br>]<br><br><span class="hljs-comment">// 1 压型员工</span><br><span class="hljs-keyword">const</span> role1 = [<br>  main,<br>  [<span class="hljs-string">&#x27;dataCenter&#x27;</span>, <span class="hljs-string">&#x27;forming&#x27;</span>, <span class="hljs-string">&#x27;process&#x27;</span>, <span class="hljs-string">&#x27;form&#x27;</span>],<br>  person<br>]<br><br><span class="hljs-comment">// 2 浸渍员工</span><br><span class="hljs-keyword">const</span> role2 = [<br>  main,<br>  [<span class="hljs-string">&#x27;process&#x27;</span>, <span class="hljs-string">&#x27;dipping&#x27;</span>, <span class="hljs-string">&#x27;dataCenter&#x27;</span>, <span class="hljs-string">&#x27;formCheckDip&#x27;</span>],<br>  person<br>]<br><br><span class="hljs-comment">// 3 浸隧道窑员工</span><br><span class="hljs-keyword">const</span> role3 = [<br>  main,<br>  [<span class="hljs-string">&#x27;process&#x27;</span>, <span class="hljs-string">&#x27;tunnelKiln&#x27;</span>, <span class="hljs-string">&#x27;dataCenter&#x27;</span>, <span class="hljs-string">&#x27;formCheckKiln&#x27;</span>],<br>  person<br>]<br><br><span class="hljs-comment">// 4 石墨化员工</span><br><span class="hljs-keyword">const</span> role4 = [<br>  main,<br>  [<span class="hljs-string">&#x27;process&#x27;</span>, <span class="hljs-string">&#x27;graphiting&#x27;</span>],<br>  [<span class="hljs-string">&#x27;dataCenter&#x27;</span>, <span class="hljs-string">&#x27;formCheck&#x27;</span>],<br>  person<br>]<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> allRole = &#123;<br>  role0,<br>  role1,<br>  role2,<br>  role3,<br>  role4<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li></li><li><pre><code class="javascript">router.beforeEach((to, from, next) =&gt; &#123;  NProgress.start()  store.commit(&#39;insertCurrentPage&#39;, (to.fullPath).substr(1))  // console.log(to.path)  // 如果去登录 直接放行  if (to.path === &#39;/login&#39;) &#123;    next()    NProgress.done()  &#125; else &#123;    // 如果跳过了登录去其它页面 先判断是否具有token    // console.log(sessionStorage.getItem(&#39;Token&#39;))    if (sessionStorage.getItem(&#39;Token&#39;)) &#123;      // 有token的话调用接口获取用户信息 存到vuex里 这样就不会在控制台的本地缓存中找到用户信息      findByToken(sessionStorage.getItem(&#39;Token&#39;))        .then(res =&gt; &#123;          // console.log(&#39;findByToken&#39;, res)          // 请求拦截器将res处理了          if (res === undefined) &#123;            next(&#39;/login&#39;)            NProgress.done()          &#125;          // sessionStorage.setItem(&#39;loginState&#39;, JSON.stringify(res.data.data))          const payload = res.data.data          // 将用户信息存到vuex中          store.commit(&#39;insertLoginState&#39;, payload)          // console.log(&#39;state&#39;, store)          // 从vuex里面获取数据代替router,假如没有数据则重新获取          // 对用户状态进行检测,假如跳转到非当前用户权限范围则返回          try &#123;            // console.log(to.fullPath)            // 这里有个问题，假如获取到的role为null,直接会报typeError,不会进入roleState === null,故要try&#123;&#125;catch&#123;&#125;            const roleState = store.getters.getRole            // eslint-disable-next-line no-useless-escape            const toPath = &#39;&#39; + (to.path).substr(1) + &#39;&#39;            // const toPath = &#39;\&quot;routerName\&quot;:\&quot;&#39; + (to.path).substr(1) + &#39;\&quot;&#39;            // const toPath = (to.path).substr(1)            // console.log(toPath)            var roleName = &#39;role&#39; + roleState            // console.log(allRole[roleName])            // console.log(router.options.routes)            var roleGet = allRole[roleName].toString()            if (roleGet.indexOf(toPath) === -1) &#123;              // console.log(toPath)              // console.log(&#39;非法跳转&#39;)              // return new Error(&#39;非法跳转&#39;)              // Message.error(&#39;非法跳转&#39;)              localStorage.clear()              // next(&#39;/login&#39;)              next(&#39;/404&#39;)              NProgress.done()            &#125; else &#123;              next()              NProgress.done()            &#125;          &#125; catch (error) &#123;            console.log(&#39;路由守卫err&#39;, error)            next(&#39;/login&#39;)            NProgress.done()          &#125;        &#125;).catch(err =&gt; &#123;          console.log(&#39;findByToken&#39;, err)        &#125;)    &#125; else &#123;      // 如果跳过登录去其它页面 没有token 则返回到登录页面      next(&#39;/login&#39;)      NProgress.done()    &#125;  &#125;&#125;)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>path-to-regexp</title>
    <link href="/2021/08/01/path-to-regexp/"/>
    <url>/2021/08/01/path-to-regexp/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>该工具库用来处理 url 中地址与参数，能够很方便得到我们想要的数据。</p><p>js 中有 RegExp 方法做正则表达式校验，而 path-to-regexp 可以看成是 url 字符串的正则表达式。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>第三方库，使用前先进行安装：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>npm install path-to-regexp<br></code></pre></td></tr></table></figure><p>在 js 中使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> pathToRegexp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path-to-regexp&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><h3 id="1-pathToRegexp"><a href="#1-pathToRegexp" class="headerlink" title="1. pathToRegexp()"></a>1. pathToRegexp()</h3><p>作用：这里这个方法可以类比于 js 中 <code>new RegExp(&#39;xxx&#39;)</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> pathToRegexp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path-to-regexp&#x27;</span>)<br><br><span class="hljs-keyword">var</span> re = pathToRegexp(<span class="hljs-string">&#x27;/foo/:bar&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(re);    <br></code></pre></td></tr></table></figure><p>打印结果如下:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">/^\/foo\/((<span class="hljs-string">?:</span>[^\/]+<span class="hljs-string">?)</span>)(<span class="hljs-string">?:\/</span>(<span class="hljs-string">?=</span><span class="hljs-variable">$)</span>)<span class="hljs-string">?$</span>/i<br></code></pre></td></tr></table></figure><p>要注意两点，一点是我们自己的 url 地址，一条是匹配规则。</p><h3 id="2-exec"><a href="#2-exec" class="headerlink" title="2. exec()"></a>2. exec()</h3><p>作用：匹配 url 地址与规则是否相符。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> pathToRegexp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path-to-regexp&#x27;</span>)<br><br><span class="hljs-keyword">var</span> re = pathToRegexp(<span class="hljs-string">&#x27;/foo/:bar&#x27;</span>);     <span class="hljs-comment">// 匹配规则</span><br><span class="hljs-keyword">var</span> match1 = re.exec(<span class="hljs-string">&#x27;/test/route&#x27;</span>);    <span class="hljs-comment">// url 路径</span><br><span class="hljs-keyword">var</span> match2 = re.exec(<span class="hljs-string">&#x27;/foo/route&#x27;</span>);     <span class="hljs-comment">// url 路径</span><br><br><span class="hljs-built_in">console</span>.log(match1);<br><span class="hljs-built_in">console</span>.log(match2);<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">null</span><br>[ <span class="hljs-string">&#x27;/foo/route&#x27;</span>, <span class="hljs-string">&#x27;route&#x27;</span>, index: <span class="hljs-number">0</span>, input: <span class="hljs-string">&#x27;/foo/route&#x27;</span> ]<br></code></pre></td></tr></table></figure><p>说明：</p><p>上述代码中，第一个 url 路径与匹配规则不相符返回 null，第二个 url 路径与匹配规则相符，返回一个数组。</p><h3 id="3-parse"><a href="#3-parse" class="headerlink" title="3. parse()"></a>3. parse()</h3><p>作用：解析 url 字符串中的参数部分（:id）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> pathToRegexp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path-to-regexp&#x27;</span>);<br><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;/user/:id&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(pathToRegexp.parse(url));<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ <span class="hljs-string">&#x27;/user&#x27;</span>,<br>  &#123; name: <span class="hljs-string">&#x27;id&#x27;</span>,<br>    prefix: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    delimiter: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    optional: <span class="hljs-literal">false</span>,<br>    repeat: <span class="hljs-literal">false</span>,<br>    partial: <span class="hljs-literal">false</span>,<br>    pattern: <span class="hljs-string">&#x27;[^\\/]+?&#x27;</span> &#125; ]<br></code></pre></td></tr></table></figure><p>说明：返回一个数组，从第二个数据可以就可以得到 url 地址携带参数的属性名称（item.name）。</p><p>当然，url 中携带参数出了 :id 这种形式，还有 <code>/user?id=11</code> 这种，使用 parse() 方法解析自行查看结果。</p><h3 id="4-compile"><a href="#4-compile" class="headerlink" title="4. compile()"></a>4. compile()</h3><p>作用：快速填充 url 字符串的参数值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> pathToRegexp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path-to-regexp&#x27;</span>)<br><br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;/user/:id/:name&#x27;</span><br><span class="hljs-keyword">var</span> data = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">10001</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;<br><span class="hljs-built_in">console</span>.log(pathToRegexp.compile(url)(data))<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">/user/10001/bob<br></code></pre></td></tr></table></figure><p>作者：dkvirus<br>链接：<a href="https://www.jianshu.com/p/7d2dbfdd1b0f">https://www.jianshu.com/p/7d2dbfdd1b0f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化时间</title>
    <link href="/2021/08/01/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/"/>
    <url>/2021/08/01/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="格式化时间问题"><a href="#格式化时间问题" class="headerlink" title="格式化时间问题"></a>格式化时间问题</h2><h4 id="通常我们都会遇到需要转换时间时间的格式-先简单写一点-慢慢补充"><a href="#通常我们都会遇到需要转换时间时间的格式-先简单写一点-慢慢补充" class="headerlink" title="通常我们都会遇到需要转换时间时间的格式,先简单写一点,慢慢补充"></a>通常我们都会遇到需要转换时间时间的格式,先简单写一点,慢慢补充</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> formatTime = <span class="hljs-function"><span class="hljs-params">date</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> year = date.getFullYear()<br>  <span class="hljs-keyword">const</span> month = date.getMonth() + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> day = date.getDate()<br>  <span class="hljs-keyword">const</span> hour = date.getHours()<br>  <span class="hljs-keyword">const</span> minute = date.getMinutes()<br>  <span class="hljs-keyword">const</span> second = date.getSeconds()<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;[year, month, day].map(formatNumber).join(<span class="hljs-string">&#x27;-&#x27;</span>)&#125;</span> <span class="hljs-subst">$&#123;[hour, minute, second].map(formatNumber).join(<span class="hljs-string">&#x27;:&#x27;</span>)&#125;</span>`</span><br>&#125;<br><br><span class="hljs-keyword">const</span> formatNumber = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<br>  n = n.toString()<br>  <span class="hljs-keyword">return</span> n[<span class="hljs-number">1</span>] ? n : <span class="hljs-string">`0<span class="hljs-subst">$&#123;n&#125;</span>`</span><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  formatTime<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比特币白皮书---转载</title>
    <link href="/2021/07/29/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <url>/2021/07/29/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="比特币白皮书：一种点对点的电子现金系统"><a href="#比特币白皮书：一种点对点的电子现金系统" class="headerlink" title="比特币白皮书：一种点对点的电子现金系统"></a>比特币白皮书：一种点对点的电子现金系统</h2><h1 id="原文作者：中本聪（Satoshi-Nakamoto）"><a href="#原文作者：中本聪（Satoshi-Nakamoto）" class="headerlink" title="原文作者：中本聪（Satoshi Nakamoto）"></a><strong>原文作者：<a href="http://8btc.com/article-25-1.html">中本聪</a>（Satoshi Nakamoto）</strong></h1><p><strong>作者邮箱：<a href="mailto:&#x53;&#97;&#x74;&#x6f;&#x73;&#x68;&#x69;&#x6e;&#x40;&#103;&#109;&#120;&#x2e;&#x63;&#111;&#x6d;">&#x53;&#97;&#x74;&#x6f;&#x73;&#x68;&#x69;&#x6e;&#x40;&#103;&#109;&#120;&#x2e;&#x63;&#111;&#x6d;</a></strong></p><p><strong>执行翻译：8btc.com 巴比特 *<em><a href="http://www.8btc.com/author/24">QQagent</a>*</em></strong></p><blockquote><p>[摘要]：本文提出了一种完全通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。虽然数字签名（Digital signatures）部分解决了这个问题，但是如果仍然需要第三方的支持才能防止双重支付（double-spending）的话，那么这种系统也就失去了存在的价值。我们(we)在此提出一种解决方案，使现金系统在点对点的环境下运行，并防止双重支付问题。该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条。这个系统本身需要的基础设施非常少。信息尽最大努力在全网传播即可，节点(nodes)可以随时离开和重新加入网络，并将最长的工作量证明链条作为在该节点离线期间发生的交易的证明。</p></blockquote><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>互联网上的贸易，几乎都需要借助金融机构作为可资信赖的第三方来处理电子支付信息。虽然这类系统在绝大多数情况下都运作良好，但是这类系统仍然内生性地受制于“基于信用的模式”(trust based model)的弱点。我们无法实现完全不可逆的交易，因为金融机构总是不可避免地会出面协调争端。而金融中介的存在，也会增加交易的成本，并且限制了实际可行的最小交易规模，也限制了日常的小额支付交易。并且潜在的损失还在于，很多商品和服务本身是无法退货的，如果缺乏不可逆的支付手段，互联网的贸易就大大受限。因为有潜在的退款的可能，就需要交易双方拥有信任。而商家也必须提防自己的客户，因此会向客户索取完全不必要的个人信息。而实际的商业行为中，一定比例的欺诈性客户也被认为是不可避免的，相关损失视作销售费用处理。而在使用物理现金的情况下，这些销售费用和支付问题上的不确定性却是可以避免的，因为此时没有第三方信用中介的存在。 所以，我们非常需要这样一种电子支付系统，它基于密码学原理而不基于信用，使得任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。杜绝回滚(reverse)支付交易的可能，这就可以保护特定的卖家免于欺诈；而对于想要保护买家的人来说，在此环境下设立通常的第三方担保机制也可谓轻松加愉快。在这篇论文中，我们(we)将提出一种通过点对点分布式的时间戳服务器来生成依照时间前后排列并加以记录的电子交易证明，从而解决双重支付问题。只要诚实的节点所控制的计算能力的总和，大于有合作关系的(cooperating)攻击者的计算能力的总和，该系统就是安全的。</p><h2 id="2-交易-Transactions"><a href="#2-交易-Transactions" class="headerlink" title="2. 交易(Transactions)"></a>2. 交易(Transactions)</h2><p>我们定义，一枚电子货币（an electronic coin）是这样的一串数字签名：每一位所有者通过对前一次交易和下一位拥有者的公钥(Public key) 签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾，电子货币就发送给了下一位所有者。而收款人通过对签名进行检验，就能够验证该链条的所有者。</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/202007300759252566.jpg" alt="1"></h1><p>该过程的问题在于，收款人将难以检验，之前的某位所有者，是否对这枚电子货币进行了双重支付。通常的解决方案，就是引入信得过的第三方权威，或者类似于造币厂(mint)的机构，来对每一笔交易进行检验，以防止双重支付。在每一笔交易结束后，这枚电子货币就要被造币厂回收，而造币厂将发行一枚新的电子货币；而只有造币厂直接发行的电子货币，才算作有效，这样就能够防止双重支付。可是该解决方案的问题在于，整个货币系统的命运完全依赖于运作造币厂的公司，因为每一笔交易都要经过该造币厂的确认，而该造币厂就好比是一家银行。 我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。从逻辑上看，为了达到目的，实际上我们需要关注的只是于本交易之前发生的交易，而不需要关注这笔交易发生之后是否会有双重支付的尝试。为了确保某一次交易是不存在的，那么唯一的方法就是获悉之前发生过的所有交易。在造币厂模型里面，造币厂获悉所有的交易，并且决定了交易完成的先后顺序。如果想要在电子系统中排除第三方中介机构，那么交易信息就应当被公开宣布（publicly announced）[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-1">1]</a> ，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在交易期间绝大多数的节点都认同该交易是首次出现。</p><h2 id="3-时间戳服务器-Timestamp-server"><a href="#3-时间戳服务器-Timestamp-server" class="headerlink" title="3. 时间戳服务器(Timestamp server)"></a>3. 时间戳服务器(Timestamp server)</h2><p>本解决方案首先提出一个“时间戳服务器”。时间戳服务器通过对以区块(block)形式存在的一组数据实施随机散列而加上时间戳，并将该随机散列进行广播，就像在新闻或世界性新闻组网络（Usenet）的发帖一样[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-2">2]</a>[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-3">3]</a>[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-4">4]</a>[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-5">5]</a> 。显然，该时间戳能够证实特定数据必然于某特定时间是的确存在的，因为只有在该时刻存在了才能获取相应的随机散列值。每个时间戳应当将前一个时间戳纳入其随机散列值中，每一个随后的时间戳都对之前的一个时间戳进行增强(reinforcing)，这样就形成了一个链条（Chain）。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/21.png" alt="2"></p><h2 id="4-工作量证明（Proof-of-Work）"><a href="#4-工作量证明（Proof-of-Work）" class="headerlink" title="4. 工作量证明（Proof-of-Work）"></a>4. 工作量证明（Proof-of-Work）</h2><p>为了在点对点的基础上构建一组分散化的时间戳服务器，仅仅像报纸或世界性新闻网络组一样工作是不够的，我们还需要一个类似于亚当•柏克（Adam Back）提出的哈希现金（Hashcash）[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-6">6]</a> 。在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作，比方说SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，而对结果进行检验则仅需要一次随机散列运算。</p><p>我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/31.png" alt="3"></p><p>同时，该工作量证明机制还解决了在集体投票表决时，谁是大多数的问题。如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，则该机制就被破坏了。而工作量证明机制的本质则是一CPU一票。“大多数”的决定表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。如果想要对业已出现的区块进行修改，攻击者必须重新完成该区块的工作量外加该区块之后所有区块的工作量，并最终赶上和超越诚实节点的工作量。我们将在后文证明，设想一个较慢的攻击者试图赶上随后的区块，那么其成功概率将呈指数化递减。 另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一个预定的平均数。如果区块生成的速度过快，那么难度就会提高。</p><h2 id="5-网络"><a href="#5-网络" class="headerlink" title="5. 网络"></a>5. 网络</h2><p>运行该网络的步骤如下：</p><ul><li>\1) 新的交易向全网进行广播；</li><li>\2) 每一个节点都将收到的交易信息纳入一个区块中；</li><li>\3) 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</li><li>\4) 当一个节点找到了一个工作量证明，它就向全网进行广播；</li><li>\5) 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；</li><li>\6) 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。</li></ul><p>节点始终都将最长的链条视为正确的链条，并持续工作和延长它。如果有两个节点同时广播不同版本的新区块，那么其他节点在接收到该区块的时间上将存在先后差别。当此情形，他们将在率先收到的区块基础上进行工作，但也会保留另外一个链条，以防后者变成最长的链条。该僵局（tie）的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为是较长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的链条上工作。 所谓“新的交易要广播”，实际上不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。而区块的广播对被丢弃的信息是具有容错能力的。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了某个区块，也就可以提出自己下载该区块的请求。</p><h2 id="6-激励"><a href="#6-激励" class="headerlink" title="6. 激励"></a>6. 激励</h2><p>我们约定如此：每个区块的第一笔交易进行特殊化处理，该交易产生一枚由该区块创造者拥有的新的电子货币。这样就增加了节点支持该网络的激励，并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。这种将一定数量新货币持续增添到货币系统中的方法，非常类似于耗费资源去挖掘金矿并将黄金注入到流通领域。此时，CPU的时间和电力消耗就是消耗的资源。 另外一个激励的来源则是交易费（transaction fees）。如果某笔交易的输出值小于输入值，那么差额就是交易费，该交易费将被增加到该区块的激励中。只要既定数量的电子货币已经进入流通，那么激励机制就可以逐渐转换为完全依靠交易费，那么本货币系统就能够免于通货膨胀。 激励系统也有助于鼓励节点保持诚实。如果有一个贪婪的攻击者能够调集比所有诚实节点加起来还要多的CPU计算力，那么他就面临一个选择：要么将其用于诚实工作产生新的电子货币，或者将其用于进行二次支付攻击。那么他就会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。</p><h2 id="7-回收硬盘空间"><a href="#7-回收硬盘空间" class="headerlink" title="7. 回收硬盘空间"></a>7. 回收硬盘空间</h2><p>如果最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。为了同时确保不损害区块的随机散列值，交易信息被随机散列时，被构建成一种Merkle树（Merkle tree）[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-7">7]</a> 的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/41.png" alt="4"></p><p>不含交易信息的区块头（Block header）大小仅有80字节。如果我们设定区块生成的速率为每10分钟一个，那么每一年产生的数据位4.2MB。（80 bytes * 6 * 24 * 365 = 4.2MB）。2008年，PC系统通常的内存容量为2GB，按照摩尔定律的预言，即使将全部的区块头存储于内存之中都不是问题。</p><h2 id="8-简化的支付确认（Simplified-Payment-Verification）"><a href="#8-简化的支付确认（Simplified-Payment-Verification）" class="headerlink" title="8. 简化的支付确认（Simplified Payment Verification）"></a>8. 简化的支付确认（Simplified Payment Verification）</h2><p>在不运行完整网络节点的情况下，也能够对支付进行检验。一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支通向它被加上时间戳并纳入区块的那次交易。节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/5.png" alt="5"></p><p>当此情形，只要诚实的节点控制了网络，检验机制就是可靠的。但是，当全网被一个计算力占优的攻击者攻击时，将变得较为脆弱。因为网络节点能够自行确认交易的有效性，只要攻击者能够持续地保持计算力优势，简化的机制会被攻击者焊接的（fabricated）交易欺骗。那么一个可行的策略就是，只要他们发现了一个无效的区块，就立刻发出警报，收到警报的用户将立刻开始下载被警告有问题的区块或交易的完整信息，以便对信息的不一致进行判定。对于日常会发生大量收付的商业机构，可能仍会希望运行他们自己的完整节点，以保持较大的独立完全性和检验的快速性。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/7.png" alt="7"></p><h2 id="9-价值的组合与分割（Combining-and-Splitting-Value）"><a href="#9-价值的组合与分割（Combining-and-Splitting-Value）" class="headerlink" title="9. 价值的组合与分割（Combining and Splitting Value）"></a>9. 价值的组合与分割（Combining and Splitting Value）</h2><p>虽然可以单个单个地对电子货币进行处理，但是对于每一枚电子货币单独发起一次交易将是一种笨拙的办法。为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。</p><h2 id="10-隐私（Privacy）"><a href="#10-隐私（Privacy）" class="headerlink" title="10. 隐私（Privacy）"></a>10. 隐私（Privacy）</h2><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/6.png" alt="6"></p><p>传统的造币厂模型为交易的参与者提供了一定程度的隐私保护，因为试图向可信任的第三方索取交易信息是严格受限的。但是如果将交易信息向全网进行广播，就意味着这样的方法失效了。但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起，也就是说，公众难以确信，这些人究竟是谁。这同股票交易所发布的信息是类似的，股票交易发生的时间、交易量是记录在案且可供查询的，但是交易双方的身份信息却不予透露。 作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。</p><h2 id="11-计算"><a href="#11-计算" class="headerlink" title="11. 计算"></a>11. 计算</h2><p>设想如下场景：一个攻击者试图比诚实节点产生链条更快地制造替代性区块链。即便它达到了这一目的，但是整个系统也并非就此完全受制于攻击者的独断意志了，比方说凭空创造价值，或者掠夺本不属于攻击者的货币。这是因为节点将不会接受无效的交易，而诚实的节点永远不会接受一个包含了无效信息的区块。一个攻击者能做的，最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。 诚实链条和攻击者链条之间的竞赛，可以用二叉树随机漫步（Binomial Random Walk)来描述。成功事件定义为诚实链条延长了一个区块，使其领先性+1，而失败事件则是攻击者的链条被延长了一个区块，使得差距-1。 攻击者成功填补某一既定差距的可能性，可以近似地看做赌徒破产问题（Gambler’s Ruin problem）。假定一个赌徒拥有无限的透支信用，然后开始进行潜在次数为无穷的赌博，试图填补上自己的亏空。那么我们可以计算他填补上亏空的概率，也就是该攻击者赶上诚实链条，如下所示[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-8">8]</a> ：</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/pq.png" alt="pq"></p><p>假定p&gt;q，那么攻击成功的概率就因为区块数的增长而呈现指数化下降。由于概率是攻击者的敌人，如果他不能幸运且快速地获得成功，那么他获得成功的机会随着时间的流逝就变得愈发渺茫。那么我们考虑一个收款人需要等待多长时间，才能足够确信付款人已经难以更改交易了。我们假设付款人是一个支付攻击者，希望让收款人在一段时间内相信他已经付过款了，然后立即将支付的款项重新支付给自己。虽然收款人届时会发现这一点，但为时已晚。 收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。这将可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。当此情形，只要交易一旦发出，攻击者就开始秘密地准备一条包含了该交易替代版本的平行链条。 然后收款人将等待交易出现在首个区块中，然后在等到z个区块链接其后。此时，他仍然不能确切知道攻击者已经进展了多少个区块，但是假设诚实区块将耗费平均预期时间以产生一个区块，那么攻击者的潜在进展就是一个泊松分布，分布的期望值为：</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/image022.png" alt="image022"></p><p>当此情形，为了计算攻击者追赶上的概率，我们将攻击者取得进展区块数量的泊松分布的概率密度，乘以在该数量下攻击者依然能够追赶上的概率。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/pq2.png" alt="pq2"></p><p>化为如下形式，避免对无限数列求和：</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/pq3.png" alt="pq3"></p><p>写为如下C语言代码：</p><p><code>#include double AttackerSuccessProbability(double q, int z) &#123; double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k &lt;= z; k++) &#123; double poisson = exp(-lambda); for (i = 1; i &lt;= k; i++) poisson *= lambda / i; sum -= poisson * (1 - pow(q / p, z - k)); &#125; return sum; &#125;</code> 对其进行运算，我们可以得到如下的概率结果，发现概率对z值呈指数下降。</p><p>当q=0.1时 z=0 P=1.0000000 z=1 P=0.2045873 z=2 P=0.0509779 z=3 P=0.0131722 z=4 P=0.0034552 z=5 P=0.0009137 z=6 P=0.0002428 z=7 P=0.0000647 z=8 P=0.0000173 z=9 P=0.0000046 z=10 P=0.0000012</p><p>当q=0.3时 z=0 P=1.0000000 z=5 P=0.1773523 z=10 P=0.0416605 z=15 P=0.0101008 z=20 P=0.0024804 z=25 P=0.0006132 z=30 P=0.0001522 z=35 P=0.0000379 z=40 P=0.0000095 z=45 P=0.0000024 z=50 P=0.0000006</p><p>求解令P&lt;0.1%的z值：</p><p>为使P&lt;0.001，则 q=0.10 z=5 q=0.15 z=8 q=0.20 z=11 q=0.25 z=15 q=0.30 z=24 q=0.35 z=41 q=0.40 z=89 q=0.45 z=340</p><h2 id="12-结论"><a href="#12-结论" class="headerlink" title="12.结论"></a>12.结论</h2><p>我们在此提出了一种不需要信用中介的电子支付系统。我们首先讨论了通常的电子货币的电子签名原理，虽然这种系统为所有权提供了强有力的控制，但是不足以防止双重支付。为了解决这个问题，我们提出了一种采用工作量证明机制的点对点网络来记录交易的公开信息，只要诚实的节点能够控制绝大多数的CPU计算能力，就能使得攻击者事实上难以改变交易记录。该网络的强健之处在于它结构上的简洁性。节点之间的工作大部分是彼此独立的，只需要很少的协同。每个节点都不需要明确自己的身份，由于交易信息的流动路径并无任何要求，所以只需要尽其最大努力传播即可。节点可以随时离开网络，而想重新加入网络也非常容易，因为只需要补充接收离开期间的工作量证明链条即可。节点通过自己的CPU计算力进行投票，表决他们对有效区块的确认，他们不断延长有效的区块链来表达自己的确认，并拒绝在无效的区块之后延长区块以表示拒绝。本框架包含了一个P2P电子货币系统所需要的全部规则和激励措施。</p><p>1.W Dai（戴伟）,a scheme for a group of untraceable digital pseudonyms to pay each other with money and to enforce contracts amongst themselves without outside help（一种能够借助电子假名在群体内部相互支付并迫使个体遵守规则且不需要外界协助的电子现金机制）, “B-money”, <a href="http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a>, 1998<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-1">↵</a></p><p>2.H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,”（在最小化信任的基础上设计一种时间戳服务器） In 20th Symposium on Information Theory in the Benelux, May 1999.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-2">↵</a></p><p>3.S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” （怎样为电子文件添加时间戳）In Journal of Cryptology, vol 3, No.2, pages 99-111, 1991.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-3">↵</a></p><p>4.D. Bayer, S. Haber, W.S. Stornetta, “Improving the efficiency and reliability of digital time-stamping,”（提升电子时间戳的效率和可靠性） In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-4">↵</a></p><p>5.S. Haber, W.S. Stornetta, “Secure names for bit-strings,”（比特字串的安全命名） In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. on Computer and Communications Security, pages 28-35, April 1997.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-5">↵</a></p><p>6.A. Back, “Hashcash - a denial of service counter-measure,”（哈希现金——拒绝服务式攻击的克制方法）<a href="http://www.hashcash.org/papers/hashcash.pdf">http://www.hashcash.org/papers/hashcash.pdf</a>, 2002. <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-6">↵</a></p><p>7.R.C. Merkle, “Protocols for public key cryptosystems,” （公钥密码系统的协议）In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980. S. Haber, W.S. Stornetta, “Secure names for bit-strings,”（比特字串安全命名） In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. on Computer and Communications Security, pages 28-35, April 1997. H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,”（在最小化信任的条件下设计一种时间戳服务器） In 20th Symposium on Information Theory in the Benelux, May 1999. <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-7">↵</a></p><p>8.W. Feller, “An introduction to probability theory and its applications,” （概率学理论与应用导论）1957 <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-8">↵</a></p><h2 id="此文转载自-https-www-8btc-com-wiki-bitcoin-a-peer-to-peer-electronic-cash-system"><a href="#此文转载自-https-www-8btc-com-wiki-bitcoin-a-peer-to-peer-electronic-cash-system" class="headerlink" title="此文转载自 https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system"></a>此文转载自 <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system</a></h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript小记---01</title>
    <link href="/2021/07/28/JavaScript%E5%B0%8F%E8%AE%B001/"/>
    <url>/2021/07/28/JavaScript%E5%B0%8F%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h1 id="Array-apply-null-length-20-map"><a href="#Array-apply-null-length-20-map" class="headerlink" title="Array.apply(null, { length 20 }).map()"></a>Array.apply(null, { length 20 }).map()</h1><p>参考链接 <a href="https://blog.csdn.net/qq_20794095/article/details/103244977">https://blog.csdn.net/qq_20794095/article/details/103244977</a></p><p>本质是<strong>函数式编程</strong>的<strong>循环方法</strong>。</p><p>就是一种<strong>循环方法</strong>，你用<code>for</code>循环代替，效果也是一样的，但是<code>Array.apply(null, &#123; length: 20 &#125;).map()</code>算是<strong>函数式编程</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.cardloading = <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>(<span class="hljs-number">20</span>)).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br><span class="hljs-built_in">this</span>.eploading = <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>(<span class="hljs-number">20</span>)).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这就是简单的<strong>函数式循环</strong>。然而重点其实是前面<strong>需要循环的数组</strong>，如何<strong>优雅</strong>的产生。</p><p>如果我们想循环<code>20</code>次，直接写一个<code>0</code>到<code>20</code>的数组，结合<code>forEach</code>是可以的，但是未免显得有些拙略,</p><p>可以使用<code>js</code>内置函数<code>Array()</code>来生成一个<strong>指定长度</strong>的数组，这样子只需要指定长度就能循环了</p><p>直接使用<code>Array()</code>可以生成指定长度的数组，但是会有一个问题：<strong>数组里面的值都是没有初始化的</strong>！！重要的是，你<strong>拿不到循环的索引</strong>，因为里面的<code>key</code>和<code>value</code>都是<code>empty</code>状态</p><p>为了解决<code>index</code>无法获取的问题，我们可以<strong>在<code>Array()</code>初始化的时候传入数值</strong></p><h3 id="主要用户操作数组"><a href="#主要用户操作数组" class="headerlink" title="主要用户操作数组"></a>主要用户操作数组</h3><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul><li><p>传入  <strong>2</strong>     个参数的时候是删除    (第一个参数是要删除元素的位置,    第二个参数是要删除的元素数量)</p></li><li><p>传入 <strong>3</strong>    个参数可执行插入操作    (第一个参数是要参入的位置,    第二个参数任然是要删除的元素的数量在插入操作中是0,    第三个参数是想要插入的元素—-可以很多个) </p><ul><li>注意当 第二个参数为     <strong>1</strong>    便是替换操作了</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是模块化开发,为什么需要模块化开发?</title>
    <link href="/2021/07/26/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <url>/2021/07/26/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><blockquote><p>前端模块化的本质就是组件化、复用性，是为了提高开发效率而生的。</p><p><strong>将独立的功能代码封装成一个独立的文件在需要的时候引用它</strong></p><p>在网站发展的早期，前端页面上的JavaScript仅是用来做页面逻辑交互和表单验证的，随着Web2.0的兴起，各种前端技术也层出不穷，前端代码越来越臃肿了。而JavaScript由于设计时的定位问题，导至没有“类”的概念，导致以前的JS代码写的都很分散，没有“模块化”的思想。</p><p>那时我们开发网站，前端页面就存在一个“复用性”的问题，比如你写了给网站A写了一个表单验证处理逻辑，等开发网站B时还是存在表单验证逻辑，还需要再次写代码，浪费精力。</p><p>虽然可以写成公共函数库，但不可避免的存在多个函数库某个函数命名冲突的情况，所以前端“工程化”难以实现。这时，国外很多大牛就意识到“模块化”的重要性了，于是推出了不少模块化的实现框架。</p><p>前端模块化能给我们带来以下便利：</p><p>组件化，提高生产力，代码扩展性强；</p><p>解决了命名冲突，减少了全局空间的污染；</p><p>解决了文件依懒问题，让开发者关注于业务的实现。</p><p>最后，不管项目的大小，我觉得模块化都是很有必要的</p></blockquote><h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><p>先看伴随 nodejs 而诞生的 commonjs 规范。commonjs 规范应用于 nodejs 应用中，在 nodejs 应用中每个文件就是一个模块，拥有自己的作用域，文件中的变量、函数都是私有的，与其他文件相隔离。</p><p>CommonJS规范规定，每个模块内部， <code>module 变量代表当前模块。这个变量是一个对象</code>，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。（引用阮一峰老师的描述）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// util\index.js</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;now&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>;<br><br><span class="hljs-keyword">let</span> fun = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;into fun&#x27;</span>);<br>    name = <span class="hljs-string">&#x27;change&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    name,<br>    fun<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>)<br><br><span class="hljs-comment">// appJsBridge\index.js</span><br><span class="hljs-keyword">var</span> &#123; name, fun &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util/index.js&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>上面这个文件有两个变量，一个函数，通过 module.exports 暴露变量 name 和函数 fun ,age 这个变量就是私有的，外部无法直接访问，如果想让 age 变量全局都可以访问，那么可以改成 global.age = 18 ，但这样子会污染全局作用域，</p><p>module 中有这些属性</p><p>module.id 模块的识别符，<code>通常是带有绝对路径的模块文件名</code>。<code>module.filename</code> 模块的文件名，带有绝对路径。<code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。<code>module.parent</code> 返回一个<code>module</code>对象，表示调用该模块的模块，如果改该模块没有被引用，那么 <code>parent</code> 就是 <code>null module.children</code> 返回一个<code>module</code>数组，表示该模块要用到的其他模块。<code>module.exports</code> 表示模块对外输出的值。<code>module.paths</code> 这个用于 <code>require</code> 查找该文件的位置。</p><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>既然有 module.exports 导出，那么就有与之相对应的 require 导入，如下</p><p><code>var &#123; name, fun, object &#125; = require(&#39;./util/index.js&#39;) // 不用解构，直接导出对象也可以使用</code> require 我们最关心的就是文件路径，这里还是引用阮一峰老师的解释</p><h2 id="module-exports-和-exports"><a href="#module-exports-和-exports" class="headerlink" title="module.exports 和 exports"></a>module.exports 和 exports</h2><p>我们还可以导出 exports 直接使用，但需要注意一点，exports 是已经定义的常量，在导出的时候不能在给它定义，如下</p><p>let exports = module.exports // 错误 #region exports  Identifier ‘exports’ has already been declared<br>exports = module.exports; // 正确的</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h2><p><strong>commonjs 规范是在运行时加载的，在运行时导出对象，导出的对象与原本模块中的对象是隔离的，简单的说就是克隆了一份。看下面这个栗子</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// util\index.js</span><br><span class="hljs-keyword">let</span> object = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">let</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;modules obj&#x27;</span>, object);<br>    object = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">99</span> &#125;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    fun,<br>    object<br>&#125;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> &#123; name, fun, object &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util/index.js&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before fun&#x27;</span>, object)<br>fun()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;end fun&#x27;</span>, object)<br><br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">before fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>modules obj &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>end fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br></code></pre></td></tr></table></figure><p>引用方调用了导出的 fun 方法，fun 方法改变了模块中的 object 对象，可是在 index.js 中导出的 object 对象并没有发生改变，所以可见 commonjs 规范下模块的导出是深克隆的。</p><h2 id="注意我觉得上面的说法有些不完全正确"><a href="#注意我觉得上面的说法有些不完全正确" class="headerlink" title="注意我觉得上面的说法有些不完全正确"></a>注意我觉得上面的说法有些不完全正确</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">let</span> object = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">let</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;modules obj&#x27;</span>, object);<br>    object.age=<span class="hljs-number">12</span><br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    fun,<br>    object<br>&#125;<br><br><span class="hljs-comment">// index02.js</span><br><span class="hljs-keyword">var</span> &#123; fun, object &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before fun&#x27;</span>, object)<br>fun()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;end fun&#x27;</span>, object)<br></code></pre></td></tr></table></figure><p>测试结果如下, 这结果说明能改变 ===&gt;&gt;&gt;此处保留求解各位!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">before fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>modules obj &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>end fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">12</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><p>ECMA推出了官方标准的模块化解决方案，使用 export 导出，import 导入，编码简洁，从语义上更加通俗易懂。</p><p>ES6 支持异步加载模块 的模块不是对象，而是在编译的时候就完成模块的引用，所以是编译时才加载的。</p><blockquote><p>阮一峰老师的话</p><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p></blockquote><h2 id="ES6-模块规范和-commonjs-规范-运行机制的区别"><a href="#ES6-模块规范和-commonjs-规范-运行机制的区别" class="headerlink" title="ES6 模块规范和 commonjs 规范 运行机制的区别"></a>ES6 模块规范和 commonjs 规范 运行机制的区别</h2><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</p><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</p><h2 id="AMD-require-js-和-CMD-sea-js"><a href="#AMD-require-js-和-CMD-sea-js" class="headerlink" title="AMD-require.js 和 CMD-sea.js"></a>AMD-require.js 和 CMD-sea.js</h2><p>聊到 AMD 和 CMD 这两个规范都离不开 require.js 和 sea.js，这是早些年，为了解决浏览器异步加载模块而诞生的方案。随着打包工具的发展，commonjs和es6都可以在浏览器上运行了，所以 AMD、CMD 将逐渐被替代。</p><p>AMD规范的模块化：用 require.config()指定引用路径等，用define()定义模块，用require()加载模块。</p><p>CMD规范的模块化：用define()定义模块， seajs.use 引用模块。</p><h2 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h2><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><h2 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h2><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack基础</title>
    <link href="/2021/07/24/webpack%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/07/24/webpack%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="1-webpack-是什么？"><a href="#1-webpack-是什么？" class="headerlink" title="1.webpack 是什么？"></a>1.webpack 是什么？</h3><p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a>，然后将你项目中所需的每一个模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示你的内容。</p><h3 id="2-webpack-的核心概念"><a href="#2-webpack-的核心概念" class="headerlink" title="2.webpack 的核心概念"></a>2.webpack 的核心概念</h3><ul><li>entry: 入口</li><li>output: 输出</li><li>loader: 模块转换器，用于把模块原内容按照需求转换成新内容</li><li>插件(plugins): 扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</li></ul><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点(entry point)</strong> 指示 webpack 应该使用哪个模块，来作为构建其内部 <a href="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a> 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>默认值是 <code>./src/index.js</code>，但你可以通过在 <a href="https://webpack.docschina.org/configuration">webpack configuration</a> 中配置 <code>entry</code> 属性，来指定一个（或多个）不同的入口起点。例如：</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./path/to/my/entry/file.js&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出(output)"></a>输出(output)</h2><p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件。主要输出文件的默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在 <code>./dist</code> 文件夹中。</p><p>你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./path/to/my/entry/file.js&#x27;</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;my-first-webpack.bundle.js&#x27;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。<strong>loader</strong> 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href="https://webpack.docschina.org/concepts/modules">模块</a>，以供应用程序使用，以及被添加到依赖图中。</p><p>在更高层面，在 webpack 的配置中，<strong>loader</strong> 有两个属性：</p><ol><li><code>test</code> 属性，识别出哪些文件会被转换。</li><li><code>use</code> 属性，定义出在进行转换时，应该使用哪个 loader。</li></ol><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;my-first-webpack.bundle.js&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, use: <span class="hljs-string">&#x27;raw-loader&#x27;</span> &#125;],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 webpack 编译器(compiler) 如下信息：</p><blockquote><p>“嘿，webpack 编译器，当你碰到「在 <code>require()</code>/<code>import</code> 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先 <strong>use(使用)</strong> <code>raw-loader</code> 转换一下。”</p></blockquote><h2 id="插件-plugin"><a href="#插件-plugin" class="headerlink" title="插件(plugin)"></a>插件(plugin)</h2><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h6><p>查看 <a href="https://webpack.docschina.org/api/plugins">插件接口(plugin interface)</a>，学习如何使用它来扩展 webpack 能力。</p><p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-comment">// 通过 npm 安装</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>); <span class="hljs-comment">// 用于访问内置插件</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, use: <span class="hljs-string">&#x27;raw-loader&#x27;</span> &#125;],<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> &#125;)],<br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>html-webpack-plugin</code> 为应用程序生成一个 HTML 文件，并自动将生成的所有 bundle 注入到此文件中。</p><h2 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式(mode)"></a>模式(mode)</h2><p>通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 <code>production</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习记录</title>
    <link href="/2021/07/20/Nginx%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/20/Nginx%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="nginx的特点"><a href="#nginx的特点" class="headerlink" title="nginx的特点"></a>nginx的特点</h2><blockquote><p>Nginx的基础，特性，配置部署，优化，以及企业中的日常运维管理和应用。作为HTTP服务软件的后起之秀，Nginx与它的老大哥Apache相比有很多改进之处，比如，在性能上，Nginx占用的系统资源更少，能支持更多的并发连接（特别是静态小文件场景下），达到更高的访问效率；在功能上，Nginx不但是一个优秀的Web服务软件，还可以作为反向代理负载均衡及缓存服务使用；在安装配置上，Nginx更为方便，简单，灵活，可以说，Nginx是一个极具发展潜力的Web服务软件。</p></blockquote><ul><li>nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。</li><li>nginx因具有高并发（特别是静态资源），占用系统资源少等特性，且功能丰富而逐渐流行起来。</li><li>nginx不但是一个优秀Web服务软件，还具有反向代理负载均衡功能和缓存服务功能，与lvs负载均衡及Haproxy等专业代理软件相比，Nginx部署起来更为简单，方便；在缓存功能方面，它又类似于Squid等专业的缓存服务软件。</li><li>支持高并发：能支持几万并发连接（特别是静态小文件业务环境）</li><li>资源消耗少：在3万并发连接下，开启10个Nginx线程消耗的内存不到200MB</li><li>可以做HTTP反向代理及加速缓存，即负载均衡功能，内置对RS节点服务器健康检查功能，这相当于专业的Haproxy软件或LVS的功能</li><li>具备Squid等专业缓存软件等的缓存功能。</li><li>支持异步网络I／O事件模型epoll（linux2.6+）。</li></ul><h2 id="nginx-的主要应用"><a href="#nginx-的主要应用" class="headerlink" title="nginx 的主要应用"></a>nginx 的主要应用</h2><p>作为Web服务软件</p><blockquote><p>Nginx是一个支持高性能，高并发的Web服务软件，它具有很多优秀的特性，作为Web服务器，与Apache相比，Nginx能够支持更多的并发连接访问，但占用的资源更少，效率更高，在功能上也强大了很多，几乎不逊色于Apache。</p></blockquote><p>反向代理或负载均衡服务</p><blockquote><p>在反向代理或负载均衡服务方面，Nginx可以作为Web服务，PHP等动态服务及Memcached缓存的代理服务器，它具有类似专业反向代理软件（如Haproxy）的功能，同时也是一个优秀的邮件代理服务软件，但是Nginx的代理功能还是相对简单了些，特别是不支持TCP的代理（Nginx1.9.0版本已经开始支持TCP代理了）</p></blockquote><h2 id="Nginx主配置文件nginx-conf"><a href="#Nginx主配置文件nginx-conf" class="headerlink" title="Nginx主配置文件nginx.conf"></a>Nginx主配置文件nginx.conf</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span>  <span class="hljs-number">1</span>; <span class="hljs-comment">#worker进程的数量</span><br><span class="hljs-attribute">error_log</span>  logs/error.log;  <span class="hljs-comment">#错误日志（默认没开）</span><br><span class="hljs-attribute">pid</span>        logs/nginx.pid;  <span class="hljs-comment">#进程号（默认没开）</span><br><span class="hljs-section">events</span> &#123;    <span class="hljs-comment">#事件区块开始</span><br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;   <span class="hljs-comment">#每个worker进程支持的最大连接数</span><br>&#125;           <span class="hljs-comment">#事件区块结束</span><br><span class="hljs-section">http</span> &#123;      <span class="hljs-comment">#http区块开始</span><br>    <span class="hljs-attribute">include</span>       mime.types;   <span class="hljs-comment">#Nginx支持的媒体类型库文件包含</span><br>    <span class="hljs-attribute">default_type</span>  application/octet-stream; <span class="hljs-comment">#默认的媒体类型</span><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;     <span class="hljs-comment">#开启高效传输模式</span><br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;  <span class="hljs-comment">#连接超时。</span><br>    <span class="hljs-section">server</span> &#123;      <span class="hljs-comment">#网站配置区域（第一个server第一个虚拟主机站点）</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;    <span class="hljs-comment">#提供服务的端口，默认80</span><br>        <span class="hljs-attribute">server_name</span>  www.chensiqi.org; <span class="hljs-comment">#提供服务的域名主机名</span><br>        <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-comment">#第一个Location区块开始</span><br>            <span class="hljs-attribute">root</span>   html;  <span class="hljs-comment">#站点的根目录（相对于nginx安装路径）</span><br>            <span class="hljs-attribute">index</span>  index.html index.htm; <span class="hljs-comment">#默认的首页文件，多个用空格分开</span><br>        &#125;<br>        <span class="hljs-attribute">error_page</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;  <span class="hljs-comment">#出现对应的http状态码时，使用50x.html回应客户</span><br>        <span class="hljs-attribute">location</span> = /50x.html &#123;  <span class="hljs-comment">#Location区块开始，访问50x.html</span><br>            <span class="hljs-attribute">root</span>   html;     <span class="hljs-comment">#指定对应的站点目录为html</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-section">server</span> &#123;      <span class="hljs-comment">#网站配置区域（第二个server第二个虚拟主机站点）</span><br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;    <span class="hljs-comment">#提供服务的端口，默认80</span><br>        <span class="hljs-attribute">server_name</span>  bbs.chensiqi.org; <span class="hljs-comment">#提供服务的域名主机名</span><br>        <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-comment">#服务区块</span><br>            <span class="hljs-attribute">root</span>   html;  <span class="hljs-comment">#相对路径（nginx安装路径）</span><br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123; <span class="hljs-comment">#发生错误访问的页面</span><br>            <span class="hljs-attribute">root</span>   html;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整个nginx配置文件的核心框架如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">worker_processes</span> <span class="hljs-number">1</span>;<br><span class="hljs-section">events</span> &#123;<br>    <br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;<br><br>&#125;<br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span> mime.types;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>  <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>  html;<br>            <span class="hljs-attribute">index</span>  index.html index.htm;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yarn快速、可靠、安全的依赖管理工具</title>
    <link href="/2021/07/16/yarn%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/16/yarn%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="yarn快速、可靠、安全的依赖管理工具。—npm就不多说了"><a href="#yarn快速、可靠、安全的依赖管理工具。—npm就不多说了" class="headerlink" title="yarn快速、可靠、安全的依赖管理工具。—npm就不多说了"></a>yarn快速、可靠、安全的依赖管理工具。—npm就不多说了</h3><h4 id="速度超快。"><a href="#速度超快。" class="headerlink" title="速度超快。"></a>速度超快。</h4><p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。</p><h4 id="超级安全。"><a href="#超级安全。" class="headerlink" title="超级安全。"></a>超级安全。</h4><p>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p><h4 id="超级可靠。"><a href="#超级可靠。" class="headerlink" title="超级可靠。"></a>超级可靠。</h4><p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p><p>Yarn 对你的代码来说是一个包管理器。它可以让你使用并分享 全世界开发者的（例如 JavaScript）代码。 Yarn 能够快速、安全、 并可靠地完成这些工作，所以你不用有任何担心。</p><p>通过Yarn你可以使用其他开发者针对不同问题的解决方案，使自己的开发过程更简单。 使用过程中遇到问题，你可以将其上报或者贡献解决方案。一旦问题被修复， Yarn会更新保持同步。</p><p>代码通过 <strong>包（package）</strong> (或者称为 <strong>模块（module）</strong>) 的方式来共享。 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为 <code>package.json</code> 。<a href="https://yarn.bootcss.com/docs/install">安装 →</a></p><h4 id="yarn的安装"><a href="#yarn的安装" class="headerlink" title="yarn的安装:"></a>yarn的安装:</h4><ol><li>下载node.js，使用npm安装<br><code>npm install -g yarn</code></li><li>Yarn 淘宝源安装，分别复制粘贴以下代码行到黑窗口运行即可<br>yarn config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> -g<br>yarn config set sass_binary_site <a href="http://cdn.npm.taobao.org/dist/node-sass">http://cdn.npm.taobao.org/dist/node-sass</a> -g</li></ol><p><strong>初始化一个新项目</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">yarn <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p><strong>添加依赖包</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">yarn <span class="hljs-built_in">add</span> [<span class="hljs-keyword">package</span>]<br>yarn <span class="hljs-built_in">add</span> [<span class="hljs-keyword">package</span>]@[version]<br>yarn <span class="hljs-built_in">add</span> [<span class="hljs-keyword">package</span>]@[tag]<br></code></pre></td></tr></table></figure><p><strong>将依赖项添加到不同依赖项类别中</strong></p><p>分别添加到 <code>devDependencies</code>、<code>peerDependencies</code> 和 <code>optionalDependencies</code> 类别中：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">yarn add [<span class="hljs-keyword">package</span>] <span class="hljs-comment">--dev</span><br>yarn add [<span class="hljs-keyword">package</span>] <span class="hljs-comment">--peer</span><br>yarn add [<span class="hljs-keyword">package</span>] <span class="hljs-comment">--optional</span><br></code></pre></td></tr></table></figure><p><strong>升级依赖包</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">yarn upgrade <span class="hljs-comment">[package]</span><br>yarn upgrade <span class="hljs-comment">[package]</span>@<span class="hljs-comment">[version]</span><br>yarn upgrade <span class="hljs-comment">[package]</span>@<span class="hljs-comment">[tag]</span><br></code></pre></td></tr></table></figure><p><strong>移除依赖包</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">yarn <span class="hljs-built_in">remove</span> [<span class="hljs-built_in">package</span>]<br></code></pre></td></tr></table></figure><h4 id="yarn的常用命令："><a href="#yarn的常用命令：" class="headerlink" title="yarn的常用命令："></a>yarn的常用命令：</h4><ul><li><p>安装 npm i -g  yarn</p></li><li><p>检查yarn 版本号 yarn -v</p></li><li><p>yarn的配置项：</p></li><li><p>yarn config list // 显示所有配置项<br>yarn config get <key> //显示某配置项<br>yarn config delete <key> //删除某配置项<br>yarn config set <key> <value> [-g|–global] //设置配置项</p></li><li><p>发布包  yarn publish</p></li><li><p>运行 脚本 yarn run  …</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>yarn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署vue +koa+nginx前后端分离项目到服务器</title>
    <link href="/2021/07/05/vue-koa/"/>
    <url>/2021/07/05/vue-koa/</url>
    
    <content type="html"><![CDATA[<h1 id="部署vue-koa-nginx前后端分离项目到服务器"><a href="#部署vue-koa-nginx前后端分离项目到服务器" class="headerlink" title="部署vue +koa+nginx前后端分离项目到服务器"></a>部署vue +koa+nginx前后端分离项目到服务器</h1><h5 id="因为遇到很多坑-百度了很多-记录一下-方便以后回看-也希望这篇文章能够帮到需要的人"><a href="#因为遇到很多坑-百度了很多-记录一下-方便以后回看-也希望这篇文章能够帮到需要的人" class="headerlink" title="因为遇到很多坑,百度了很多,记录一下,方便以后回看,也希望这篇文章能够帮到需要的人"></a>因为遇到很多坑,百度了很多,记录一下,方便以后回看,也希望这篇文章能够帮到需要的人</h5><p>先上正确部署，</p><ol><li><p>部署前先确保本地可以跑起来，在打包前对自己项目的修改=&gt;把baseurl 修改成<strong>自己的ip地                址</strong>，原来可能类似这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// axios 配置接口默认路径</span><br>axios.defaults.baseURL = <span class="hljs-string">&#x27;http://127.0.0.1:8888/api/&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>cd到自己的项目目录下  <code>npm run build </code> 就行打包，右侧就会出来打包后的文件夹<strong>dist</strong>，这些是自己的静态资源。前端到这里打包完成。在自己的服务器上新建个文件夹例如/www/demo，这个目录就是我们网站的根目录了。可以选择通过xshell 自带的xftp，也可以直接用宝塔面板把本地的dist文件夹上传到服务器。</p></li><li><p><strong>这里使用的是阿里云服务器，通过xhell 连接操作服务器，并且使用宝塔Linux操作面板方便安装一些环境，对新手十分友好，就像软件商店一样简单。</strong></p></li><li><p>nginx 的安装，nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。宝塔操作面板软件商店一键安装，我们只需要关心nginx的配置问题<br><img src="https://img-blog.csdnimg.cn/20210307121212315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>nginx的使用<code>cd /usr/local/nginx/sbin</code>。一些命令<code> ./nginx  启动</code>，<code>./nginx -s stop 停止</code>，<code> ./nginx  -s reload 重启</code>，当修改完配置文件记得重新启动nginx</p></li><li><p>nginx的配置，<strong>nginx.conf</strong>  。可以通过<code>vim /etc/nginx/nginx.conf</code>编辑</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">server<br>   &#123;<br>       listen 80;  <span class="hljs-comment">#监听的端口号</span><br>       server_name <span class="hljs-comment">#自己服务器的ip地址;  </span><br>       index index.html index.htm index.php;  <span class="hljs-comment">#默认页面</span><br>       root  /www/demo/dist; <span class="hljs-comment"># 自己项目的根目录，不知道的看上的打包</span><br></code></pre></td></tr></table></figure></li><li><p>部署后端项目，把本地文件夹上传至服务器，本地原来是通过node  app.js来运行一个服务部署到服务器，也就相当于在服务器上运行一个进程。注意需要端口号的开放。去阿里云的实例控制台对安全组就行管理，开放你需要的端口号。查看正在运行的端口<code>netstat -ntlp</code>常用。</p></li><li><p>使用pm2 管理后端接口，<br> 安装pm2</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install pm2 -g<br></code></pre></td></tr></table></figure><p> 开启服务pm2</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 start app.js                //启动app.js应用<br></code></pre></td></tr></table></figure><p> 停止服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 stop all               //停止所有应用<br>pm2 stop [AppName]        //根据应用名停止指定应用<br>pm2 stop [ID]             //根据应用id停止指定应用<br></code></pre></td></tr></table></figure><p> 自启动 <code>pm2 startup</code></p><h5 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h5></li></ol><hr><p>因为在项目中使用了WebSocket,部署是遇见这个报错,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">WebSocket connection to <span class="hljs-string">&#x27;ws://*********&#x27;</span> failed: <span class="hljs-built_in">Error</span> <span class="hljs-keyword">in</span> connection establishment: net::ERR_CONNECTION_TIMED_OUT<br></code></pre></td></tr></table></figure><p>解决方案 :  运行下面代码关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop firewalld.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用git指令集合</title>
    <link href="/2021/07/04/%E5%B8%B8%E7%94%A8git%E6%8C%87%E4%BB%A4%E9%9B%86%E5%90%88/"/>
    <url>/2021/07/04/%E5%B8%B8%E7%94%A8git%E6%8C%87%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="常用的git指令集合"><a href="#常用的git指令集合" class="headerlink" title="常用的git指令集合"></a>常用的git指令集合</h2><p><img src="http://lxandzjy.top:9003/2021/12/01/d30bde1f73083.png"></p><p><img src="http://lxandzjy.top:9003/2021/12/01/550cb97dc2987.png"></p><ul><li>workspace：工作区</li><li>staging area：暂存区/缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><h4 id="1-git-查看本地仓库，对应的“远程仓库地址”"><a href="#1-git-查看本地仓库，对应的“远程仓库地址”" class="headerlink" title="1. git 查看本地仓库，对应的“远程仓库地址”"></a>1. git 查看本地仓库，对应的“远程仓库地址”</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@istester</span> gittest]<span class="hljs-meta"># git remote -v</span><br></code></pre></td></tr></table></figure><h4 id="2-下载git注册git账号并进行全局配置-Git-Bash-Here"><a href="#2-下载git注册git账号并进行全局配置-Git-Bash-Here" class="headerlink" title="2. 下载git注册git账号并进行全局配置 // Git Bash Here"></a>2. 下载git注册git账号并进行全局配置 // Git Bash Here</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-number">1</span>. git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;nameVal&quot;</span> <span class="hljs-comment">// 配置用户名</span><br><span class="hljs-number">2</span>. git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;eamil@qq.com&quot;</span> <span class="hljs-comment">// 配置邮箱</span><br></code></pre></td></tr></table></figure><h4 id="3-版本回退"><a href="#3-版本回退" class="headerlink" title="3. 版本回退"></a>3. 版本回退</h4><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 回到上一个版本,将HEAD指针指向上一个commitID</span><br>git reset --hard <span class="hljs-string">&quot;HEAD^&quot;</span><br><br><span class="hljs-meta"># 回到指定版本</span><br>git reset --hard 版本号<br><br><span class="hljs-meta"># 回到最新版本</span><br>git pull origin [branchName]<br></code></pre></td></tr></table></figure><h4 id="4-Git强制拉取覆盖本地-Pull-force"><a href="#4-Git强制拉取覆盖本地-Pull-force" class="headerlink" title="4. Git强制拉取覆盖本地 Pull force"></a>4. Git强制拉取覆盖本地 Pull force</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">fetch</span> <span class="hljs-comment">--all  </span><br>git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard origin/master </span><br>git pull<br></code></pre></td></tr></table></figure><h4 id="5-第一次创建远程仓库并推送文件"><a href="#5-第一次创建远程仓库并推送文件" class="headerlink" title="5. 第一次创建远程仓库并推送文件"></a>5. 第一次创建远程仓库并推送文件</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 先进入项目文件夹<br><span class="hljs-number">1</span>. git init <span class="hljs-regexp">//</span> 初始化本地仓库<br><span class="hljs-number">2</span>. git remote add origin http...git <span class="hljs-regexp">//</span> 绑定本地和远程仓库<br><span class="hljs-number">3</span>. git add . <span class="hljs-regexp">//</span> 将本地仓库的变化添加到缓存区<br><span class="hljs-number">4</span>. git commit -m <span class="hljs-string">&quot;注释&quot;</span> <span class="hljs-regexp">//</span> 确认本地缓存区的内容 可以准备push<br><span class="hljs-number">5</span>. git push -u origin master<br></code></pre></td></tr></table></figure><h4 id="6-提交代码"><a href="#6-提交代码" class="headerlink" title="6. 提交代码"></a>6. 提交代码</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">add </span>. <span class="hljs-comment"># 将workspace修改的内容提交到暂存区</span><br>git commit -m <span class="hljs-string">&quot;提交信息&quot;</span> <span class="hljs-comment"># 将暂存区的内容提交到版本库</span><br><span class="hljs-comment"># 如果本地分支名与远程分支名相同，直接git push即可</span><br>git push <span class="hljs-keyword">origin </span>[<span class="hljs-keyword">branchName] </span><span class="hljs-comment"># 将版本库内容提交到远程仓库</span><br></code></pre></td></tr></table></figure><h4 id="7-在现有代码基础上获取远程最新代码"><a href="#7-在现有代码基础上获取远程最新代码" class="headerlink" title="7. 在现有代码基础上获取远程最新代码"></a>7. 在现有代码基础上获取远程最新代码</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">git fetch <span class="hljs-regexp">//</span> 获取远程最新代码版本<br>git pull <span class="hljs-regexp">//</span> 拉取远程最新版本的代码，并合并到本地 需要先做第一步 否则直接git pull拉取不到任何代码<br><span class="hljs-regexp">//</span> 如果遇见报错    Please, commit your changes or stash them before you can merge.  <br>git stash <span class="hljs-regexp">//</span> 备份当前的工作区，从最近一次提交中读取相关内容，让工作区保持和上一次提交的内容一致。<br>git pull <span class="hljs-regexp">//</span> 拉取远程代码<br>git stash pop  从git栈中读取最近一次保存的内容，恢复工作区的相关内容。 <br>自行对比修改  解决冲突<br></code></pre></td></tr></table></figure><h4 id="8-删除远程-amp-本地分支"><a href="#8-删除远程-amp-本地分支" class="headerlink" title="8. 删除远程&amp;本地分支"></a>8. 删除远程&amp;本地分支</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 删除远程</span><br>git push <span class="hljs-keyword">origin </span>--delete [<span class="hljs-keyword">branchName] </span><span class="hljs-comment"># 远程分支名</span><br><br><span class="hljs-comment"># 删除本地分支,因为删除远程分支时并不会把本地分支一并删除</span><br><span class="hljs-comment"># 注意删除本地分支时HEAD不能指向该分支,不然会删除失败</span><br>git <span class="hljs-keyword">branch </span>-D [<span class="hljs-keyword">branchName]</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># 查看现有分支</span><br>git <span class="hljs-keyword">branch </span>-a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 遇到的部署问题</title>
    <link href="/2021/07/04/hexo-bug/"/>
    <url>/2021/07/04/hexo-bug/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-遇到的部署问题"><a href="#hexo-遇到的部署问题" class="headerlink" title="hexo 遇到的部署问题"></a>hexo 遇到的部署问题</h1><p>下面是一些常用的 hexo 命令</p><ul><li>hexo   g  -d   //   生成静态文件并部署</li><li>hexo  s    //  本地运行</li><li>hexo clean  //   清理配置文件</li></ul><p><strong>出现问题的原因是  git 没有配置系统变量</strong></p><p>本来系统是有的,因为win10更新导致系统变量好多 都丢失了  也不知道为什么  node 的环境变量也没了</p><p>直接上解决方案===&gt;&gt;&gt;<br><strong>解决方案一</strong><br>    重新配置环境变量  然后就可以了<br><strong>解决方案二</strong><br>    到 hexo 的根目录下 右键 git bash  ;  在git bash  里面执行 hexo d 就能完成部署了</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>发npm包，遇到问题</title>
    <link href="/2021/06/28/npm%E5%8F%91%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/28/npm%E5%8F%91%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第一次发布npm包，登录不进去"><a href="#第一次发布npm包，登录不进去" class="headerlink" title="第一次发布npm包，登录不进去"></a>第一次发布npm包，登录不进去</h1><ul><li>第一次发包，首先需要有自己npm账号<ul><li>npm adduser</li></ul></li><li>然后我这边一直登录不上去 经百度得结果 （是因为设置了taobao代理）</li><li>config 命令<ul><li>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org</a></li><li>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li></ul></li><li>然后就可以登录了</li><li>npm publish 就可以推上去了</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware安装Centos7,Centos7下配置DNS服务器,配置WEB服务器,配置FTP服务器</title>
    <link href="/2021/06/23/VMware/"/>
    <url>/2021/06/23/VMware/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Centos7-VMware安装CentOS7超详细版"><a href="#安装Centos7-VMware安装CentOS7超详细版" class="headerlink" title="安装Centos7, VMware安装CentOS7超详细版"></a>安装Centos7, <a href="https://blog.csdn.net/tsundere_x/article/details/104263100">VMware安装CentOS7超详细版</a></h2><ul><li>安装系统的时候 简单点可以直接选择默认的自动分区</li><li>网络那里一定要配置,好多小伙伴总是连不上网，安装时连接上，后面都没问题</li></ul><hr><h2 id="Centos7-下配置DNS服务器"><a href="#Centos7-下配置DNS服务器" class="headerlink" title="Centos7 下配置DNS服务器"></a>Centos7 下配置DNS服务器</h2><p>centos7上安装DNS服务器可以实现域名与IP的双向解析，即通过域名可以找到主机IP，也可以通过IP找到域名。经历了多次失败,多次重装系统,简直不要太苦涩，对于重装系统的操作熟练的让人伤心。</p><ul><li><p>查看本机ip  <code>ip addr</code>  一般在ens33 ip长得类似这样 <code>192.168.202.129</code></p></li><li><p>安装bind  <code>yum install bind bind-utils -y</code></p></li><li><p>安装完成，可以查看named服务。  <code>systemctl status named</code></p></li><li><p>开始修改配置文件 <code>vim /etc/named.conf</code><img src="https://img-blog.csdnimg.cn/20210515101507936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>配置/etc/named.rfc1912.zones，增加一个正向解析与一个反向解析的配置，可以拷贝其他的zone 配置 ，下面的test.com也就是域名 改成自己想要的就可以了test.com 是例子</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -p named.localhost test.com.zone<br>cp -p named.loopback test.com.local<br></code></pre></td></tr></table></figure></li><li><p>有了两个文件，我们需要做修改，这里非常重要，因为文件格式在拷贝过程中可能会发生变化。<code>192.168.202.129</code>  129指的是ip最后的三位。下图是    <code>.zone   是域名的正向解析</code><br><img src="https://img-blog.csdnimg.cn/20210515103557564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下图是    <code>.local   是域名的反向解析</code><br><img src="https://img-blog.csdnimg.cn/20210515102618841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>配置本机DNS1，修改<code>/etc/sysconfig/network-scripts/ifcfg-en0或者/etc/sysconfig/network-scripts/ifcfg-ens33，</code><br>增加<code>DNS1=192.168.202.129</code></p></li><li><p>重启网络，启动named服务。named:<code>systemctl start named</code><br>网络：<code>service network restart</code></p></li><li><p>修改配置文件：<code>vim /etc/resolv.conf</code></p></li><li><p>进行验证 <code>nslookup www.域名    /      nslookup 192.168.202.129</code> </p><h6 id="大功告成-呼"><a href="#大功告成-呼" class="headerlink" title="大功告成  呼~~~"></a>大功告成  呼~~~</h6></li></ul><hr><h2 id="Centos7下配置WEB服务器"><a href="#Centos7下配置WEB服务器" class="headerlink" title="Centos7下配置WEB服务器"></a>Centos7下配置WEB服务器</h2><p> Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以处理浏览器等Web客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache、 Nginx 、IIS</p><ul><li><p>安装Apache服务  <code>yum install -y httpd</code></p></li><li><p>启动Apache服务  <code>ystemctl start httpd.service </code></p></li><li><p>切换目录 <code>cd /var/www</code></p></li><li><p>新建目录 <code>mkdir web</code></p></li><li><p>新建index.html    <code>echo &quot;this is web&quot; &gt; web/index.html</code></p></li><li><p> 修改配置文件 <code>在/etc/httpd/conf/httpd.conf</code><img src="https://img-blog.csdnimg.cn/20210515104831208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p> 打开自己 浏览器进行测试<img src="https://img-blog.csdnimg.cn/20210515105335176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="大功告成-呼-1"><a href="#大功告成-呼-1" class="headerlink" title="大功告成 呼~~~"></a>大功告成 呼~~~</h6></li></ul><hr><h2 id="Centos7下配置FTP服务器"><a href="#Centos7下配置FTP服务器" class="headerlink" title="Centos7下配置FTP服务器"></a>Centos7下配置FTP服务器</h2><p>FTP服务器（File Transfer Protocol Server）是在互联网上提供文件存储和访问服务的计算机，它们依照FTP协议提供服务。 FTP是File Transfer Protocol(文件传输协议)。顾名思义，就是专门用来传输文件的协议。简单地说，支持FTP协议的服务器就是FTP服务器</p><ul><li>安装vsftpd  <code>yum -y install vsftpd</code></li><li>按照下面修改配置文件  <code>vim vsftpd.conf</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#是否允许匿名，默认no</span><br><span class="hljs-attribute">anonymous_enable</span>=<span class="hljs-literal">NO</span><br><br><span class="hljs-comment">#这个设定值必须要为YES 时，在/etc/passwd内的账号才能以实体用户的方式登入我们的vsftpd主机</span><br><span class="hljs-attribute">local_enable</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#具有写权限</span><br><span class="hljs-attribute">write_enable</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#本地用户创建文件或目录的掩码</span><br><span class="hljs-attribute">local_umask</span>=022<br><br><span class="hljs-comment">#当dirmessage_enable=YES时，可以设定这个项目来让vsftpd寻找该档案来显示讯息！您也可以设定其它档名！</span><br><span class="hljs-attribute">dirmessage_enable</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#当设定为YES时，使用者上传与下载日志都会被纪录起来。记录日志与下一个xferlog_file设定选项有关：</span><br><span class="hljs-attribute">xferlog_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">xferlog_std_format</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#上传与下载日志存放路径</span><br><span class="hljs-attribute">xferlog_file</span>=/var/log/xferlog<br><br><span class="hljs-comment">#开启20端口</span><br><span class="hljs-attribute">connect_from_port_20</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#关于系统安全的设定值：</span><br><span class="hljs-attribute">ascii_download_enable</span>=<span class="hljs-literal">YES</span>(NO)<br>如果设定为<span class="hljs-literal">YES</span> ，那么<span class="hljs-built_in"> client </span>就可以使用 ASCII 格式下载档案。<br>一般来说，由于启动了这个设定项目可能会导致DoS 的攻击，因此预设是<span class="hljs-literal">NO</span>。<br><span class="hljs-attribute">ascii_upload_enable</span>=<span class="hljs-literal">YES</span>(NO)<br>与上一个设定类似的，只是这个设定针对上传而言！预设是<span class="hljs-literal">NO</span>。<br><span class="hljs-attribute">ascii_upload_enable</span>=<span class="hljs-literal">NO</span><br><span class="hljs-attribute">ascii_download_enable</span>=<span class="hljs-literal">NO</span><br><br><span class="hljs-comment">#通过搭配能实现以下几种效果：</span><br>①当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">YES</span>，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。<br>②当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">YES</span>，chroot_local_user=NO时，<br>在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。<br>③当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">NO</span>，<br><span class="hljs-attribute">chroot_local_user</span>=<span class="hljs-literal">YES</span>时，所有的用户均不能切换到其他目录。<br>④当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">NO</span>，<br><span class="hljs-attribute">chroot_local_user</span>=<span class="hljs-literal">NO</span>时，所有的用户均可以切换到其他目录。<br><br><span class="hljs-attribute">chroot_local_user</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">chroot_list_file</span>=/etc/vsftpd/chroot_list<br><br><span class="hljs-comment">#这个是pam模块的名称，我们放置在/etc/pam.d/vsftpd</span><br><span class="hljs-attribute">pam_service_name</span>=vsftpd<br><br><span class="hljs-comment">#当然我们都习惯支持TCP Wrappers的啦！</span><br><span class="hljs-attribute">tcp_wrappers</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#不添加下面这个会报错：500 OOPS: vsftpd: refusing to run with writable root inside chroot()</span><br><span class="hljs-attribute">allow_writeable_chroot</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#ftp的端口号</span><br><span class="hljs-attribute">listen_port</span>=60021<br><span class="hljs-comment">#启动被动式联机(passivemode)</span><br><span class="hljs-attribute">pasv_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-comment">#上面两个是与passive mode 使用的 port number 有关，如果您想要使用65400 到65410 这 11 个 port 来进行被动式资料的连接，可以这样设定</span><br><span class="hljs-attribute">pasv_min_port</span>=65400<br><span class="hljs-attribute">pasv_max_port</span>=65410<br><br><span class="hljs-comment">#FTP访问目录</span><br><span class="hljs-attribute">local_root</span>=/data/ftp/<br></code></pre></td></tr></table></figure><ul><li>启动暂停查看服务状态命令 </li><li><code>启动systemctl start vsftpd.service</code>  </li><li><code>暂停 systemctl status vsftpd.service</code></li><li>创建FTP用户<br> 添加FTP用户命令：useradd XXX<br>  设置FTP用户密码：passwd XXX</li></ul><h6 id="完结-呼"><a href="#完结-呼" class="headerlink" title="完结 呼~~~"></a>完结 呼~~~</h6><hr>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Centos7</tag>
      
      <tag>VMware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式的学习</title>
    <link href="/2021/06/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/06/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="正则表达式的学习"><a href="#正则表达式的学习" class="headerlink" title="正则表达式的学习"></a>正则表达式的学习</h3><blockquote><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p><p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><p>正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真阅读本教程，加上应用的时候进行一定的参考，掌握正则表达式不是问题。</p><p>许多程序设计语言都支持利用正则表达式进行字符串操作。</p></blockquote><ul><li>从字符串 str 中提取数字部分的内容(匹配一次)：<code>/[0-9]+/;</code></li><li><strong>?</strong> 通配符匹配文件名中的 0 个或 1 个字符，而 ***** 通配符匹配零个或多个字符。像 <strong>data(\w)?.dat</strong> 这样的模式将查找下列文件：</li><li><strong>^</strong> 为匹配输入字符串的开始位置。</li><li><strong>[0-9]+<strong>匹配多个数字， <strong>[0-9]</strong> 匹配单个数字，</strong>+</strong> 匹配一个或者多个。</li><li><strong>abc$<strong>匹配字母 <strong>abc</strong> 并以 <strong>abc</strong> 结尾，</strong>$</strong> 为匹配输入字符串的结束位置。</li><li>我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用以下正则表达式来设定。<strong>^[a-z0-9_-]{3,15}$</strong></li><li>匹配以数字开头,abc结尾的字符串       <strong>/^[0-9]+abc$/</strong></li><li><strong>runoo+b</strong>，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</li><li><strong>runoo*b</strong>，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li><li><strong>colou?r</strong> 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</li><li>[\s\S] 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</li><li>\w     匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</li><li>[A-Z]             [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</li></ul><h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 <strong>**，**runo*ob</strong> 匹配字符串 <strong>runo*ob</strong>。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符*<em>*</em> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td align="left">( )</td><td align="left"><strong>标记一个子表达式的开始和结束位置</strong>。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td align="left">.</td><td align="left"><strong>匹配除换行符 \n 之外的任何单字符</strong>。要匹配 . ，请使用 . 。</td></tr><tr><td align="left">[</td><td align="left"><strong>标记一个中括号表达式的开始</strong>。要匹配 [，请使用 [。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left">\</td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left"><strong>匹配输入字符串的开始位置</strong>，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td align="left">{</td><td align="left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td align="left">|</td><td align="left"><strong>指明两项之间的一个选择</strong>。要匹配 |，请使用 |。</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式<strong>零次或多次</strong>。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式<strong>一次或多次</strong>。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式<strong>零次或一次</strong>。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。<strong>最少匹配 n 次且最多匹配 m 次</strong>。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p><strong>[1-9]<strong>设置第一个数字不是 0，</strong>[0-9]*</strong> 表示任意多个数字：<code>/[1-9][0-9]*</code></p><p>*<strong>和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。</strong></p><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table><p>匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：</p><p><strong>\b</strong> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p><ul><li>**exp1(?=exp2)**：查找 exp2 前面的 exp1。</li><li><strong>(?&lt;=exp2)exp1</strong>：查找 exp2 后面的 exp1。</li><li>**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。</li><li><strong>(?&lt;!exp2)exp1</strong>：查找前面不是 exp2 的 exp1。</li></ul><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力</p><h1 id="正则表达式-修饰符（标记）"><a href="#正则表达式-修饰符（标记）" class="headerlink" title="正则表达式 - 修饰符（标记）"></a>正则表达式 - 修饰符（标记）</h1><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>flags<br></code></pre></td></tr></table></figure><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h1 id="正则表达式-元字符"><a href="#正则表达式-元字符" class="headerlink" title="正则表达式 - 元字符"></a>正则表达式 - 元字符</h1><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="left">?</td><td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td></tr><tr><td align="left">(pattern)</td><td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td align="left">(?:pattern)</td><td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td align="left">(?=pattern)</td><td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?!pattern)</td><td align="left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?&lt;=pattern)</td><td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95</td></tr><tr><td align="left">(?&lt;!pattern)</td><td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95</td></tr><tr><td align="left">x|y</td><td align="left">匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td align="left">[xyz]</td><td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td align="left">[^xyz]</td><td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td align="left">[a-z]</td><td align="left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td align="left">[^a-z]</td><td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\cx</td><td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td align="left">\xn</td><td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td align="left">\num</td><td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td align="left">\n</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td align="left">\nm</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td align="left">\nml</td><td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td align="left">\un</td><td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h1 id="正则表达式-运算符优先级"><a href="#正则表达式-运算符优先级" class="headerlink" title="正则表达式 - 运算符优先级"></a>正则表达式 - 运算符优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><p>下面列出一些正则表达式示例：</p><table><thead><tr><th align="left">正则表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">/\b([a-z]+) \1\b/gi</td><td align="left">一个单词连续出现的位置。</td></tr><tr><td align="left">/(\w+)://([^/:]+)(:\d*)?([^# ]*)/</td><td align="left">将一个URL解析为协议、域、端口及相对路径。</td></tr><tr><td align="left">/^(?:Chapter|Section) [1-9][0-9]{0,1}$/</td><td align="left">定位章节的位置。</td></tr><tr><td align="left">/[-a-z]/</td><td align="left">a至z共26个字母再加一个-号。</td></tr><tr><td align="left">/ter\b/</td><td align="left">可匹配chapter，而不能匹配terminal。</td></tr><tr><td align="left">/\Bapt/</td><td align="left">可匹配chapter，而不能匹配aptitude。</td></tr><tr><td align="left">/Windows(?=95 |98 |NT )/</td><td align="left">可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。</td></tr><tr><td align="left">/^\s*$/</td><td align="left">匹配空行。</td></tr><tr><td align="left">/\d{2}-\d{5}/</td><td align="left">验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</td></tr><tr><td align="left">/&lt;\s*(\S+)(\s[^&gt;]<em>)?&gt;[\s\S]</em>&lt;\s*/\1\s*&gt;/</td><td align="left">匹配 HTML 标记。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async await</title>
    <link href="/2021/06/12/Async%E5%87%BD%E6%95%B0/"/>
    <url>/2021/06/12/Async%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><ul><li>内置执行器</li><li><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果</li><li>更广的适用性。<code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</li><li>返回值是 Promise。<code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStockPriceByName</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> symbol = <span class="hljs-keyword">await</span> getStockSymbol(name);<br>  <span class="hljs-keyword">const</span> stockPrice = <span class="hljs-keyword">await</span> getStockPrice(symbol);<br>  <span class="hljs-keyword">return</span> stockPrice;<br>&#125;<br><br>getStockPriceByName(<span class="hljs-string">&#x27;goog&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br><br>f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br><span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>&#125;<br><br>f().then(<br>  <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolve&#x27;</span>, v),<br>  <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reject&#x27;</span>, e)<br>)<br><span class="hljs-comment">//reject Error: 出错了</span><br></code></pre></td></tr></table></figure><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 等同于</span><br>  <span class="hljs-comment">// return 123;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">123</span>;<br>&#125;<br><br>f().then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br><span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sleep</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">timeout</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.timeout = timeout;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-built_in">setTimeout</span>(<br>      <span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-built_in">Date</span>.now() - startTime),<br>      <span class="hljs-built_in">this</span>.timeout<br>    );<br>  &#125;<br>&#125;<br><br>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> sleepTime = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Sleep(<span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">console</span>.log(sleepTime);<br>&#125;)();<br><span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p><p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">interval</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, interval);<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one2FiveInAsync</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>    <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;<br><br>one2FiveInAsync();<br></code></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>  &#125;);<br>&#125;<br><br>f()<br>.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))<br><span class="hljs-comment">// Error：出错了</span><br></code></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> getFoo();<br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> getBar();<br></code></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">let</span> [foo, bar] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([getFoo(), getBar()]);<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">let</span> fooPromise = getFoo();<br><span class="hljs-keyword">let</span> barPromise = getBar();<br><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">await</span> fooPromise;<br><span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">await</span> barPromise;<br></code></pre></td></tr></table></figure><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dbFuc</span>(<span class="hljs-params">db</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];<br><br>  <span class="hljs-comment">// 报错</span><br>  docs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>&#123;<br>    <span class="hljs-keyword">await</span> db.post(doc);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>第四点，async 函数可以保留运行堆栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-function">() =&gt;</span> &#123;<br>  b().then(<span class="hljs-function">() =&gt;</span> c());<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p><p>现在将这个例子改成<code>async</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> b();<br>  c();<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2021/06/10/Promise%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/06/10/Promise%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</p><p>Promise是异步编程的一种解决方案,简单来说就是一个容器,里面保存着某个未来才会结束的事件</p><p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p><ul><li><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</li><li><em>已兑现（fulfilled）</em>: 意味着操作成功完成。</li><li><em>已拒绝（rejected）</em>: 意味着操作失败。</li></ul><p>待定状态的 Promise 对象要么会通过一个值<em>被兑现（fulfilled）</em>，要么会通过一个原因（错误）<em>被拒绝（rejected）</em>。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序就会被调用，因此在完成异步操作和绑定处理方法之间不会存在竞争状态。</p><p>因为 <code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code> 方法返回的是 promise， 所以它们可以被链式调用。</p><p><img src="http://lxandzjy.top:9003/2021/12/02/360bf99d451fd.png"></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将</span><br><span class="hljs-comment">//  异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为</span><br><span class="hljs-comment">//  rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ... some code</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    resolve(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    reject(error);<br>  &#125;<br>&#125;);<br><span class="hljs-comment">// Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</span><br>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-comment">// success</span><br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>Promise的执行顺序：</p><ul><li>Promise内部的代码是同步宏任务</li><li>而then/catch/finally的代码是微任务</li><li>当给Promise添加了多个处理程序，当Promise状态改变时，相关处理程序(then/catch/finally)会按添加顺序执行</li></ul></blockquote><p>Promise 新建后就会立即执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>  resolve();<br>&#125;);<br><br>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolved.&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi!&#x27;</span>);<br><br><span class="hljs-comment">// Promise</span><br><span class="hljs-comment">// Hi!</span><br><span class="hljs-comment">// resolved</span><br></code></pre></td></tr></table></figure><p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getJSON = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>) &#123;<br>        resolve(<span class="hljs-built_in">this</span>.response);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>    client.open(<span class="hljs-string">&quot;GET&quot;</span>, url);<br>    client.onreadystatechange = handler;<br>    client.responseType = <span class="hljs-string">&quot;json&quot;</span>;<br>    client.setRequestHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    client.send();<br><br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise;<br>&#125;;<br><br>getJSON(<span class="hljs-string">&quot;/posts.json&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Contents: &#x27;</span> + json);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;出错了&#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p><code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">getJSON(<span class="hljs-string">&quot;/posts.json&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> json.post;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">post</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">getJSON(<span class="hljs-string">&#x27;/posts.json&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">posts</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;<br>  <span class="hljs-comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;发生错误！&#x27;</span>, error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>promise<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// success</span><br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-comment">// error</span><br>  &#125;);<br><br><span class="hljs-comment">// good</span><br>promise<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123; <span class="hljs-comment">//cb</span><br>    <span class="hljs-comment">// success</span><br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-comment">// error</span><br>  &#125;);<br></code></pre></td></tr></table></figure><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.finally(<span class="hljs-function">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>下面是一个具体的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 生成一个Promise对象的数组</span><br><span class="hljs-keyword">const</span> promises = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> getJSON(<span class="hljs-string">&#x27;/post/&#x27;</span> + id + <span class="hljs-string">&quot;.json&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">Promise</span>.all(promises).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">posts</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([p1, p2, p3]);<br></code></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([<br>  fetch(<span class="hljs-string">&#x27;/resource-that-may-take-a-while&#x27;</span>),<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;request timeout&#x27;</span>)), <span class="hljs-number">5000</span>)<br>  &#125;)<br>]);<br><br>p<br>.then(<span class="hljs-built_in">console</span>.log)<br>.catch(<span class="hljs-built_in">console</span>.error);<br></code></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p><a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p><p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promises = [<br>  fetch(<span class="hljs-string">&#x27;/api-1&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/api-2&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/api-3&#x27;</span>),<br>];<br><br><span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.allSettled(promises);<br>removeLoadingIndicator();<br></code></pre></td></tr></table></figure><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p><p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> resolved = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">const</span> rejected = <span class="hljs-built_in">Promise</span>.reject(-<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">const</span> allSettledPromise = <span class="hljs-built_in">Promise</span>.allSettled([resolved, rejected]);<br><br>allSettledPromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(results);<br>&#125;);<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span><br><span class="hljs-comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.any([<br>  fetch(<span class="hljs-string">&#x27;https://v8.dev/&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;home&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;https://v8.dev/blog&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;blog&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;https://v8.dev/docs&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;docs&#x27;</span>)<br>]).then(<span class="hljs-function">(<span class="hljs-params">first</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 只要有一个 fetch() 请求成功</span><br>  <span class="hljs-built_in">console</span>.log(first);<br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123; <span class="hljs-comment">// 所有三个 fetch() 全部请求失败</span><br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p><p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promises = [<br>  fetch(<span class="hljs-string">&#x27;/endpoint-a&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;a&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/endpoint-b&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;b&#x27;</span>),<br>  fetch(<span class="hljs-string">&#x27;/endpoint-c&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;c&#x27;</span>),<br>];<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> first = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.any(promises);<br>  <span class="hljs-built_in">console</span>.log(first);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-built_in">console</span>.log(error);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jsPromise = <span class="hljs-built_in">Promise</span>.resolve($.ajax(<span class="hljs-string">&#x27;/whatever.json&#x27;</span>));<br></code></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;foo&#x27;</span>))<br></code></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> thenable = &#123;<br>  <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    resolve(<span class="hljs-number">42</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> thenable = &#123;<br>  <span class="hljs-attr">then</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    resolve(<span class="hljs-number">42</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(thenable);<br>p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 42</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s)<br>&#125;);<br><span class="hljs-comment">// Hello</span><br></code></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(<span class="hljs-string">&#x27;出错了&#x27;</span>))<br><br>p.then(<span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s)<br>&#125;);<br><span class="hljs-comment">// 出错了</span><br></code></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&#x27;出错了&#x27;</span>)<br>.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(e === <span class="hljs-string">&#x27;出错了&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝塔安装Lsky Pro图床教程</title>
    <link href="/2021/05/10/%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85Lsky%20Pro%E5%9B%BE%E5%BA%8A%E6%95%99%E7%A8%8B/"/>
    <url>/2021/05/10/%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85Lsky%20Pro%E5%9B%BE%E5%BA%8A%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Lsky-Pro图床是一个支持本地、阿里云-OSS、腾讯云-COS、七牛云、又拍云等储存方式的基于PHP的开源图床。"><a href="#Lsky-Pro图床是一个支持本地、阿里云-OSS、腾讯云-COS、七牛云、又拍云等储存方式的基于PHP的开源图床。" class="headerlink" title="Lsky Pro图床是一个支持本地、阿里云 OSS、腾讯云 COS、七牛云、又拍云等储存方式的基于PHP的开源图床。"></a>Lsky Pro图床是一个支持本地、阿里云 OSS、腾讯云 COS、七牛云、又拍云等储存方式的基于PHP的<a href="https://xiaoma.me/tag/%E5%BC%80%E6%BA%90%E5%9B%BE%E5%BA%8A">开源图床</a>。</h2><p>作为一个小白,又想拥有自己的博客,所以选择了宝塔,偶然发现了一个开源的图床,并且基于宝塔部署起来也很简单</p><p>项目主页：<a href="https://www.lsky.pro/">https://www.lsky.pro</a><br>项目仓库地址：<a href="https://github.com/wisp-x/lsky-pro">https://github.com/wisp-x/lsky-pro</a></p><p>Lsky Pro 使用手册：<a href="https://www.kancloud.cn/wispx/lsky-pro/880042">https://www.kancloud.cn/wispx/lsky-pro/880042</a></p><h3 id="基于宝塔面板安装Lsky-Pro图床教程"><a href="#基于宝塔面板安装Lsky-Pro图床教程" class="headerlink" title="基于宝塔面板安装Lsky Pro图床教程"></a>基于宝塔面板安装Lsky Pro图床教程</h3><p>宝塔官网地址:<a href="https://www.bt.cn/">https://www.bt.cn/</a></p><p><img src="http://lxandzjy.top:9003/2021/11/09/e468df2e4e34a.png"></p><h3 id="安装好宝塔面板，并按需求配置好环境，本次教程安装环境为：-PHP7-3-Nginx1-12-MySQL5-6"><a href="#安装好宝塔面板，并按需求配置好环境，本次教程安装环境为：-PHP7-3-Nginx1-12-MySQL5-6" class="headerlink" title="安装好宝塔面板，并按需求配置好环境，本次教程安装环境为： PHP7.3 Nginx1.12 MySQL5.6"></a>安装好宝塔面板，并按需求配置好环境，本次教程安装环境为： PHP7.3 Nginx1.12 MySQL5.6</h3><p><strong>1.安装扩展插件</strong><br>首页或者宝塔软件管理中点击你网站所使用版本的PHP设置，安装扩展，安装 fileinfo 拓展；curl拓展宝塔自带，如果你是较老版本，也可以自己去扩展插件里安装<br><img src="http://lxandzjy.top:9003/2021/11/09/21c959fc54bc3.png"></p><p><strong>2.添加一个站点，按需求选择好环境，点提交</strong></p><p><img src="http://lxandzjy.top:9003/2021/11/09/7d38c7f718116.png"></p><p><strong>3.下载LSKY PRO图床程序</strong></p><p>下载程序并上传到你创建的网站根目录下</p><ul><li>Github下载（推荐）：<a href="https://github.com/wisp-x/lsky-pro">https://github.com/wisp-x/lsky-pro</a></li></ul><p><strong>4.下载好后解压到当前目录</strong></p><p><strong>5.程序上传完后我们回到网站&gt;你的站点设置&gt;网站目录，将网站运行目录设置为 <code>/public</code>目录</strong></p><p><img src="http://lxandzjy.top:9003/2021/11/09/8adecc60a0ce6.png"></p><p><strong>6.配置 <code>Rewrite</code></strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">location / &#123;<br>   if (!-e <span class="hljs-variable">$request_filename</span>) &#123;<br>    rewrite ^(.*)<span class="hljs-variable">$ </span>/index.php?s=<span class="hljs-variable">$1</span> last; <span class="hljs-keyword">break</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://lxandzjy.top:9003/2021/11/09/6d34cae7aa52e.png"></p><p><strong>7.在浏览器中输入你的站点地址，将自动跳转至安装页面</strong></p><p><img src="http://lxandzjy.top:9003/2021/11/09/cfb8072d7c381.png"></p><p><strong>8.环境检测完后下一步是填写数据库相关信息，在最开始创建网站时，你设置的数据库名以及密码，就是那东西，将你的数据库名、数据库用户名以及数据库密码输入完后，点击配置数据库即可</strong></p><p><img src="http://lxandzjy.top:9003/2021/11/09/5016343f05e0f.png"></p><p><strong>9.如果你的数据库信息填写正确的话，将跳转到设置管理员账号的这一步，请自行设置管理员邮箱以及用户名和密码，填写完成后即可看到安装成功的提示界面</strong></p><p><img src="http://lxandzjy.top:9003/2021/11/09/75a45b3c1dbcd.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新手小白入门前后端分离-持续更新</title>
    <link href="/2021/04/13/%E6%96%B0%E6%89%8B%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2021/04/13/%E6%96%B0%E6%89%8B%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前后端分离-前端做前端的-后端做后端的-前端用-axios-调用后端的接口进行交互"><a href="#前后端分离-前端做前端的-后端做后端的-前端用-axios-调用后端的接口进行交互" class="headerlink" title="前后端分离,前端做前端的,后端做后端的.     前端用 axios 调用后端的接口进行交互"></a>前后端分离,前端做前端的,后端做后端的.     前端用 axios 调用后端的接口进行交互</h2><p>前端的目录结构<br>build – 构建相关<br>config – 配置<br>assets – 静态资源<br>components – 全局公用组件<br>router – 路由<br>utils – 公用方法<br>APP.vue – 入口页面<br>main.js – 入口文件，加载组件和初始化<br>static – 静态资源<br><img src="https://img-blog.csdnimg.cn/20210706134306321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"># 在这个项目中,components 下直接写的 前端页面,不是公用组件;<br>router.js 是前端的 页面管理, 注意这跟后端一点关系没有,  每一个 path 就是前端能访问的页面,(用户能访问的页面)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs javascript">routes: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;登录&#x27;</span>,<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">component</span>: Login<br>  &#125;, &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span><br>  &#125;, &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;文章管理&#x27;</span>,<br>    <span class="hljs-attr">iconCls</span>: <span class="hljs-string">&#x27;fa fa-file-text-o&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/articleList&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;文章列表&#x27;</span>,<br>        <span class="hljs-attr">component</span>: ArticleList,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;, &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/postArticle&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;发表文章&#x27;</span>,<br>        <span class="hljs-attr">component</span>: PostArticle,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;, &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/blogDetail&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;博客详情&#x27;</span>,<br>        <span class="hljs-attr">component</span>: BlogDetail,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;, &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/editBlog&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;编辑博客&#x27;</span>,<br>        <span class="hljs-attr">component</span>: PostArticle,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;用户管理&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>        <span class="hljs-attr">iconCls</span>: <span class="hljs-string">&#x27;fa fa-user-o&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;用户管理&#x27;</span>,<br>        <span class="hljs-attr">component</span>: UserMana<br>      &#125;<br>    ]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;栏目管理&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/cateMana&#x27;</span>,<br>        <span class="hljs-attr">iconCls</span>: <span class="hljs-string">&#x27;fa fa-reorder&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;栏目管理&#x27;</span>,<br>        <span class="hljs-attr">component</span>: CateMana<br>      &#125;<br>    ]<br>  &#125;, <br>]<br></code></pre></td></tr></table></figure><blockquote><p>   <a href="http://localhost:8080/#/">http://localhost:8080/#/</a>    井号后面开始的path<br>   看这个路径意思就是当访问path: ‘/‘, 根目录的时候==&gt;&gt;显示 component: Login Login页面</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;登录&#x27;</span>,<br>  <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">component</span>: Login<br>&#125;,<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210706140040496.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021070614000446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="这个页面"></p><h3 id="axios和接口封装"><a href="#axios和接口封装" class="headerlink" title="axios和接口封装:"></a>axios和接口封装:</h3><blockquote><p>在前后端交互方面采用axios，为了便于维护和复用，避免每个页面都引入一次axios和qs、避免每个接口都进行请求头配置，我们可以对axios进行封装。</p></blockquote><p>例子get方法的封装, 例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装get请求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">url</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">params</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">url, params = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    axios.get(url, &#123;<br>      <span class="hljs-attr">params</span>: params<br>    &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(response);<br>      <br>      resolve(response.data)<br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      reject(error)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们解析一下项目中的代码, 项目的代码如下,同样也是把代码封装了一层<br>注意 () =&gt; {}  这是es6的箭头函数, 他就是函数跟上边的function是一样的,()括号中是这个函数的参数;<br>用axios get post 等请求.params是参数 transformRequest在向服务器发送前，修改请求数据<br>export 是把这个函数导出 ====&gt;&gt;&gt;其他地方import 引入就能直接用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getRequest = <span class="hljs-function">(<span class="hljs-params">url,params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">data</span>:params,<br>    <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;<br>        ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">&#x27;&amp;&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> ret<br>    &#125;],<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span><br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteRequest = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;delete&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span><br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> postRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>    <span class="hljs-attr">data</span>: params,<br>    <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-comment">// Do whatever you want to transform the data</span><br>      <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;<br>        ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">&#x27;&amp;&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> ret<br>    &#125;],<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> uploadFileRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>    <span class="hljs-attr">data</span>: params,<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;multipart/form-data&#x27;</span><br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> putRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;put&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>    <span class="hljs-attr">data</span>: params,<br>    <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;<br>        ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">&#x27;&amp;&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> ret<br>    &#125;],<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript">找到登录的页面 用户输入的账号密码都通过 v-model进行双向绑定 存到了loginForm 这里<br><span class="hljs-keyword">import</span> &#123;postRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/api&#x27;</span>  通过<span class="hljs-keyword">import</span>引入封装好的方法<br>&lt;el-button type=<span class="hljs-string">&quot;primary&quot;</span> @click.native.prevent=<span class="hljs-string">&quot;submitClick&quot;</span> style=<span class="hljs-string">&quot;width: 100%&quot;</span>&gt;登录&lt;/el-button&gt;<br>这是登录的 按钮, 使用了element-ui ;  @click.native.prevent=<span class="hljs-string">&quot;submitClick&quot;</span> 绑定事件,当点击按钮的时候会触发这个方法函数.<br> <span class="hljs-string">&#x27;/login&#x27;</span>,为上方封装号的url; &#123;<span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.loginForm.username,<span class="hljs-attr">password</span>: <span class="hljs-built_in">this</span>.loginForm.password&#125;这就是要传递的参数<br>        <br>      <span class="hljs-attr">submitClick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">true</span>;<br>        postRequest(<span class="hljs-string">&#x27;/login&#x27;</span>, &#123;<br>          <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.loginForm.username,<br>          <span class="hljs-attr">password</span>: <span class="hljs-built_in">this</span>.loginForm.password<br>        &#125;).then(<span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span> &#123;<br>          _this.loading = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">if</span> (resp.status == <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-comment">//成功</span><br>            <span class="hljs-keyword">var</span> json = resp.data;<br>            <span class="hljs-keyword">if</span> (json.status == <span class="hljs-string">&#x27;success&#x27;</span>) &#123;<br>              _this.$router.replace(&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              _this.$alert(<span class="hljs-string">&#x27;登录失败!&#x27;</span>, <span class="hljs-string">&#x27;失败!&#x27;</span>);<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//失败</span><br>            _this.$alert(<span class="hljs-string">&#x27;登录失败!&#x27;</span>, <span class="hljs-string">&#x27;失败!&#x27;</span>);<br>          &#125;<br>        &#125;, <span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span> &#123;<br>          _this.loading = <span class="hljs-literal">false</span>;<br>          _this.$alert(<span class="hljs-string">&#x27;找不到服务器⊙﹏⊙∥!&#x27;</span>, <span class="hljs-string">&#x27;失败!&#x27;</span>);<br>        &#125;);<br>      &#125;<br>      ##############<br><span class="hljs-string">&#x27;/login&#x27;</span>  是后端的接口<br>注意 在config文件夹下的index文件中 配置了服务端的信息<br>意思就是 axios中写的url <span class="hljs-string">&#x27;/login&#x27;</span> 会和<span class="hljs-string">&#x27;http://localhost:8081&#x27;</span> 拼接在一起形成完整的服务端接口地址.<br>    <span class="hljs-comment">// Paths</span><br>    <span class="hljs-attr">assetsSubDirectory</span>: <span class="hljs-string">&#x27;static&#x27;</span>,<br>    <span class="hljs-attr">assetsPublicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">proxyTable</span>: &#123;<br>      <span class="hljs-string">&#x27;/&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8081&#x27;</span>,  <span class="hljs-comment">// 本地测试</span><br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-string">&#x27;^/&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>axios</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scss 学习笔记</title>
    <link href="/2021/04/11/Scss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/04/11/Scss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="Scss-学习笔记"><a href="#Scss-学习笔记" class="headerlink" title="Scss 学习笔记"></a>Scss 学习笔记</h3><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量用来存储需要在CSS中复用的信息，例如颜色和字体。SASS通过$符号去声明一个变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$font</span>-stack: Helvetica, sans-serif;<br><span class="hljs-variable">$primary</span>-color: <span class="hljs-comment">#333;</span><br><br>body &#123;<br>  font: 100% <span class="hljs-variable">$font</span>-stack;<br>  color: <span class="hljs-variable">$primary</span>-color;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中变量$font-stack和$primary-color的值将会替换所有引用他们的位置。</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>SASS允许开发人员以嵌套的方式使用CSS，但是过度的使用嵌套会让产生的CSS难以维护，因此是一种不好的实践，下面的例子表达了一个典型的网站导航样式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">nav &#123;<br>  ul &#123;<br>    margin: <span class="hljs-number">0</span>;<br>    padding: <span class="hljs-number">0</span>;<br>    list-style: none;<br>  &#125;<br><br>  li &#123; display: <span class="hljs-keyword">inline</span>-block; &#125;<br><br>  a &#123;<br>    display: block;<br>    padding: <span class="hljs-number">6</span>px <span class="hljs-number">12</span>px;<br>    text-decoration: none;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家注意上面代码中的ul、li、a选择器都被嵌套在nav选择器当中使用，这是一种书写更高可读性CSS的良好方式，编译后产生的CSS代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">list-style</span>: none; &#125;<br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block; &#125;<br><span class="hljs-selector-tag">nav</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">6px</span> <span class="hljs-number">12px</span>;<br>  <span class="hljs-attribute">text-decoration</span>: none; &#125;<br></code></pre></td></tr></table></figure><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>SASS的@import则会直接将这些引入的片段合并至当前CSS文件，并且不会产生新的HTTP请求。下面例子中的代码，将会在base.scss文件当中引入_reset.scss片断。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// _reset.scss</span><br>html, body, ul, ol &#123;<br>  margin:  <span class="hljs-number">0</span>;<br>  padding: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// base.scss</span><br>@import <span class="hljs-string">&#x27;reset&#x27;</span>;<br>body &#123;<br>  font: <span class="hljs-number">100</span>% Helvetica, sans-serif;<br>  background-color: <span class="hljs-meta">#efefef;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>SASS中引入片断时，可以缺省使用文件扩展名，因此上面代码中直接通过@import ‘reset’引入，编译后生成的代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span>, <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">ol</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font</span>: <span class="hljs-number">100%</span> Helvetica, sans-serif;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#efefef</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>混合（Mixin）用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@mixin</span> border-radius(<span class="hljs-variable">$radius</span>) &#123;<br>          border-<span class="hljs-symbol">radius:</span> <span class="hljs-variable">$radius</span>;<br>      -ms-border-<span class="hljs-symbol">radius:</span> <span class="hljs-variable">$radius</span>;<br>     -moz-border-<span class="hljs-symbol">radius:</span> <span class="hljs-variable">$radius</span>;<br>  -webkit-border-<span class="hljs-symbol">radius:</span> <span class="hljs-variable">$radius</span>;<br>&#125;<br><br>.box &#123;<br>  <span class="hljs-variable">@include</span> border-radius(10px);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码建立了一个名为border-radius的Mixin，并传递了一个变量$radius作为参数，然后在后续代码中通过@include border-radius(10px)使用该Mixin，最终编译的结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  -ms-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>  -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是SASS中非常重要的一个特性，可以通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码，下面例子将会通过SASS提供的继承机制建立一系列样式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 这段代码不会被输出到最终生成的CSS文件，因为它没有被任何代码所继承。</span><br>%other-styles &#123;<br>  display: flex;<br>  flex-wrap: wrap;<br>&#125;<br><br><span class="hljs-comment">// 下面代码会正常输出到生成的CSS文件，因为它被其接下来的代码所继承。</span><br>%message-common &#123;<br>  border: <span class="hljs-number">1</span>px solid #ccc;<br>  padding: <span class="hljs-number">10</span>px;<br>  color: #<span class="hljs-number">333</span>;<br>&#125;<br><br>.message &#123;<br>  <span class="hljs-meta">@extend</span> %message-common;<br>&#125;<br><br>.success &#123;<br>  <span class="hljs-meta">@extend</span> %message-common;<br>  border-color: green;<br>&#125;<br><br>.error &#123;<br>  <span class="hljs-meta">@extend</span> %message-common;<br>  border-color: red;<br>&#125;<br><br>.warning &#123;<br>  <span class="hljs-meta">@extend</span> %message-common;<br>  border-color: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码将.message中的CSS属性应用到了.success、.error、.warning上面，魔法将会发生在最终生成的CSS当中。这种方式能够避免在HTML元素上书写多个class选择器，最终生成的CSS样式是下面这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.message</span>, <span class="hljs-selector-class">.success</span>, <span class="hljs-selector-class">.error</span>, <span class="hljs-selector-class">.warning</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>; &#125;<br><br><span class="hljs-selector-class">.success</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: green; &#125;<br><br><span class="hljs-selector-class">.error</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: red; &#125;<br><br><span class="hljs-selector-class">.warning</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: yellow; &#125;<br></code></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>SASS提供了标准的算术运算符，例如+、-、*、/、%。在接下来的例子里，我们尝试在aside和article选择器当中对宽度进行简单的计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; &#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;main&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span> / <span class="hljs-number">960px</span> * <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">aside</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;complementary&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span> / <span class="hljs-number">960px</span> * <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码以960px为基准建立了简单的流式网格布局，SASS提供的算术运算符让开发人员可以更容易的将像素值转换为百分比，最终生成的CSS样式如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; &#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;main&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">62.5%</span>; &#125;<br><br><span class="hljs-selector-tag">aside</span><span class="hljs-selector-attr">[role=<span class="hljs-string">&quot;complementary&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">31.25%</span>; &#125;<br></code></pre></td></tr></table></figure><h2 id="CSS扩展"><a href="#CSS扩展" class="headerlink" title="CSS扩展"></a>CSS扩展</h2><hr><h3 id="引用父级选择器”-amp-”"><a href="#引用父级选择器”-amp-”" class="headerlink" title="引用父级选择器”&amp;”"></a>引用父级选择器”&amp;”</h3><p>Scss使用”&amp;”关键字在CSS规则中引用父级选择器，例如在嵌套使用伪类选择器的场景下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/*===== SCSS =====*/</span><br>a &#123;<br>  font<span class="hljs-operator">-</span>weight: bold;<br>  text<span class="hljs-operator">-</span>decoration: none;<br>  <span class="hljs-operator">&amp;</span>:hover &#123; text<span class="hljs-operator">-</span>decoration: underline; &#125;<br>  body.firefox <span class="hljs-operator">&amp;</span> &#123; font<span class="hljs-operator">-</span>weight: normal; &#125;<br>&#125;<br><br><span class="hljs-comment">/*===== CSS =====*/</span><br>a &#123;<br>  font<span class="hljs-operator">-</span>weight: bold;<br>  text<span class="hljs-operator">-</span>decoration: none; &#125;<br>  a:hover &#123;<br>    text<span class="hljs-operator">-</span>decoration: underline; &#125;<br>  body.firefox a &#123;<br>    font<span class="hljs-operator">-</span>weight: normal; &#125;<br></code></pre></td></tr></table></figure><p>无论CSS规则嵌套的深度怎样，关键字”&amp;”都会使用父级选择器级联替换全部其出现的位置：</p><p>作者：白雪公主960<br>链接：<a href="https://www.jianshu.com/p/a99764ff3c41">https://www.jianshu.com/p/a99764ff3c41</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大转盘抽奖</title>
    <link href="/2021/04/10/vue%E8%BD%AC%E7%9B%98%E6%8A%BD%E5%A5%96/"/>
    <url>/2021/04/10/vue%E8%BD%AC%E7%9B%98%E6%8A%BD%E5%A5%96/</url>
    
    <content type="html"><![CDATA[<h2 id="先放上效果图"><a href="#先放上效果图" class="headerlink" title="先放上效果图"></a>先放上效果图</h2><h3 id="体验地址-手机体验-http-lz-lxandzjy-top"><a href="#体验地址-手机体验-http-lz-lxandzjy-top" class="headerlink" title="体验地址(手机体验)  http://lz.lxandzjy.top/"></a>体验地址(手机体验)  <a href="http://lz.lxandzjy.top/">http://lz.lxandzjy.top/</a></h3><p><img src="http://lxandzjy.top:9003/2021/11/18/aa51a5c8da570.png"></p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><ul><li><p><strong>将指针和中奖区 划分为两部分,，控制中奖区域旋转，然后停在指针处，当然控制指针也可以，(比较懒)中间区域其实就是一张图片</strong></p></li><li><p><strong>每个移动位置应均分，360/个数  === 每个奖品所占据的位置，以本文为例8个奖品位置，每个区域应为45deg，每个指针中心位置应为±22.5deg（±的意思看你是顺时针还是逆时针)</strong></p></li><li><p>代码挺简单的,直接粘贴代码了</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;container&quot;&gt;<br>    &lt;div class=&quot;main&quot; :style=&quot;rotateStyle&quot;&gt; &lt;/div&gt;<br>    &lt;div class=&quot;txt1&quot;  &gt; &lt;span class=&quot;txt2&quot; @click=&quot;run&quot;&gt;干饭&lt;/span&gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  data () &#123;<br>    return &#123;<br>      isrun: false,<br>      rotateAngle: 0, // 旋转角度<br>      config: &#123;<br>        duration: 4000, // 总旋转时间 ms级<br>        circle: 8, // 旋转圈数<br>        mode: &#x27;ease-in-out&#x27; // 由快到慢 惯性效果都省了<br>      &#125;,<br>      cricleAdd: 1, // 第几次抽奖<br>      drawIndex: 0 // 中奖索引 转盘图片排序 指针右手开始 0-...<br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    rotateStyle () &#123;<br>      const _c = this.config<br>      return `<br>        -webkit-transition: transform $&#123;_c.duration&#125;ms $&#123;_c.mode&#125;;<br>        transition: transform $&#123;_c.duration&#125;ms $&#123;_c.mode&#125;;<br>        -webkit-transform: rotate($&#123;this.rotateAngle&#125;deg);<br>            transform: rotate($&#123;this.rotateAngle&#125;deg);`<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    async run () &#123;<br>      if (this.isrun) return<br>      const a = Math.floor(Math.random() * 9 )<br>      this.isrun = true<br>      this.rotateAngle = this.config.circle * 360 * this.cricleAdd - (22.5 + a * 45)<br>      // 圈数位置解析<br>      // this.config.circle * 360 * this.cricleAdd 顺时针总圈数/累积总圈数<br>      // 22.5 + this.drawIndex * 45 ===&gt; (奖品位置 === this.drawIndex * 45) (指针中间位置 === 22.5)<br>      this.cricleAdd++<br>      setTimeout(() =&gt; &#123;<br>        // this.$emit(&#x27;draw_fin&#x27;, &#x27;fin&#x27;)<br>        this.isrun = false<br>      &#125;, this.config.duration)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br>&lt;style scoped &gt;<br>.container&#123;<br>  width: 100%;<br>  height: 100%;<br>  position: absolute;<br>  top: 0;<br>  left: 0;<br>  background: url(&#x27;../assets/beijing.png&#x27;) no-repeat;<br>  background-size: contain;<br>  background-color: #c2c7ff;<br>&#125;<br>.main&#123;<br>  width: 280px;<br>  height: 280px;<br>  background: url(&#x27;../assets/pan.png&#x27;) no-repeat;<br>  background-size: contain;<br>  position: absolute;<br>  top: 50%;<br>  left: 50%;<br>  margin: -140px 0 0 -140px;<br>  /* display: flex;<br>  justify-content: center;<br>  align-items: center; */<br>&#125;<br>.txt1&#123;<br>  width: 80px;<br>  height: 80px;<br>  background: url(&#x27;../assets/point.png&#x27;) no-repeat;<br>  background-size: contain;<br>  position: absolute;<br>  top: 50%;<br>  left: 50%;<br>  margin: -40px 0 0 -40px;<br>&#125;<br>.txt2&#123;<br>  line-height: 80px;<br>  display: block;<br>  margin: 0 auto;<br>  text-align: center;<br>&#125;<br>&lt;/style&gt;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock.js的简单使用</title>
    <link href="/2021/04/01/Mockjs%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/04/01/Mockjs%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a>Mock.js</h1><h2 id="在开发的过程中有很多需要发送请求-获取数据-可以通过Mock-js拦截ajax请求-简单的方便的构建你所需要的数据"><a href="#在开发的过程中有很多需要发送请求-获取数据-可以通过Mock-js拦截ajax请求-简单的方便的构建你所需要的数据" class="headerlink" title="在开发的过程中有很多需要发送请求,获取数据,可以通过Mock.js拦截ajax请求,简单的方便的构建你所需要的数据"></a>在开发的过程中有很多需要发送请求,获取数据,可以通过Mock.js拦截ajax请求,简单的方便的构建你所需要的数据</h2><ul><li>安装mock.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install mockjs --save-dev<br></code></pre></td></tr></table></figure><ul><li><p>具体 data 有什么,参阅官方文档   <a href="http://mockjs.com/examples.html">http://mockjs.com/examples.html</a></p></li><li><p>在项目中创建mock.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入mockjs</span><br><span class="hljs-keyword">import</span> Mock <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mockjs&#x27;</span><br><span class="hljs-comment">//使用mockjs模拟数据</span><br>Mock.mock(<span class="hljs-string">&#x27;/\/api\/msdk\/proxy\/query_common_credit/&#x27;</span>, &#123;<br>    <span class="hljs-string">&quot;ret&quot;</span>:<span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>:<br>      &#123;<br>        <span class="hljs-string">&quot;mtime&quot;</span>: <span class="hljs-string">&quot;@datetime&quot;</span>,<span class="hljs-comment">//随机生成日期时间</span><br>        <span class="hljs-string">&quot;score|1-800&quot;</span>: <span class="hljs-number">800</span>,<span class="hljs-comment">//随机生成1-800的数字</span><br>        <span class="hljs-string">&quot;rank|1-100&quot;</span>:  <span class="hljs-number">100</span>,<span class="hljs-comment">//随机生成1-100的数字</span><br>        <span class="hljs-string">&quot;stars|1-5&quot;</span>: <span class="hljs-number">5</span>,<span class="hljs-comment">//随机生成1-5的数字</span><br>        <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;@cname&quot;</span>,<span class="hljs-comment">//随机生成中文名字</span><br>      &#125;<br><span class="hljs-comment">//data里的属性看不懂，需要详细看语法规范,博客链接:https://www.jianshu.com/p/4579f40e6108</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>在main.js中引入 该文档</p></li><li><p>xxx.vue文件中调用mock.js中模拟的数据接口，这时返回的response就是mock.js中用Mock.mock(‘url’,data）中设置的data了。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">query_common_credit()&#123;<br>      <span class="hljs-keyword">var</span> loginMode = <span class="hljs-string">&#x27;msdk&#x27;</span>;<span class="hljs-comment">//游戏内默认msdk(wx|qq|msdk)</span><br>      <span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;/api/msdk/proxy/query_common_credit&#x27;</span>;<br>      this.<span class="hljs-symbol">$a</span>xios.get(url)<br>        .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <br>        &#125;)<br>        .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>          <br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>axios</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Websocket</title>
    <link href="/2021/02/20/websocket/"/>
    <url>/2021/02/20/websocket/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要websocket"><a href="#为什么需要websocket" class="headerlink" title="为什么需要websocket"></a>为什么需要websocket</h2><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p><p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息</p><p>特点包括：</p><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;wss://echo.websocket.org&quot;</span>);<br><br>ws.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Connection open ...&quot;</span>); <br>  ws.send(<span class="hljs-string">&quot;Hello WebSockets!&quot;</span>);<br>&#125;;<br><br>ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&quot;Received Message: &quot;</span> + evt.data);<br>  ws.close();<br>&#125;;<br><br>ws.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Connection closed.&quot;</span>);<br>&#125;;  <br></code></pre></td></tr></table></figure><h3 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p><blockquote><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul></blockquote><h3 id="ebSocket-onopen"><a href="#ebSocket-onopen" class="headerlink" title="ebSocket.onopen"></a>ebSocket.onopen</h3><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ws.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  ws.send(<span class="hljs-string">&#x27;Hello Server!&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ws.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> code = event.code;<br>  <span class="hljs-keyword">var</span> reason = event.reason;<br>  <span class="hljs-keyword">var</span> wasClean = event.wasClean;<br>  <span class="hljs-comment">// handle close event</span><br>&#125;;<br><br>ws.addEventListener(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> code = event.code;<br>  <span class="hljs-keyword">var</span> reason = event.reason;<br>  <span class="hljs-keyword">var</span> wasClean = event.wasClean;<br>  <span class="hljs-comment">// handle close event</span><br>&#125;);<br></code></pre></td></tr></table></figure></blockquote><h3 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h3><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> data = event.data;<br>  <span class="hljs-comment">// 处理数据</span><br>&#125;;<br><br>ws.addEventListener(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> data = event.data;<br>  <span class="hljs-comment">// 处理数据</span><br>&#125;);<br></code></pre></td></tr></table></figure></blockquote><h3 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send()"></a>webSocket.send()</h3><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p><p>发送文本的例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ws.send(<span class="hljs-string">&#x27;your message&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote><p>转载自阮一峰的网络日志<a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">https://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DOM property 和 attribute 的区别</title>
    <link href="/2020/11/12/DOM%E4%B8%ADproperty%E5%92%8Cattribute/"/>
    <url>/2020/11/12/DOM%E4%B8%ADproperty%E5%92%8Cattribute/</url>
    
    <content type="html"><![CDATA[<h3 id="DOM-property-和-attribute-的区别详解"><a href="#DOM-property-和-attribute-的区别详解" class="headerlink" title="DOM property 和 attribute 的区别详解"></a>DOM property 和 attribute 的区别详解</h3><h1 id="明确概念"><a href="#明确概念" class="headerlink" title="明确概念"></a>明确概念</h1><p>首先因为两个单词在中文中都翻译成<strong>属性</strong>，所以会造成较多混淆。在此也先明确一下其它一些基础概念。 身为前端人员我们经常会用<code>标签</code>，<code>元素</code>，<code>DOM</code>来形容<code>HTML</code> 内容，对此其实有明确划分的。如下<code>HTML code</code>（能明确区分的可以跳过）</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p>标签指的是 <code>div</code>，也有其他标签如：<code>a</code>，<code>p</code>，<code>input</code>等等。 多数标签分为<code>&lt;div&gt;</code> 开始标签(opening tag)，以及<code>&lt;/div&gt;</code>结束标签(closing tag)。 当然有的也不区分如: <code>&lt;input&gt;</code>，<code>&lt;hr&gt;</code>，<code>&lt;br&gt;</code>等。 标签上有附加信息我们称之为 <code>HTML 属性</code>，如 <code>id</code>，<code>class</code> 以上合起来，我们统称为<code>HTML 元素</code>，而一个<code>HTML文档</code>就是多个<code>HTML元素</code>构成的。</p><p>而<code>HTML DOM</code>是 HTML 的标准对象模型，<code>DOM(Document Object Model)</code>，直译就是<strong>文档对象模型</strong> <code>HTML DOM</code> 定义了所有 HTML 元素的<strong>对象</strong>和<strong>属性</strong>，以及访问它们的<strong>方法</strong>。 而DOM对象上的<strong>属性</strong>我们称之为<code>property</code>。</p><h1 id="讨论原因"><a href="#讨论原因" class="headerlink" title="讨论原因"></a>讨论原因</h1><p>引发<a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html%23answer-6004028"><strong>此次</strong></a>讨论的主要原因就是因为<code>jQuery v1.6.1</code>的发布，此版本之前直接用<code>attr()</code>方法处理了<code>property</code>和<code>attribute</code>，为了消除<code>property</code>和<code>attribute</code>的歧义，以及一些<code>attr()</code>的bug和维护困难的问题，于是新添加了<code>prop()</code>方法，<code>jQuery v1.6.1</code>发布日志可以在<a href="https://link.juejin.cn/?target=http://blog.jquery.com/2011/05/12/jquery-1-6-1-released/"><strong>这里</strong></a>看。</p><h1 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h1><p>编写HTML源代码时，可以在HTML元素上定义属性(attribute) 。 然后，一旦浏览器解析了您的代码，就会创建一个对应的DOM节点。 该节点是一个对象，因此具有属性 (property)。 例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p><code>input</code>元素有两个属性(attribute)，<code>type</code>和<code>value</code>。 浏览器解析这段代码后，将创建一个<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLInputElement"><strong>HTMLInputElement</strong></a>对象，该对象将包含许多属性。 例如：<code>accept</code>，<code>accessKey</code>，<code>align</code>，<code>alt</code>，<code>attributes</code>，<code>autofocus</code>，<code>baseURI</code>，<code>checked</code>，<code>childElementCount</code>，<code>childNodes</code>，<code>childNodes</code>，<code>classList</code>，<code>className</code>，<code>clientHeight</code>等</p><p>解析创建后的这个<strong>DOM节点对象</strong>，<code>property</code>是这个对象的属性，而<code>attribute</code>是这个对象的<code>attributes</code>这个对象的属性 （简单讲就是这样 <code>domObj.attibutes.attribute</code> ）。</p><p>因为是根据HTML 元素创建的<strong>DOM节点对象</strong>，所以会有许多属性(property)都与<strong>具有相同或相似名称</strong>的属性(attribute)相关，但这不并是一对一的关系。 比如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;inputId&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>复制代码<br></code></pre></td></tr></table></figure><p>此元素创建的<strong>DOM节点对象</strong>有，<code>id</code>，<code>type</code>，<code>value</code> 等属性(property) DOM节点对象上的<code>id</code> 属性(property)是映射的<code>id</code>属性(attribute)。获取<code>id</code>的<code>property</code>就是获取<code>attribute</code>值，设置也是一样。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> inputDom = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;#inputId&#x27;</span>)<br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.id)<br><span class="hljs-comment">// &quot;inputId&quot;</span><br><span class="hljs-comment">// &quot;inputId&quot;</span><br><br>inputDom<span class="hljs-selector-class">.setAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;inputId2&#x27;</span>)<br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.id)<br><span class="hljs-comment">// &quot;inputId2&quot;</span><br><span class="hljs-comment">// &quot;inputId2&quot;</span><br><br>inputDom<span class="hljs-selector-class">.id</span> = <span class="hljs-string">&#x27;inputId&#x27;</span><br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.id)<br><span class="hljs-comment">// &quot;inputId&quot;</span><br><span class="hljs-comment">// &quot;inputId&quot;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>DOM节点对象上的<code>type</code>属性(property)是映射 <code>type</code>的属性(attribute)，获取<code>property</code>读取的是<code>attribute</code>值，并且设置<code>property</code>写入的是<code>attribute</code>值。<code>type</code>不是纯粹的映射属性，因为它的值只能为 <strong>已知值</strong> （例如:<code>text</code>，<code>submit</code>，<code>button</code>，<code>checkbox</code>等等）。以下可以看到，设置<code>type</code>为<strong>未知值</strong> 时 <code>property</code>始终为text。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> inputDom = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;#inputId&#x27;</span>)<br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.type)<br><span class="hljs-comment">// text</span><br><span class="hljs-comment">// text</span><br><br>inputDom<span class="hljs-selector-class">.setAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>,<span class="hljs-string">&#x27;007&#x27;</span>)<br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.type)<br><span class="hljs-comment">// 007</span><br><span class="hljs-comment">// text</span><br><br>inputDom<span class="hljs-selector-class">.type</span> = <span class="hljs-string">&#x27;008&#x27;</span><br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.type)<br><span class="hljs-comment">// 008</span><br><span class="hljs-comment">// text</span><br>复制代码<br></code></pre></td></tr></table></figure><p><code>value</code>属性(property)不是完全映射<code>value</code>属性(attribute)。 初始状态<code>value</code>属性(property)映射的<code>value</code>属性(attribute)， 当用户手动更改输入框的内容时 ， <code>value</code>属性(property)将更改为用户输入的信息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;<span class="hljs-selector-tag">input</span> id=<span class="hljs-string">&quot;inputId&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span> value=<span class="hljs-string">&quot;name&quot;</span>&gt;<br>复制代码<br><span class="hljs-selector-tag">var</span> inputDom = document<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;#inputId&#x27;</span>)<br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.value)<br><span class="hljs-comment">// name</span><br><span class="hljs-comment">// name</span><br><br>inputDom<span class="hljs-selector-class">.setAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>,<span class="hljs-string">&#x27;007&#x27;</span>)<br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.value)<br><span class="hljs-comment">// 007</span><br><span class="hljs-comment">// 007</span><br><br>inputDom<span class="hljs-selector-class">.value</span> = <span class="hljs-string">&#x27;008&#x27;</span><br>console<span class="hljs-selector-class">.log</span>(inputDom<span class="hljs-selector-class">.getAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<br>console<span class="hljs-selector-class">.log</span>(inputDom.value)<br><span class="hljs-comment">// 007</span><br><span class="hljs-comment">// 008</span><br>复制代码<br></code></pre></td></tr></table></figure><p>由以上可以得知，<code>input</code>的<code>value</code>属性(property)在用户未输入数据，或设置<code>property</code>的值时，取的值是<code>attribute</code>的值。当用户输入值或者设置了<code>property</code>的值后，<code>property</code>的值就不受<code>attribute</code>影响了，<code>property</code>的值就是页面输入框内展示的内容（如下图）</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713f34e72850b41~tplv-t2oaga2asx-watermark.awebp" alt="在这里插入图片描述"></p><p><code>attribute</code>的值是HTML源代码属性（如下图）</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/3/1713f34e7479f135~tplv-t2oaga2asx-watermark.awebp" alt="attribute 的值"></p><p>从这个例子中就能很明显看出来<code>property</code>和<code>attribute</code>的区别了，当然还有很多属性<code>property</code>与<code>attribute</code>之间的映射关系并不相同，比如<code>class attribute</code> 和 <code>className property</code>、<code>classList property</code> 之间的关系等等。</p><p>这里有篇 <a href="https://link.juejin.cn/?target=https://angular.cn/guide/template-syntax%23html-attribute-vs-dom-property"><strong>Angular 的文档</strong></a>，其中也描述了html属性和DOM属性的一些内容，有兴趣的小伙伴们可以进去看看。 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API%23%E6%8E%A5%E5%8F%A3">Web API 接口参考</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后总的来讲就是  <strong>HTML属性</strong> (attribute)和 <strong>DOM属性</strong>(property)，是相互关联的。多数情况<code>attribute</code>值仅用作初始DOM节点对象使用，而<code>property</code>更多用于页面交互，很多框架都是在与元素和指令的 <code>property</code>和事件打交道。</p><p>以上描述如有错误欢迎指正，谢谢</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>以上所引用文档都尽量更换为中文文档，原英文文档参考下方。</p><p><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement">HTMLInputElement</a> <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API%23Interfaces">Web APIs</a> <a href="https://link.juejin.cn/?target=https://angular.io/guide/template-syntax%23html-attribute-vs-dom-property">HTML attribute vs. DOM property</a> <a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html%23answer-6004028">Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html#answer-6004028">https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html#answer-6004028</a></p><p>————————————————<br>版权声明：本文为CSDN博主「rudy_zhou」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/rudy_zhou/article/details/104058741">https://blog.csdn.net/rudy_zhou/article/details/104058741</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue学习笔记之v-bind</title>
    <link href="/2020/11/10/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bv-bind/"/>
    <url>/2020/11/10/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bv-bind/</url>
    
    <content type="html"><![CDATA[<h2 id="vue官方文档-https-cn-vuejs-org"><a href="#vue官方文档-https-cn-vuejs-org" class="headerlink" title="vue官方文档  https://cn.vuejs.org/"></a>vue官方文档  <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></h2><p><code>v-bind</code><strong>用于绑定数据和元素属性</strong><br>例如：绑定<code>a</code>标签的<code>href</code>属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>&lt;/div&gt;  <br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>    el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    data:&#123;<br>        url:<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>,<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上代码中，使用<code>v-bind</code>绑定了<code>a</code>标签的<code>href</code>属性，当<code>a</code>标签被点击时，会根据对应<code>vue</code>中的对应的<code>url</code>数据进行跳转到<code>https://www.baidu.com</code><br> 不光是<code>href</code>属性可以被<code>v-bind</code>指令绑定，任何属性都可以被绑定<br> 例如，绑定<code>src</code>属性、<code>class</code>属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;klass&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgsrc&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  <br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>    el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    data:&#123;<br>        url:<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>,<br>        imgsrc:<span class="hljs-string">&quot;https://cn.vuejs.org/images/logo.png&quot;</span>,<br>        kclass:<span class="hljs-string">&quot;btn btn-default&quot;</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="再看文档时-作为一个-DOM-property-绑定而不是作为-attribute-绑定。-差别在哪里？-我去百度一波"><a href="#再看文档时-作为一个-DOM-property-绑定而不是作为-attribute-绑定。-差别在哪里？-我去百度一波" class="headerlink" title="再看文档时    作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？)    (我去百度一波)"></a>再看文档时    作为一个 DOM property 绑定而不是作为 attribute 绑定。(<a href="https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028">差别在哪里？</a>)    (我去百度一波)</h5><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a><a href="https://cn.vuejs.org/v2/api/#v-bind">v-bind</a></h3><ul><li><p><strong>缩写</strong>：<code>:</code></p></li><li><p><strong>预期</strong>：<code>any (with argument) | Object (without argument)</code></p></li><li><p><strong>参数</strong>：<code>attrOrProp (optional)</code></p></li><li><p><strong>修饰符</strong>：</p><ul><li><code>.prop</code> - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(<a href="https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028">差别在哪里？</a>)</li><li><code>.camel</code> - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)</li><li><code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器。</li></ul></li><li><p><strong>用法</strong>：</p><p>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p><p>在绑定 <code>class</code> 或 <code>style</code> attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p><p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p><p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 绑定一个 attribute --&gt;<br>&lt;img v-bind:src=&quot;imageSrc&quot;&gt;<br><br>&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;<br>&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 缩写 --&gt;<br>&lt;img :src=&quot;imageSrc&quot;&gt;<br><br>&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;<br>&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 内联字符串拼接 --&gt;<br>&lt;img :src=&quot;&#x27;/path/to/images/&#x27; + fileName&quot;&gt;<br><br>&lt;!-- class 绑定 --&gt;<br>&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;<br>&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;<br>&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;<br><br>&lt;!-- style 绑定 --&gt;<br>&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;<br>&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;<br><br>&lt;!-- 绑定一个全是 attribute 的对象 --&gt;<br>&lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;<br><br>&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;<br>&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;<br><br>&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;<br>&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;<br><br>&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;<br>&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;<br><br>&lt;!-- XLink --&gt;<br>&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;<br></code></pre></td></tr></table></figure><p><code>.camel</code> 修饰符允许在使用 DOM 模板时将 <code>v-bind</code> property 名称驼峰化，例如 SVG 的 <code>viewBox</code> property：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;svg :view-box.camel=&quot;viewBox&quot;&gt;&lt;/svg&gt;<br></code></pre></td></tr></table></figure><p>在使用字符串模板或通过 <code>vue-loader</code>/<code>vueify</code> 编译时，无需使用 <code>.camel</code>。</p></li><li><p><strong>参考</strong>：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/class-and-style.html">Class 与 Style 绑定</a></li><li><a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE">组件 - Props</a></li><li><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6">组件 - <code>.sync</code> 修饰符</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的学习笔记---vue的生命周期</title>
    <link href="/2020/10/28/learn-vue01/"/>
    <url>/2020/10/28/learn-vue01/</url>
    
    <content type="html"><![CDATA[<h2 id="vue学习小记—vue的生命周期"><a href="#vue学习小记—vue的生命周期" class="headerlink" title="vue学习小记—vue的生命周期"></a>vue学习小记—vue的生命周期</h2><p>建议学习 vue ,直接阅读官方文档就好,真的很强.</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue生命周期"></p><p><strong>beforeCreate( 创建前 )</strong></p><p>el 和data都没有初始化,无妨访问methods,data,computed上的方法和数据</p><p><strong>created ( 创建后 ）</strong></p><p>实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成</p><p><strong>beforeMount</strong></p><p>挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p><p><strong>mounted</strong></p><p>挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</p><p><strong>beforeUpdate</strong></p><p>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</p><p><strong>updated（更新后）</strong></p><p>在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p><p><strong>beforeDestroy（销毁前）</strong></p><p>在实例销毁之前调用，实例仍然完全可用，</p><ol><li>这一步还可以用this来获取实例，</li><li>一般在这一步做一些重置的操作，比如清除掉组件中的定时器     和 监听的dom事件</li></ol><p><strong>destroyed（销毁后）</strong></p><p>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的学习笔记之 v-on</title>
    <link href="/2020/10/28/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bv-on/"/>
    <url>/2020/10/28/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bv-on/</url>
    
    <content type="html"><![CDATA[<p><code>v-on</code>就是<strong>用于绑定事件的</strong><br>例如：有个按钮，当点击的时候执行一些操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;app&quot;&gt;<br>    &lt;button v-on:click=&quot;myclick&quot;&gt;click me&lt;/button&gt;<br>&lt;/div&gt;  <br></code></pre></td></tr></table></figure><p><code>v-on:</code>后面的值是一个方法，可以写成<code>myclick()</code>，没有参数可以写成<code>myclick</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;.app&#x27;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br>        <br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-attr">myclick</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111111</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>v-on</code>也可以绑定多个事件<br>多个事件可以单独多个v-on绑定</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:mouseenter</span>=<span class="hljs-string">&#x27;onenter&#x27;</span> <span class="hljs-attr">v-on:mouseleave</span>=<span class="hljs-string">&#x27;leave&#x27;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;  <br></code></pre></td></tr></table></figure><h6 id="跟v-bind一样，v-on也非常常用，对应也有快捷方式："><a href="#跟v-bind一样，v-on也非常常用，对应也有快捷方式：" class="headerlink" title="跟v-bind一样，v-on也非常常用，对应也有快捷方式："></a><strong>跟<code>v-bind</code>一样，v-on也非常常用，对应也有快捷方式：</strong></h6><p><strong><code>**v-on:事件名** 可以简写为 **@事件名**</code></strong></p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><a href="https://cn.vuejs.org/v2/api/#v-on">v-on</a></h3><ul><li><p><strong>缩写</strong>：<code>@</code></p></li><li><p><strong>预期</strong>：<code>Function | Inline Statement | Object</code></p></li><li><p><strong>参数</strong>：<code>event</code></p></li><li><p><strong>修饰符</strong>：</p><ul><li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li><li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li><li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li><li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li><code>.&#123;keyCode | keyAlias&#125;</code> - 只当事件是从特定键触发时才触发回调。</li><li><code>.native</code> - 监听组件根元素的原生事件。</li><li><code>.once</code> - 只触发一次回调。</li><li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li><li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li><li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li><li><code>.passive</code> - (2.3.0) 以 <code>&#123; passive: true &#125;</code> 模式添加侦听器</li></ul></li><li><p><strong>用法</strong>：</p><p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p><p>用在普通元素上时，只能监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events"><strong>原生 DOM 事件</strong></a>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p><p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> property：<code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。</p><p>从 <code>2.4.0</code> 开始，<code>v-on</code> 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 方法处理器 --&gt;<br>&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 动态事件 (2.6.0+) --&gt;<br>&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 内联语句 --&gt;<br>&lt;button v-on:click=&quot;doThat(&#x27;hello&#x27;, $event)&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 缩写 --&gt;<br>&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 动态事件缩写 (2.6.0+) --&gt;<br>&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 停止冒泡 --&gt;<br>&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 阻止默认行为 --&gt;<br>&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 阻止默认行为，没有表达式 --&gt;<br>&lt;form @submit.prevent&gt;&lt;/form&gt;<br><br>&lt;!--  串联修饰符 --&gt;<br>&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 键修饰符，键别名 --&gt;<br>&lt;input @keyup.enter=&quot;onEnter&quot;&gt;<br><br>&lt;!-- 键修饰符，键代码 --&gt;<br>&lt;input @keyup.13=&quot;onEnter&quot;&gt;<br><br>&lt;!-- 点击回调只会触发一次 --&gt;<br>&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;<br><br>&lt;!-- 对象语法 (2.4.0+) --&gt;<br>&lt;button v-on=&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;<br><br>&lt;!-- 内联语句 --&gt;<br>&lt;my-component @my-event=&quot;handleThis(123, $event)&quot;&gt;&lt;/my-component&gt;<br><br>&lt;!-- 组件中的原生事件 --&gt;<br>&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
