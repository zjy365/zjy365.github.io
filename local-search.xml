<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>比特币白皮书---转载</title>
    <link href="/2021/07/29/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
    <url>/2021/07/29/%E6%AF%94%E7%89%B9%E5%B8%81%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="比特币白皮书：一种点对点的电子现金系统"><a href="#比特币白皮书：一种点对点的电子现金系统" class="headerlink" title="比特币白皮书：一种点对点的电子现金系统"></a>比特币白皮书：一种点对点的电子现金系统</h2><h1 id="原文作者：中本聪（Satoshi-Nakamoto）"><a href="#原文作者：中本聪（Satoshi-Nakamoto）" class="headerlink" title="原文作者：中本聪（Satoshi Nakamoto）"></a><strong>原文作者：<a href="http://8btc.com/article-25-1.html">中本聪</a>（Satoshi Nakamoto）</strong></h1><p><strong>作者邮箱：<a href="mailto:&#x53;&#97;&#116;&#x6f;&#115;&#104;&#105;&#110;&#x40;&#103;&#109;&#x78;&#46;&#x63;&#x6f;&#x6d;">&#x53;&#97;&#116;&#x6f;&#115;&#104;&#105;&#110;&#x40;&#103;&#109;&#x78;&#46;&#x63;&#x6f;&#x6d;</a></strong></p><p><strong>执行翻译：8btc.com 巴比特 *<em><a href="http://www.8btc.com/author/24">QQagent</a>*</em></strong></p><blockquote><p>[摘要]：本文提出了一种完全通过点对点技术实现的电子现金系统，它使得在线支付能够直接由一方发起并支付给另外一方，中间不需要通过任何的金融机构。虽然数字签名（Digital signatures）部分解决了这个问题，但是如果仍然需要第三方的支持才能防止双重支付（double-spending）的话，那么这种系统也就失去了存在的价值。我们(we)在此提出一种解决方案，使现金系统在点对点的环境下运行，并防止双重支付问题。该网络通过随机散列（hashing）对全部交易加上时间戳（timestamps），将它们合并入一个不断延伸的基于随机散列的工作量证明（proof-of-work）的链条作为交易记录，除非重新完成全部的工作量证明，形成的交易记录将不可更改。最长的链条不仅将作为被观察到的事件序列（sequence）的证明，而且被看做是来自CPU计算能力最大的池（pool）。只要大多数的CPU计算能力都没有打算合作起来对全网进行攻击，那么诚实的节点将会生成最长的、超过攻击者的链条。这个系统本身需要的基础设施非常少。信息尽最大努力在全网传播即可，节点(nodes)可以随时离开和重新加入网络，并将最长的工作量证明链条作为在该节点离线期间发生的交易的证明。</p></blockquote><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>互联网上的贸易，几乎都需要借助金融机构作为可资信赖的第三方来处理电子支付信息。虽然这类系统在绝大多数情况下都运作良好，但是这类系统仍然内生性地受制于“基于信用的模式”(trust based model)的弱点。我们无法实现完全不可逆的交易，因为金融机构总是不可避免地会出面协调争端。而金融中介的存在，也会增加交易的成本，并且限制了实际可行的最小交易规模，也限制了日常的小额支付交易。并且潜在的损失还在于，很多商品和服务本身是无法退货的，如果缺乏不可逆的支付手段，互联网的贸易就大大受限。因为有潜在的退款的可能，就需要交易双方拥有信任。而商家也必须提防自己的客户，因此会向客户索取完全不必要的个人信息。而实际的商业行为中，一定比例的欺诈性客户也被认为是不可避免的，相关损失视作销售费用处理。而在使用物理现金的情况下，这些销售费用和支付问题上的不确定性却是可以避免的，因为此时没有第三方信用中介的存在。 所以，我们非常需要这样一种电子支付系统，它基于密码学原理而不基于信用，使得任何达成一致的双方，能够直接进行支付，从而不需要第三方中介的参与。杜绝回滚(reverse)支付交易的可能，这就可以保护特定的卖家免于欺诈；而对于想要保护买家的人来说，在此环境下设立通常的第三方担保机制也可谓轻松加愉快。在这篇论文中，我们(we)将提出一种通过点对点分布式的时间戳服务器来生成依照时间前后排列并加以记录的电子交易证明，从而解决双重支付问题。只要诚实的节点所控制的计算能力的总和，大于有合作关系的(cooperating)攻击者的计算能力的总和，该系统就是安全的。</p><h2 id="2-交易-Transactions"><a href="#2-交易-Transactions" class="headerlink" title="2. 交易(Transactions)"></a>2. 交易(Transactions)</h2><p>我们定义，一枚电子货币（an electronic coin）是这样的一串数字签名：每一位所有者通过对前一次交易和下一位拥有者的公钥(Public key) 签署一个随机散列的数字签名，并将这个签名附加在这枚电子货币的末尾，电子货币就发送给了下一位所有者。而收款人通过对签名进行检验，就能够验证该链条的所有者。</p><h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/202007300759252566.jpg" alt="1"></h1><p>该过程的问题在于，收款人将难以检验，之前的某位所有者，是否对这枚电子货币进行了双重支付。通常的解决方案，就是引入信得过的第三方权威，或者类似于造币厂(mint)的机构，来对每一笔交易进行检验，以防止双重支付。在每一笔交易结束后，这枚电子货币就要被造币厂回收，而造币厂将发行一枚新的电子货币；而只有造币厂直接发行的电子货币，才算作有效，这样就能够防止双重支付。可是该解决方案的问题在于，整个货币系统的命运完全依赖于运作造币厂的公司，因为每一笔交易都要经过该造币厂的确认，而该造币厂就好比是一家银行。 我们需要收款人有某种方法，能够确保之前的所有者没有对更早发生的交易实施签名。从逻辑上看，为了达到目的，实际上我们需要关注的只是于本交易之前发生的交易，而不需要关注这笔交易发生之后是否会有双重支付的尝试。为了确保某一次交易是不存在的，那么唯一的方法就是获悉之前发生过的所有交易。在造币厂模型里面，造币厂获悉所有的交易，并且决定了交易完成的先后顺序。如果想要在电子系统中排除第三方中介机构，那么交易信息就应当被公开宣布（publicly announced）[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-1">1]</a> ，我们需要整个系统内的所有参与者，都有唯一公认的历史交易序列。收款人需要确保在交易期间绝大多数的节点都认同该交易是首次出现。</p><h2 id="3-时间戳服务器-Timestamp-server"><a href="#3-时间戳服务器-Timestamp-server" class="headerlink" title="3. 时间戳服务器(Timestamp server)"></a>3. 时间戳服务器(Timestamp server)</h2><p>本解决方案首先提出一个“时间戳服务器”。时间戳服务器通过对以区块(block)形式存在的一组数据实施随机散列而加上时间戳，并将该随机散列进行广播，就像在新闻或世界性新闻组网络（Usenet）的发帖一样[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-2">2]</a>[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-3">3]</a>[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-4">4]</a>[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-5">5]</a> 。显然，该时间戳能够证实特定数据必然于某特定时间是的确存在的，因为只有在该时刻存在了才能获取相应的随机散列值。每个时间戳应当将前一个时间戳纳入其随机散列值中，每一个随后的时间戳都对之前的一个时间戳进行增强(reinforcing)，这样就形成了一个链条（Chain）。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/21.png" alt="2"></p><h2 id="4-工作量证明（Proof-of-Work）"><a href="#4-工作量证明（Proof-of-Work）" class="headerlink" title="4. 工作量证明（Proof-of-Work）"></a>4. 工作量证明（Proof-of-Work）</h2><p>为了在点对点的基础上构建一组分散化的时间戳服务器，仅仅像报纸或世界性新闻网络组一样工作是不够的，我们还需要一个类似于亚当•柏克（Adam Back）提出的哈希现金（Hashcash）[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-6">6]</a> 。在进行随机散列运算时，工作量证明机制引入了对某一个特定值的扫描工作，比方说SHA-256下，随机散列值以一个或多个0开始。那么随着0的数目的上升, 找到这个解所需要的工作量将呈指数增长，而对结果进行检验则仅需要一次随机散列运算。</p><p>我们在区块中补增一个随机数(Nonce)，这个随机数要使得该给定区块的随机散列值出现了所需的那么多个0。我们通过反复尝试来找到这个随机数，直到找到为止，这样我们就构建了一个工作量证明机制。只要该CPU耗费的工作量能够满足该工作量证明机制，那么除非重新完成相当的工作量，该区块的信息就不可更改。由于之后的区块是链接在该区块之后的，所以想要更改该区块中的信息，就还需要重新完成之后所有区块的全部工作量。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/31.png" alt="3"></p><p>同时，该工作量证明机制还解决了在集体投票表决时，谁是大多数的问题。如果决定大多数的方式是基于IP地址的，一IP地址一票，那么如果有人拥有分配大量IP地址的权力，则该机制就被破坏了。而工作量证明机制的本质则是一CPU一票。“大多数”的决定表达为最长的链，因为最长的链包含了最大的工作量。如果大多数的CPU为诚实的节点控制，那么诚实的链条将以最快的速度延长，并超越其他的竞争链条。如果想要对业已出现的区块进行修改，攻击者必须重新完成该区块的工作量外加该区块之后所有区块的工作量，并最终赶上和超越诚实节点的工作量。我们将在后文证明，设想一个较慢的攻击者试图赶上随后的区块，那么其成功概率将呈指数化递减。 另一个问题是，硬件的运算速度在高速增长，而节点参与网络的程度则会有所起伏。为了解决这个问题，工作量证明的难度(the proof-of-work difficulty)将采用移动平均目标的方法来确定，即令难度指向令每小时生成区块的速度为某一个预定的平均数。如果区块生成的速度过快，那么难度就会提高。</p><h2 id="5-网络"><a href="#5-网络" class="headerlink" title="5. 网络"></a>5. 网络</h2><p>运行该网络的步骤如下：</p><ul><li>\1) 新的交易向全网进行广播；</li><li>\2) 每一个节点都将收到的交易信息纳入一个区块中；</li><li>\3) 每个节点都尝试在自己的区块中找到一个具有足够难度的工作量证明；</li><li>\4) 当一个节点找到了一个工作量证明，它就向全网进行广播；</li><li>\5) 当且仅当包含在该区块中的所有交易都是有效的且之前未存在过的，其他节点才认同该区块的有效性；</li><li>\6) 其他节点表示他们接受该区块，而表示接受的方法，则是在跟随该区块的末尾，制造新的区块以延长该链条，而将被接受区块的随机散列值视为先于新区快的随机散列值。</li></ul><p>节点始终都将最长的链条视为正确的链条，并持续工作和延长它。如果有两个节点同时广播不同版本的新区块，那么其他节点在接收到该区块的时间上将存在先后差别。当此情形，他们将在率先收到的区块基础上进行工作，但也会保留另外一个链条，以防后者变成最长的链条。该僵局（tie）的打破要等到下一个工作量证明被发现，而其中的一条链条被证实为是较长的一条，那么在另一条分支链条上工作的节点将转换阵营，开始在较长的链条上工作。 所谓“新的交易要广播”，实际上不需要抵达全部的节点。只要交易信息能够抵达足够多的节点，那么他们将很快被整合进一个区块中。而区块的广播对被丢弃的信息是具有容错能力的。如果一个节点没有收到某特定区块，那么该节点将会发现自己缺失了某个区块，也就可以提出自己下载该区块的请求。</p><h2 id="6-激励"><a href="#6-激励" class="headerlink" title="6. 激励"></a>6. 激励</h2><p>我们约定如此：每个区块的第一笔交易进行特殊化处理，该交易产生一枚由该区块创造者拥有的新的电子货币。这样就增加了节点支持该网络的激励，并在没有中央集权机构发行货币的情况下，提供了一种将电子货币分配到流通领域的一种方法。这种将一定数量新货币持续增添到货币系统中的方法，非常类似于耗费资源去挖掘金矿并将黄金注入到流通领域。此时，CPU的时间和电力消耗就是消耗的资源。 另外一个激励的来源则是交易费（transaction fees）。如果某笔交易的输出值小于输入值，那么差额就是交易费，该交易费将被增加到该区块的激励中。只要既定数量的电子货币已经进入流通，那么激励机制就可以逐渐转换为完全依靠交易费，那么本货币系统就能够免于通货膨胀。 激励系统也有助于鼓励节点保持诚实。如果有一个贪婪的攻击者能够调集比所有诚实节点加起来还要多的CPU计算力，那么他就面临一个选择：要么将其用于诚实工作产生新的电子货币，或者将其用于进行二次支付攻击。那么他就会发现，按照规则行事、诚实工作是更有利可图的。因为该等规则使得他能够拥有更多的电子货币，而不是破坏这个系统使得其自身财富的有效性受损。</p><h2 id="7-回收硬盘空间"><a href="#7-回收硬盘空间" class="headerlink" title="7. 回收硬盘空间"></a>7. 回收硬盘空间</h2><p>如果最近的交易已经被纳入了足够多的区块之中，那么就可以丢弃该交易之前的数据，以回收硬盘空间。为了同时确保不损害区块的随机散列值，交易信息被随机散列时，被构建成一种Merkle树（Merkle tree）[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-7">7]</a> 的形态，使得只有根(root)被纳入了区块的随机散列值。通过将该树（tree）的分支拔除（stubbing）的方法，老区块就能被压缩。而内部的随机散列值是不必保存的。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/41.png" alt="4"></p><p>不含交易信息的区块头（Block header）大小仅有80字节。如果我们设定区块生成的速率为每10分钟一个，那么每一年产生的数据位4.2MB。（80 bytes * 6 * 24 * 365 = 4.2MB）。2008年，PC系统通常的内存容量为2GB，按照摩尔定律的预言，即使将全部的区块头存储于内存之中都不是问题。</p><h2 id="8-简化的支付确认（Simplified-Payment-Verification）"><a href="#8-简化的支付确认（Simplified-Payment-Verification）" class="headerlink" title="8. 简化的支付确认（Simplified Payment Verification）"></a>8. 简化的支付确认（Simplified Payment Verification）</h2><p>在不运行完整网络节点的情况下，也能够对支付进行检验。一个用户需要保留最长的工作量证明链条的区块头的拷贝，它可以不断向网络发起询问，直到它确信自己拥有最长的链条，并能够通过merkle的分支通向它被加上时间戳并纳入区块的那次交易。节点想要自行检验该交易的有效性原本是不可能的，但通过追溯到链条的某个位置，它就能看到某个节点曾经接受过它，并且于其后追加的区块也进一步证明全网曾经接受了它。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/5.png" alt="5"></p><p>当此情形，只要诚实的节点控制了网络，检验机制就是可靠的。但是，当全网被一个计算力占优的攻击者攻击时，将变得较为脆弱。因为网络节点能够自行确认交易的有效性，只要攻击者能够持续地保持计算力优势，简化的机制会被攻击者焊接的（fabricated）交易欺骗。那么一个可行的策略就是，只要他们发现了一个无效的区块，就立刻发出警报，收到警报的用户将立刻开始下载被警告有问题的区块或交易的完整信息，以便对信息的不一致进行判定。对于日常会发生大量收付的商业机构，可能仍会希望运行他们自己的完整节点，以保持较大的独立完全性和检验的快速性。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/7.png" alt="7"></p><h2 id="9-价值的组合与分割（Combining-and-Splitting-Value）"><a href="#9-价值的组合与分割（Combining-and-Splitting-Value）" class="headerlink" title="9. 价值的组合与分割（Combining and Splitting Value）"></a>9. 价值的组合与分割（Combining and Splitting Value）</h2><p>虽然可以单个单个地对电子货币进行处理，但是对于每一枚电子货币单独发起一次交易将是一种笨拙的办法。为了使得价值易于组合与分割，交易被设计为可以纳入多个输入和输出。一般而言是某次价值较大的前次交易构成的单一输入，或者由某几个价值较小的前次交易共同构成的并行输入，但是输出最多只有两个：一个用于支付，另一个用于找零（如有）。 需要指出的是，当一笔交易依赖于之前的多笔交易时，这些交易又各自依赖于多笔交易，但这并不存在任何问题。因为这个工作机制并不需要展开检验之前发生的所有交易历史。</p><h2 id="10-隐私（Privacy）"><a href="#10-隐私（Privacy）" class="headerlink" title="10. 隐私（Privacy）"></a>10. 隐私（Privacy）</h2><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/6.png" alt="6"></p><p>传统的造币厂模型为交易的参与者提供了一定程度的隐私保护，因为试图向可信任的第三方索取交易信息是严格受限的。但是如果将交易信息向全网进行广播，就意味着这样的方法失效了。但是隐私依然可以得到保护：将公钥保持为匿名。公众得知的信息仅仅是有某个人将一定数量的货币发所给了另外一个人，但是难以将该交易同特定的人联系在一起，也就是说，公众难以确信，这些人究竟是谁。这同股票交易所发布的信息是类似的，股票交易发生的时间、交易量是记录在案且可供查询的，但是交易双方的身份信息却不予透露。 作为额外的预防措施，使用者可以让每次交易都生成一个新的地址，以确保这些交易不被追溯到一个共同的所有者。但是由于并行输入的存在，一定程度上的追溯还是不可避免的，因为并行输入表明这些货币都属于同一个所有者。此时的风险在于，如果某个人的某一个公钥被确认属于他，那么就可以追溯出此人的其它很多交易。</p><h2 id="11-计算"><a href="#11-计算" class="headerlink" title="11. 计算"></a>11. 计算</h2><p>设想如下场景：一个攻击者试图比诚实节点产生链条更快地制造替代性区块链。即便它达到了这一目的，但是整个系统也并非就此完全受制于攻击者的独断意志了，比方说凭空创造价值，或者掠夺本不属于攻击者的货币。这是因为节点将不会接受无效的交易，而诚实的节点永远不会接受一个包含了无效信息的区块。一个攻击者能做的，最多是更改他自己的交易信息，并试图拿回他刚刚付给别人的钱。 诚实链条和攻击者链条之间的竞赛，可以用二叉树随机漫步（Binomial Random Walk)来描述。成功事件定义为诚实链条延长了一个区块，使其领先性+1，而失败事件则是攻击者的链条被延长了一个区块，使得差距-1。 攻击者成功填补某一既定差距的可能性，可以近似地看做赌徒破产问题（Gambler’s Ruin problem）。假定一个赌徒拥有无限的透支信用，然后开始进行潜在次数为无穷的赌博，试图填补上自己的亏空。那么我们可以计算他填补上亏空的概率，也就是该攻击者赶上诚实链条，如下所示[<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#footnote-8">8]</a> ：</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/pq.png" alt="pq"></p><p>假定p&gt;q，那么攻击成功的概率就因为区块数的增长而呈现指数化下降。由于概率是攻击者的敌人，如果他不能幸运且快速地获得成功，那么他获得成功的机会随着时间的流逝就变得愈发渺茫。那么我们考虑一个收款人需要等待多长时间，才能足够确信付款人已经难以更改交易了。我们假设付款人是一个支付攻击者，希望让收款人在一段时间内相信他已经付过款了，然后立即将支付的款项重新支付给自己。虽然收款人届时会发现这一点，但为时已晚。 收款人生成了新的一对密钥组合，然后只预留一个较短的时间将公钥发送给付款人。这将可以防止以下情况：付款人预先准备好一个区块链然后持续地对此区块进行运算，直到运气让他的区块链超越了诚实链条，方才立即执行支付。当此情形，只要交易一旦发出，攻击者就开始秘密地准备一条包含了该交易替代版本的平行链条。 然后收款人将等待交易出现在首个区块中，然后在等到z个区块链接其后。此时，他仍然不能确切知道攻击者已经进展了多少个区块，但是假设诚实区块将耗费平均预期时间以产生一个区块，那么攻击者的潜在进展就是一个泊松分布，分布的期望值为：</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/image022.png" alt="image022"></p><p>当此情形，为了计算攻击者追赶上的概率，我们将攻击者取得进展区块数量的泊松分布的概率密度，乘以在该数量下攻击者依然能够追赶上的概率。</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/pq2.png" alt="pq2"></p><p>化为如下形式，避免对无限数列求和：</p><p><img src="https://cdn.8btc.cn/wp-content/uploads/2013/11/pq3.png" alt="pq3"></p><p>写为如下C语言代码：</p><p><code>#include double AttackerSuccessProbability(double q, int z) &#123; double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k &lt;= z; k++) &#123; double poisson = exp(-lambda); for (i = 1; i &lt;= k; i++) poisson *= lambda / i; sum -= poisson * (1 - pow(q / p, z - k)); &#125; return sum; &#125;</code> 对其进行运算，我们可以得到如下的概率结果，发现概率对z值呈指数下降。</p><p>当q=0.1时 z=0 P=1.0000000 z=1 P=0.2045873 z=2 P=0.0509779 z=3 P=0.0131722 z=4 P=0.0034552 z=5 P=0.0009137 z=6 P=0.0002428 z=7 P=0.0000647 z=8 P=0.0000173 z=9 P=0.0000046 z=10 P=0.0000012</p><p>当q=0.3时 z=0 P=1.0000000 z=5 P=0.1773523 z=10 P=0.0416605 z=15 P=0.0101008 z=20 P=0.0024804 z=25 P=0.0006132 z=30 P=0.0001522 z=35 P=0.0000379 z=40 P=0.0000095 z=45 P=0.0000024 z=50 P=0.0000006</p><p>求解令P&lt;0.1%的z值：</p><p>为使P&lt;0.001，则 q=0.10 z=5 q=0.15 z=8 q=0.20 z=11 q=0.25 z=15 q=0.30 z=24 q=0.35 z=41 q=0.40 z=89 q=0.45 z=340</p><h2 id="12-结论"><a href="#12-结论" class="headerlink" title="12.结论"></a>12.结论</h2><p>我们在此提出了一种不需要信用中介的电子支付系统。我们首先讨论了通常的电子货币的电子签名原理，虽然这种系统为所有权提供了强有力的控制，但是不足以防止双重支付。为了解决这个问题，我们提出了一种采用工作量证明机制的点对点网络来记录交易的公开信息，只要诚实的节点能够控制绝大多数的CPU计算能力，就能使得攻击者事实上难以改变交易记录。该网络的强健之处在于它结构上的简洁性。节点之间的工作大部分是彼此独立的，只需要很少的协同。每个节点都不需要明确自己的身份，由于交易信息的流动路径并无任何要求，所以只需要尽其最大努力传播即可。节点可以随时离开网络，而想重新加入网络也非常容易，因为只需要补充接收离开期间的工作量证明链条即可。节点通过自己的CPU计算力进行投票，表决他们对有效区块的确认，他们不断延长有效的区块链来表达自己的确认，并拒绝在无效的区块之后延长区块以表示拒绝。本框架包含了一个P2P电子货币系统所需要的全部规则和激励措施。</p><p>1.W Dai（戴伟）,a scheme for a group of untraceable digital pseudonyms to pay each other with money and to enforce contracts amongst themselves without outside help（一种能够借助电子假名在群体内部相互支付并迫使个体遵守规则且不需要外界协助的电子现金机制）, “B-money”, <a href="http://www.weidai.com/bmoney.txt">http://www.weidai.com/bmoney.txt</a>, 1998<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-1">↵</a></p><p>2.H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,”（在最小化信任的基础上设计一种时间戳服务器） In 20th Symposium on Information Theory in the Benelux, May 1999.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-2">↵</a></p><p>3.S. Haber, W.S. Stornetta, “How to time-stamp a digital document,” （怎样为电子文件添加时间戳）In Journal of Cryptology, vol 3, No.2, pages 99-111, 1991.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-3">↵</a></p><p>4.D. Bayer, S. Haber, W.S. Stornetta, “Improving the efficiency and reliability of digital time-stamping,”（提升电子时间戳的效率和可靠性） In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-4">↵</a></p><p>5.S. Haber, W.S. Stornetta, “Secure names for bit-strings,”（比特字串的安全命名） In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. on Computer and Communications Security, pages 28-35, April 1997.<a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-5">↵</a></p><p>6.A. Back, “Hashcash - a denial of service counter-measure,”（哈希现金——拒绝服务式攻击的克制方法）<a href="http://www.hashcash.org/papers/hashcash.pdf">http://www.hashcash.org/papers/hashcash.pdf</a>, 2002. <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-6">↵</a></p><p>7.R.C. Merkle, “Protocols for public key cryptosystems,” （公钥密码系统的协议）In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980. S. Haber, W.S. Stornetta, “Secure names for bit-strings,”（比特字串安全命名） In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997. on Computer and Communications Security, pages 28-35, April 1997. H. Massias, X.S. Avila, and J.-J. Quisquater, “Design of a secure timestamping service with minimal trust requirements,”（在最小化信任的条件下设计一种时间戳服务器） In 20th Symposium on Information Theory in the Benelux, May 1999. <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-7">↵</a></p><p>8.W. Feller, “An introduction to probability theory and its applications,” （概率学理论与应用导论）1957 <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system#refmark-8">↵</a></p><h2 id="此文转载自-https-www-8btc-com-wiki-bitcoin-a-peer-to-peer-electronic-cash-system"><a href="#此文转载自-https-www-8btc-com-wiki-bitcoin-a-peer-to-peer-electronic-cash-system" class="headerlink" title="此文转载自 https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system"></a>此文转载自 <a href="https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system">https://www.8btc.com/wiki/bitcoin-a-peer-to-peer-electronic-cash-system</a></h2>]]></content>
    
    
    <categories>
      
      <category>区块链</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript小记---01</title>
    <link href="/2021/07/28/JavaScript%E5%B0%8F%E8%AE%B001/"/>
    <url>/2021/07/28/JavaScript%E5%B0%8F%E8%AE%B001/</url>
    
    <content type="html"><![CDATA[<h1 id="Array-apply-null-length-20-map"><a href="#Array-apply-null-length-20-map" class="headerlink" title="Array.apply(null, { length 20 }).map()"></a>Array.apply(null, { length 20 }).map()</h1><p>参考链接 <a href="https://blog.csdn.net/qq_20794095/article/details/103244977">https://blog.csdn.net/qq_20794095/article/details/103244977</a></p><p>本质是<strong>函数式编程</strong>的<strong>循环方法</strong>。</p><p>就是一种<strong>循环方法</strong>，你用<code>for</code>循环代替，效果也是一样的，但是<code>Array.apply(null, &#123; length: 20 &#125;).map()</code>算是<strong>函数式编程</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.cardloading = <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>(<span class="hljs-number">20</span>)).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br><span class="hljs-built_in">this</span>.eploading = <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>(<span class="hljs-number">20</span>)).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这就是简单的<strong>函数式循环</strong>。然而重点其实是前面<strong>需要循环的数组</strong>，如何<strong>优雅</strong>的产生。</p><p>如果我们想循环<code>20</code>次，直接写一个<code>0</code>到<code>20</code>的数组，结合<code>forEach</code>是可以的，但是未免显得有些拙略,</p><p>可以使用<code>js</code>内置函数<code>Array()</code>来生成一个<strong>指定长度</strong>的数组，这样子只需要指定长度就能循环了</p><p>直接使用<code>Array()</code>可以生成指定长度的数组，但是会有一个问题：<strong>数组里面的值都是没有初始化的</strong>！！重要的是，你<strong>拿不到循环的索引</strong>，因为里面的<code>key</code>和<code>value</code>都是<code>empty</code>状态</p><p>为了解决<code>index</code>无法获取的问题，我们可以<strong>在<code>Array()</code>初始化的时候传入数值</strong></p><h3 id="主要用户操作数组"><a href="#主要用户操作数组" class="headerlink" title="主要用户操作数组"></a>主要用户操作数组</h3><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul><li><p>传入  <strong>2</strong>     个参数的时候是删除    (第一个参数是要删除元素的位置,    第二个参数是要删除的元素数量)</p></li><li><p>传入 <strong>3</strong>    个参数可执行插入操作    (第一个参数是要参入的位置,    第二个参数任然是要删除的元素的数量在插入操作中是0,    第三个参数是想要插入的元素—-可以很多个) </p><ul><li>注意当 第二个参数为     <strong>1</strong>    便是替换操作了</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是模块化开发,为什么需要模块化开发?</title>
    <link href="/2021/07/26/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <url>/2021/07/26/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><blockquote><p>前端模块化的本质就是组件化、复用性，是为了提高开发效率而生的。</p><p><strong>将独立的功能代码封装成一个独立的文件在需要的时候引用它</strong></p><p>在网站发展的早期，前端页面上的JavaScript仅是用来做页面逻辑交互和表单验证的，随着Web2.0的兴起，各种前端技术也层出不穷，前端代码越来越臃肿了。而JavaScript由于设计时的定位问题，导至没有“类”的概念，导致以前的JS代码写的都很分散，没有“模块化”的思想。</p><p>那时我们开发网站，前端页面就存在一个“复用性”的问题，比如你写了给网站A写了一个表单验证处理逻辑，等开发网站B时还是存在表单验证逻辑，还需要再次写代码，浪费精力。</p><p>虽然可以写成公共函数库，但不可避免的存在多个函数库某个函数命名冲突的情况，所以前端“工程化”难以实现。这时，国外很多大牛就意识到“模块化”的重要性了，于是推出了不少模块化的实现框架。</p><p>前端模块化能给我们带来以下便利：</p><p>组件化，提高生产力，代码扩展性强；</p><p>解决了命名冲突，减少了全局空间的污染；</p><p>解决了文件依懒问题，让开发者关注于业务的实现。</p><p>最后，不管项目的大小，我觉得模块化都是很有必要的</p></blockquote><h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><p>先看伴随 nodejs 而诞生的 commonjs 规范。commonjs 规范应用于 nodejs 应用中，在 nodejs 应用中每个文件就是一个模块，拥有自己的作用域，文件中的变量、函数都是私有的，与其他文件相隔离。</p><p>CommonJS规范规定，每个模块内部， <code>module 变量代表当前模块。这个变量是一个对象</code>，它的 exports 属性（即 module.exports ）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。（引用阮一峰老师的描述）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// util\index.js</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;now&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>;<br><br><span class="hljs-keyword">let</span> fun = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;into fun&#x27;</span>);<br>    name = <span class="hljs-string">&#x27;change&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    name,<br>    fun<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>)<br><br><span class="hljs-comment">// appJsBridge\index.js</span><br><span class="hljs-keyword">var</span> &#123; name, fun &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util/index.js&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>上面这个文件有两个变量，一个函数，通过 module.exports 暴露变量 name 和函数 fun ,age 这个变量就是私有的，外部无法直接访问，如果想让 age 变量全局都可以访问，那么可以改成 global.age = 18 ，但这样子会污染全局作用域，</p><p>module 中有这些属性</p><p>module.id 模块的识别符，<code>通常是带有绝对路径的模块文件名</code>。<code>module.filename</code> 模块的文件名，带有绝对路径。<code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。<code>module.parent</code> 返回一个<code>module</code>对象，表示调用该模块的模块，如果改该模块没有被引用，那么 <code>parent</code> 就是 <code>null module.children</code> 返回一个<code>module</code>数组，表示该模块要用到的其他模块。<code>module.exports</code> 表示模块对外输出的值。<code>module.paths</code> 这个用于 <code>require</code> 查找该文件的位置。</p><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>既然有 module.exports 导出，那么就有与之相对应的 require 导入，如下</p><p><code>var &#123; name, fun, object &#125; = require(&#39;./util/index.js&#39;) // 不用解构，直接导出对象也可以使用</code> require 我们最关心的就是文件路径，这里还是引用阮一峰老师的解释</p><h2 id="module-exports-和-exports"><a href="#module-exports-和-exports" class="headerlink" title="module.exports 和 exports"></a>module.exports 和 exports</h2><p>我们还可以导出 exports 直接使用，但需要注意一点，exports 是已经定义的常量，在导出的时候不能在给它定义，如下</p><p>let exports = module.exports // 错误 #region exports  Identifier ‘exports’ has already been declared<br>exports = module.exports; // 正确的</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h2><p><strong>commonjs 规范是在运行时加载的，在运行时导出对象，导出的对象与原本模块中的对象是隔离的，简单的说就是克隆了一份。看下面这个栗子</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// util\index.js</span><br><span class="hljs-keyword">let</span> object = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">let</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;modules obj&#x27;</span>, object);<br>    object = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">99</span> &#125;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    fun,<br>    object<br>&#125;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">var</span> &#123; name, fun, object &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./util/index.js&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before fun&#x27;</span>, object)<br>fun()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;end fun&#x27;</span>, object)<br><br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">before fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>modules obj &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>end fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br></code></pre></td></tr></table></figure><p>引用方调用了导出的 fun 方法，fun 方法改变了模块中的 object 对象，可是在 index.js 中导出的 object 对象并没有发生改变，所以可见 commonjs 规范下模块的导出是深克隆的。</p><h2 id="注意我觉得上面的说法有些不完全正确"><a href="#注意我觉得上面的说法有些不完全正确" class="headerlink" title="注意我觉得上面的说法有些不完全正确"></a>注意我觉得上面的说法有些不完全正确</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">let</span> object = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-keyword">let</span> fun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;modules obj&#x27;</span>, object);<br>    object.age=<span class="hljs-number">12</span><br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    fun,<br>    object<br>&#125;<br><br><span class="hljs-comment">// index02.js</span><br><span class="hljs-keyword">var</span> &#123; fun, object &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;before fun&#x27;</span>, object)<br>fun()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;end fun&#x27;</span>, object)<br></code></pre></td></tr></table></figure><p>测试结果如下, 这结果说明能改变 ===&gt;&gt;&gt;此处保留求解各位!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">before fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>modules obj &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">10</span> &#125;<br>end fun &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">12</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><p>ECMA推出了官方标准的模块化解决方案，使用 export 导出，import 导入，编码简洁，从语义上更加通俗易懂。</p><p>ES6 支持异步加载模块 的模块不是对象，而是在编译的时候就完成模块的引用，所以是编译时才加载的。</p><blockquote><p>阮一峰老师的话</p><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p></blockquote><h2 id="ES6-模块规范和-commonjs-规范-运行机制的区别"><a href="#ES6-模块规范和-commonjs-规范-运行机制的区别" class="headerlink" title="ES6 模块规范和 commonjs 规范 运行机制的区别"></a>ES6 模块规范和 commonjs 规范 运行机制的区别</h2><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</p><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul><p>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</p><h2 id="AMD-require-js-和-CMD-sea-js"><a href="#AMD-require-js-和-CMD-sea-js" class="headerlink" title="AMD-require.js 和 CMD-sea.js"></a>AMD-require.js 和 CMD-sea.js</h2><p>聊到 AMD 和 CMD 这两个规范都离不开 require.js 和 sea.js，这是早些年，为了解决浏览器异步加载模块而诞生的方案。随着打包工具的发展，commonjs和es6都可以在浏览器上运行了，所以 AMD、CMD 将逐渐被替代。</p><p>AMD规范的模块化：用 require.config()指定引用路径等，用define()定义模块，用require()加载模块。</p><p>CMD规范的模块化：用define()定义模块， seajs.use 引用模块。</p><h2 id="AMD和require-js"><a href="#AMD和require-js" class="headerlink" title="AMD和require.js"></a>AMD和require.js</h2><p>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p><h2 id="CMD和sea-js"><a href="#CMD和sea-js" class="headerlink" title="CMD和sea.js"></a>CMD和sea.js</h2><p>require.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><h3 id="1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。"><a href="#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。" class="headerlink" title="1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ul><h3 id="2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。"><a href="#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。" class="headerlink" title="2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>部署vue +koa+nginx前后端分离项目到服务器</title>
    <link href="/2021/07/05/vue-koa/"/>
    <url>/2021/07/05/vue-koa/</url>
    
    <content type="html"><![CDATA[<h1 id="部署vue-koa-nginx前后端分离项目到服务器"><a href="#部署vue-koa-nginx前后端分离项目到服务器" class="headerlink" title="部署vue +koa+nginx前后端分离项目到服务器"></a>部署vue +koa+nginx前后端分离项目到服务器</h1><h5 id="因为遇到很多坑-百度了很多-记录一下-方便以后回看-也希望这篇文章能够帮到需要的人"><a href="#因为遇到很多坑-百度了很多-记录一下-方便以后回看-也希望这篇文章能够帮到需要的人" class="headerlink" title="因为遇到很多坑,百度了很多,记录一下,方便以后回看,也希望这篇文章能够帮到需要的人"></a>因为遇到很多坑,百度了很多,记录一下,方便以后回看,也希望这篇文章能够帮到需要的人</h5><p>先上正确部署，</p><ol><li><p>部署前先确保本地可以跑起来，在打包前对自己项目的修改=&gt;把baseurl 修改成<strong>自己的ip地                址</strong>，原来可能类似这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// axios 配置接口默认路径</span><br>axios.defaults.baseURL = <span class="hljs-string">&#x27;http://127.0.0.1:8888/api/&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>cd到自己的项目目录下  <code>npm run build </code> 就行打包，右侧就会出来打包后的文件夹<strong>dist</strong>，这些是自己的静态资源。前端到这里打包完成。在自己的服务器上新建个文件夹例如/www/demo，这个目录就是我们网站的根目录了。可以选择通过xshell 自带的xftp，也可以直接用宝塔面板把本地的dist文件夹上传到服务器。</p></li><li><p><strong>这里使用的是阿里云服务器，通过xhell 连接操作服务器，并且使用宝塔Linux操作面板方便安装一些环境，对新手十分友好，就像软件商店一样简单。</strong></p></li><li><p>nginx 的安装，nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。宝塔操作面板软件商店一键安装，我们只需要关心nginx的配置问题<br><img src="https://img-blog.csdnimg.cn/20210307121212315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>nginx的使用<code>cd /usr/local/nginx/sbin</code>。一些命令<code> ./nginx  启动</code>，<code>./nginx -s stop 停止</code>，<code> ./nginx  -s reload 重启</code>，当修改完配置文件记得重新启动nginx</p></li><li><p>nginx的配置，<strong>nginx.conf</strong>  。可以通过<code>vim /etc/nginx/nginx.conf</code>编辑</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">server<br>   &#123;<br>       listen 80;  <span class="hljs-comment">#监听的端口号</span><br>       server_name <span class="hljs-comment">#自己服务器的ip地址;  </span><br>       index index.html index.htm index.php;  <span class="hljs-comment">#默认页面</span><br>       root  /www/demo/dist; <span class="hljs-comment"># 自己项目的根目录，不知道的看上的打包</span><br></code></pre></td></tr></table></figure></li><li><p>部署后端项目，把本地文件夹上传至服务器，本地原来是通过node  app.js来运行一个服务部署到服务器，也就相当于在服务器上运行一个进程。注意需要端口号的开放。去阿里云的实例控制台对安全组就行管理，开放你需要的端口号。查看正在运行的端口<code>netstat -ntlp</code>常用。</p></li><li><p>使用pm2 管理后端接口，<br> 安装pm2</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install pm2 -g<br></code></pre></td></tr></table></figure><p> 开启服务pm2</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 start app.js                //启动app.js应用<br></code></pre></td></tr></table></figure><p> 停止服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 stop all               //停止所有应用<br>pm2 stop [AppName]        //根据应用名停止指定应用<br>pm2 stop [ID]             //根据应用id停止指定应用<br></code></pre></td></tr></table></figure><p> 自启动 <code>pm2 startup</code></p><h5 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h5></li></ol><hr><p>因为在项目中使用了WebSocket,部署是遇见这个报错,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">WebSocket connection to <span class="hljs-string">&#x27;ws://*********&#x27;</span> failed: <span class="hljs-built_in">Error</span> <span class="hljs-keyword">in</span> connection establishment: net::ERR_CONNECTION_TIMED_OUT<br></code></pre></td></tr></table></figure><p>解决方案 :  运行下面代码关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop firewalld.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>Koa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git的学习笔记</title>
    <link href="/2021/07/04/learn-git01/"/>
    <url>/2021/07/04/learn-git01/</url>
    
    <content type="html"><![CDATA[<h2 id="git的学习与使用"><a href="#git的学习与使用" class="headerlink" title="git的学习与使用"></a>git的学习与使用</h2><p>学习源,有很多===&gt;&gt;&gt;</p><p>例: 廖雪峰官方网站 ——<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都 花在了提交补丁和保存归档的繁琐事务上（1991－2002 年间）。到 2002 年， Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了， 于是整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。 到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的 合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社 区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属 于自己的版本控制系统才不至于重蹈覆辙。</p><p>SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时 候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后 干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是 必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网 下，如果网速慢的话，就郁闷了。</p><p><img src="http://47.100.67.62:9002/2021/07/04/c83eebf707bb7.png"></p><p>Git 是分布式版本控制系统，那么它可以没有中央服务器的，每个人的电脑 就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？ 比如说自己在电脑上改了文件 A，其他人也在电脑上改了文件 A，这时，你们两 之间只需把各自的修改推送给对方，就可以互相看到对方的修改了</p><p><img src="http://47.100.67.62:9002/2021/07/04/be01beffe18b1.png"></p><p><img src="http://47.100.67.62:9002/2021/07/04/b65d052e3725b.png"></p><p><img src="http://47.100.67.62:9002/2021/07/04/239c8ab06f4ba.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 遇到的部署问题</title>
    <link href="/2021/07/04/hexo-bug/"/>
    <url>/2021/07/04/hexo-bug/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-遇到的部署问题"><a href="#hexo-遇到的部署问题" class="headerlink" title="hexo 遇到的部署问题"></a>hexo 遇到的部署问题</h1><p>下面是一些常用的 hexo 命令</p><ul><li>hexo   g  -d   //   生成静态文件并部署</li><li>hexo  s    //  本地运行</li><li>hexo clean  //   清理配置文件</li></ul><p><strong>出现问题的原因是  git 没有配置系统变量</strong></p><p>本来系统是有的,因为win10更新导致系统变量好多 都丢失了  也不知道为什么  node 的环境变量也没了</p><p>直接上解决方案===&gt;&gt;&gt;<br><strong>解决方案一</strong><br>    重新配置环境变量  然后就可以了<br><strong>解决方案二</strong><br>    到 hexo 的根目录下 右键 git bash  ;  在git bash  里面执行 hexo d 就能完成部署了</p>]]></content>
    
    
    <categories>
      
      <category>遇到的问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware安装Centos7,Centos7下配置DNS服务器,配置WEB服务器,配置FTP服务器</title>
    <link href="/2021/06/23/VMware/"/>
    <url>/2021/06/23/VMware/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Centos7-VMware安装CentOS7超详细版"><a href="#安装Centos7-VMware安装CentOS7超详细版" class="headerlink" title="安装Centos7, VMware安装CentOS7超详细版"></a>安装Centos7, <a href="https://blog.csdn.net/tsundere_x/article/details/104263100">VMware安装CentOS7超详细版</a></h2><ul><li>安装系统的时候 简单点可以直接选择默认的自动分区</li><li>网络那里一定要配置,好多小伙伴总是连不上网，安装时连接上，后面都没问题</li></ul><hr><h2 id="Centos7-下配置DNS服务器"><a href="#Centos7-下配置DNS服务器" class="headerlink" title="Centos7 下配置DNS服务器"></a>Centos7 下配置DNS服务器</h2><p>centos7上安装DNS服务器可以实现域名与IP的双向解析，即通过域名可以找到主机IP，也可以通过IP找到域名。经历了多次失败,多次重装系统,简直不要太苦涩，对于重装系统的操作熟练的让人伤心。</p><ul><li><p>查看本机ip  <code>ip addr</code>  一般在ens33 ip长得类似这样 <code>192.168.202.129</code></p></li><li><p>安装bind  <code>yum install bind bind-utils -y</code></p></li><li><p>安装完成，可以查看named服务。  <code>systemctl status named</code></p></li><li><p>开始修改配置文件 <code>vim /etc/named.conf</code><img src="https://img-blog.csdnimg.cn/20210515101507936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>配置/etc/named.rfc1912.zones，增加一个正向解析与一个反向解析的配置，可以拷贝其他的zone 配置 ，下面的test.com也就是域名 改成自己想要的就可以了test.com 是例子</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -p named.localhost test.com.zone<br>cp -p named.loopback test.com.local<br></code></pre></td></tr></table></figure></li><li><p>有了两个文件，我们需要做修改，这里非常重要，因为文件格式在拷贝过程中可能会发生变化。<code>192.168.202.129</code>  129指的是ip最后的三位。下图是    <code>.zone   是域名的正向解析</code><br><img src="https://img-blog.csdnimg.cn/20210515103557564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下图是    <code>.local   是域名的反向解析</code><br><img src="https://img-blog.csdnimg.cn/20210515102618841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>配置本机DNS1，修改<code>/etc/sysconfig/network-scripts/ifcfg-en0或者/etc/sysconfig/network-scripts/ifcfg-ens33，</code><br>增加<code>DNS1=192.168.202.129</code></p></li><li><p>重启网络，启动named服务。named:<code>systemctl start named</code><br>网络：<code>service network restart</code></p></li><li><p>修改配置文件：<code>vim /etc/resolv.conf</code></p></li><li><p>进行验证 <code>nslookup www.域名    /      nslookup 192.168.202.129</code> </p><h6 id="大功告成-呼"><a href="#大功告成-呼" class="headerlink" title="大功告成  呼~~~"></a>大功告成  呼~~~</h6></li></ul><hr><h2 id="Centos7下配置WEB服务器"><a href="#Centos7下配置WEB服务器" class="headerlink" title="Centos7下配置WEB服务器"></a>Centos7下配置WEB服务器</h2><p> Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以处理浏览器等Web客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主流的三个Web服务器是Apache、 Nginx 、IIS</p><ul><li><p>安装Apache服务  <code>yum install -y httpd</code></p></li><li><p>启动Apache服务  <code>ystemctl start httpd.service </code></p></li><li><p>切换目录 <code>cd /var/www</code></p></li><li><p>新建目录 <code>mkdir web</code></p></li><li><p>新建index.html    <code>echo &quot;this is web&quot; &gt; web/index.html</code></p></li><li><p> 修改配置文件 <code>在/etc/httpd/conf/httpd.conf</code><img src="https://img-blog.csdnimg.cn/20210515104831208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p> 打开自己 浏览器进行测试<img src="https://img-blog.csdnimg.cn/20210515105335176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="大功告成-呼-1"><a href="#大功告成-呼-1" class="headerlink" title="大功告成 呼~~~"></a>大功告成 呼~~~</h6></li></ul><hr><h2 id="Centos7下配置FTP服务器"><a href="#Centos7下配置FTP服务器" class="headerlink" title="Centos7下配置FTP服务器"></a>Centos7下配置FTP服务器</h2><p>FTP服务器（File Transfer Protocol Server）是在互联网上提供文件存储和访问服务的计算机，它们依照FTP协议提供服务。 FTP是File Transfer Protocol(文件传输协议)。顾名思义，就是专门用来传输文件的协议。简单地说，支持FTP协议的服务器就是FTP服务器</p><ul><li>安装vsftpd  <code>yum -y install vsftpd</code></li><li>按照下面修改配置文件  <code>vim vsftpd.conf</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#是否允许匿名，默认no</span><br><span class="hljs-attribute">anonymous_enable</span>=<span class="hljs-literal">NO</span><br><br><span class="hljs-comment">#这个设定值必须要为YES 时，在/etc/passwd内的账号才能以实体用户的方式登入我们的vsftpd主机</span><br><span class="hljs-attribute">local_enable</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#具有写权限</span><br><span class="hljs-attribute">write_enable</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#本地用户创建文件或目录的掩码</span><br><span class="hljs-attribute">local_umask</span>=022<br><br><span class="hljs-comment">#当dirmessage_enable=YES时，可以设定这个项目来让vsftpd寻找该档案来显示讯息！您也可以设定其它档名！</span><br><span class="hljs-attribute">dirmessage_enable</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#当设定为YES时，使用者上传与下载日志都会被纪录起来。记录日志与下一个xferlog_file设定选项有关：</span><br><span class="hljs-attribute">xferlog_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">xferlog_std_format</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#上传与下载日志存放路径</span><br><span class="hljs-attribute">xferlog_file</span>=/var/log/xferlog<br><br><span class="hljs-comment">#开启20端口</span><br><span class="hljs-attribute">connect_from_port_20</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#关于系统安全的设定值：</span><br><span class="hljs-attribute">ascii_download_enable</span>=<span class="hljs-literal">YES</span>(NO)<br>如果设定为<span class="hljs-literal">YES</span> ，那么<span class="hljs-built_in"> client </span>就可以使用 ASCII 格式下载档案。<br>一般来说，由于启动了这个设定项目可能会导致DoS 的攻击，因此预设是<span class="hljs-literal">NO</span>。<br><span class="hljs-attribute">ascii_upload_enable</span>=<span class="hljs-literal">YES</span>(NO)<br>与上一个设定类似的，只是这个设定针对上传而言！预设是<span class="hljs-literal">NO</span>。<br><span class="hljs-attribute">ascii_upload_enable</span>=<span class="hljs-literal">NO</span><br><span class="hljs-attribute">ascii_download_enable</span>=<span class="hljs-literal">NO</span><br><br><span class="hljs-comment">#通过搭配能实现以下几种效果：</span><br>①当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">YES</span>，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。<br>②当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">YES</span>，chroot_local_user=NO时，<br>在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。<br>③当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">NO</span>，<br><span class="hljs-attribute">chroot_local_user</span>=<span class="hljs-literal">YES</span>时，所有的用户均不能切换到其他目录。<br>④当<span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">NO</span>，<br><span class="hljs-attribute">chroot_local_user</span>=<span class="hljs-literal">NO</span>时，所有的用户均可以切换到其他目录。<br><br><span class="hljs-attribute">chroot_local_user</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">chroot_list_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-attribute">chroot_list_file</span>=/etc/vsftpd/chroot_list<br><br><span class="hljs-comment">#这个是pam模块的名称，我们放置在/etc/pam.d/vsftpd</span><br><span class="hljs-attribute">pam_service_name</span>=vsftpd<br><br><span class="hljs-comment">#当然我们都习惯支持TCP Wrappers的啦！</span><br><span class="hljs-attribute">tcp_wrappers</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#不添加下面这个会报错：500 OOPS: vsftpd: refusing to run with writable root inside chroot()</span><br><span class="hljs-attribute">allow_writeable_chroot</span>=<span class="hljs-literal">YES</span><br><br><span class="hljs-comment">#ftp的端口号</span><br><span class="hljs-attribute">listen_port</span>=60021<br><span class="hljs-comment">#启动被动式联机(passivemode)</span><br><span class="hljs-attribute">pasv_enable</span>=<span class="hljs-literal">YES</span><br><span class="hljs-comment">#上面两个是与passive mode 使用的 port number 有关，如果您想要使用65400 到65410 这 11 个 port 来进行被动式资料的连接，可以这样设定</span><br><span class="hljs-attribute">pasv_min_port</span>=65400<br><span class="hljs-attribute">pasv_max_port</span>=65410<br><br><span class="hljs-comment">#FTP访问目录</span><br><span class="hljs-attribute">local_root</span>=/data/ftp/<br></code></pre></td></tr></table></figure><ul><li>启动暂停查看服务状态命令 </li><li><code>启动systemctl start vsftpd.service</code>  </li><li><code>暂停 systemctl status vsftpd.service</code></li><li>创建FTP用户<br> 添加FTP用户命令：useradd XXX<br>  设置FTP用户密码：passwd XXX</li></ul><h6 id="完结-呼"><a href="#完结-呼" class="headerlink" title="完结 呼~~~"></a>完结 呼~~~</h6><hr>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Centos7</tag>
      
      <tag>VMware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式的学习</title>
    <link href="/2021/06/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/06/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="正则表达式的学习"><a href="#正则表达式的学习" class="headerlink" title="正则表达式的学习"></a>正则表达式的学习</h3><blockquote><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p><p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><p>正则表达式是繁琐的，但它是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真阅读本教程，加上应用的时候进行一定的参考，掌握正则表达式不是问题。</p><p>许多程序设计语言都支持利用正则表达式进行字符串操作。</p></blockquote><ul><li>从字符串 str 中提取数字部分的内容(匹配一次)：<code>/[0-9]+/;</code></li><li><strong>?</strong> 通配符匹配文件名中的 0 个或 1 个字符，而 ***** 通配符匹配零个或多个字符。像 <strong>data(\w)?.dat</strong> 这样的模式将查找下列文件：</li><li><strong>^</strong> 为匹配输入字符串的开始位置。</li><li><strong>[0-9]+<strong>匹配多个数字， <strong>[0-9]</strong> 匹配单个数字，</strong>+</strong> 匹配一个或者多个。</li><li><strong>abc$<strong>匹配字母 <strong>abc</strong> 并以 <strong>abc</strong> 结尾，</strong>$</strong> 为匹配输入字符串的结束位置。</li><li>我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用以下正则表达式来设定。<strong>^[a-z0-9_-]{3,15}$</strong></li><li>匹配以数字开头,abc结尾的字符串       <strong>/^[0-9]+abc$/</strong></li><li><strong>runoo+b</strong>，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</li><li><strong>runoo*b</strong>，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li><li><strong>colou?r</strong> 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</li><li>[\s\S] 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</li><li>\w     匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</li><li>[A-Z]             [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</li></ul><h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 <strong>**，**runo*ob</strong> 匹配字符串 <strong>runo*ob</strong>。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符*<em>*</em> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td align="left">( )</td><td align="left"><strong>标记一个子表达式的开始和结束位置</strong>。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td align="left">.</td><td align="left"><strong>匹配除换行符 \n 之外的任何单字符</strong>。要匹配 . ，请使用 . 。</td></tr><tr><td align="left">[</td><td align="left"><strong>标记一个中括号表达式的开始</strong>。要匹配 [，请使用 [。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left">\</td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left"><strong>匹配输入字符串的开始位置</strong>，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td align="left">{</td><td align="left">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td align="left">|</td><td align="left"><strong>指明两项之间的一个选择</strong>。要匹配 |，请使用 |。</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式<strong>零次或多次</strong>。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式<strong>一次或多次</strong>。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式<strong>零次或一次</strong>。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。<strong>最少匹配 n 次且最多匹配 m 次</strong>。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p><strong>[1-9]<strong>设置第一个数字不是 0，</strong>[0-9]*</strong> 表示任意多个数字：<code>/[1-9][0-9]*</code></p><p>*<strong>和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。</strong></p><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table><p>匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：</p><p><strong>\b</strong> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p><ul><li>**exp1(?=exp2)**：查找 exp2 前面的 exp1。</li><li><strong>(?&lt;=exp2)exp1</strong>：查找 exp2 后面的 exp1。</li><li>**exp1(?!exp2)**：查找后面不是 exp2 的 exp1。</li><li><strong>(?&lt;!exp2)exp1</strong>：查找前面不是 exp2 的 exp1。</li></ul><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力</p><h1 id="正则表达式-修饰符（标记）"><a href="#正则表达式-修饰符（标记）" class="headerlink" title="正则表达式 - 修饰符（标记）"></a>正则表达式 - 修饰符（标记）</h1><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/pattern/</span>flags<br></code></pre></td></tr></table></figure><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h1 id="正则表达式-元字符"><a href="#正则表达式-元字符" class="headerlink" title="正则表达式 - 元字符"></a>正则表达式 - 元字符</h1><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="left">?</td><td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td></tr><tr><td align="left">(pattern)</td><td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td align="left">(?:pattern)</td><td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td align="left">(?=pattern)</td><td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?!pattern)</td><td align="left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?&lt;=pattern)</td><td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95</td></tr><tr><td align="left">(?&lt;!pattern)</td><td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95</td></tr><tr><td align="left">x|y</td><td align="left">匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td align="left">[xyz]</td><td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td align="left">[^xyz]</td><td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td align="left">[a-z]</td><td align="left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td align="left">[^a-z]</td><td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\cx</td><td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td align="left">\xn</td><td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td align="left">\num</td><td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td align="left">\n</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td align="left">\nm</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td align="left">\nml</td><td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td align="left">\un</td><td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h1 id="正则表达式-运算符优先级"><a href="#正则表达式-运算符优先级" class="headerlink" title="正则表达式 - 运算符优先级"></a>正则表达式 - 运算符优先级</h1><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><p>下面列出一些正则表达式示例：</p><table><thead><tr><th align="left">正则表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">/\b([a-z]+) \1\b/gi</td><td align="left">一个单词连续出现的位置。</td></tr><tr><td align="left">/(\w+)://([^/:]+)(:\d*)?([^# ]*)/</td><td align="left">将一个URL解析为协议、域、端口及相对路径。</td></tr><tr><td align="left">/^(?:Chapter|Section) [1-9][0-9]{0,1}$/</td><td align="left">定位章节的位置。</td></tr><tr><td align="left">/[-a-z]/</td><td align="left">a至z共26个字母再加一个-号。</td></tr><tr><td align="left">/ter\b/</td><td align="left">可匹配chapter，而不能匹配terminal。</td></tr><tr><td align="left">/\Bapt/</td><td align="left">可匹配chapter，而不能匹配aptitude。</td></tr><tr><td align="left">/Windows(?=95 |98 |NT )/</td><td align="left">可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。</td></tr><tr><td align="left">/^\s*$/</td><td align="left">匹配空行。</td></tr><tr><td align="left">/\d{2}-\d{5}/</td><td align="left">验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</td></tr><tr><td align="left">/&lt;\s*(\S+)(\s[^&gt;]<em>)?&gt;[\s\S]</em>&lt;\s*/\1\s*&gt;/</td><td align="left">匹配 HTML 标记。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新手小白入门前后端分离-持续更新</title>
    <link href="/2021/04/13/%E6%96%B0%E6%89%8B%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2021/04/13/%E6%96%B0%E6%89%8B%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前后端分离-前端做前端的-后端做后端的-前端用-axios-调用后端的接口进行交互"><a href="#前后端分离-前端做前端的-后端做后端的-前端用-axios-调用后端的接口进行交互" class="headerlink" title="前后端分离,前端做前端的,后端做后端的.     前端用 axios 调用后端的接口进行交互"></a>前后端分离,前端做前端的,后端做后端的.     前端用 axios 调用后端的接口进行交互</h2><p>前端的目录结构<br>build – 构建相关<br>config – 配置<br>assets – 静态资源<br>components – 全局公用组件<br>router – 路由<br>utils – 公用方法<br>APP.vue – 入口页面<br>main.js – 入口文件，加载组件和初始化<br>static – 静态资源<br><img src="https://img-blog.csdnimg.cn/20210706134306321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"># 在这个项目中,components 下直接写的 前端页面,不是公用组件;<br>router.js 是前端的 页面管理, 注意这跟后端一点关系没有,  每一个 path 就是前端能访问的页面,(用户能访问的页面)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs javascript">routes: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;登录&#x27;</span>,<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">component</span>: Login<br>  &#125;, &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span><br>  &#125;, &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;文章管理&#x27;</span>,<br>    <span class="hljs-attr">iconCls</span>: <span class="hljs-string">&#x27;fa fa-file-text-o&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/articleList&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;文章列表&#x27;</span>,<br>        <span class="hljs-attr">component</span>: ArticleList,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span><br>        &#125;<br>      &#125;, &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/postArticle&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;发表文章&#x27;</span>,<br>        <span class="hljs-attr">component</span>: PostArticle,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;, &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/blogDetail&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;博客详情&#x27;</span>,<br>        <span class="hljs-attr">component</span>: BlogDetail,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;, &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/editBlog&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;编辑博客&#x27;</span>,<br>        <span class="hljs-attr">component</span>: PostArticle,<br>        <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">meta</span>: &#123;<br>          <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;用户管理&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>        <span class="hljs-attr">iconCls</span>: <span class="hljs-string">&#x27;fa fa-user-o&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;用户管理&#x27;</span>,<br>        <span class="hljs-attr">component</span>: UserMana<br>      &#125;<br>    ]<br>  &#125;, <br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: Home,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;栏目管理&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/cateMana&#x27;</span>,<br>        <span class="hljs-attr">iconCls</span>: <span class="hljs-string">&#x27;fa fa-reorder&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;栏目管理&#x27;</span>,<br>        <span class="hljs-attr">component</span>: CateMana<br>      &#125;<br>    ]<br>  &#125;, <br>]<br></code></pre></td></tr></table></figure><blockquote><p>   <a href="http://localhost:8080/#/">http://localhost:8080/#/</a>    井号后面开始的path<br>   看这个路径意思就是当访问path: ‘/‘, 根目录的时候==&gt;&gt;显示 component: Login Login页面</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;登录&#x27;</span>,<br>  <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">component</span>: Login<br>&#125;,<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210706140040496.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021070614000446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlaWNoZW55dW1v,size_16,color_FFFFFF,t_70" alt="这个页面"></p><h3 id="axios和接口封装"><a href="#axios和接口封装" class="headerlink" title="axios和接口封装:"></a>axios和接口封装:</h3><blockquote><p>在前后端交互方面采用axios，为了便于维护和复用，避免每个页面都引入一次axios和qs、避免每个接口都进行请求头配置，我们可以对axios进行封装。</p></blockquote><p>例子get方法的封装, 例子如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装get请求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">url</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-variable">params</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Promise&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">url, params = &#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    axios.get(url, &#123;<br>      <span class="hljs-attr">params</span>: params<br>    &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(response);<br>      <br>      resolve(response.data)<br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>      reject(error)<br>    &#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们解析一下项目中的代码, 项目的代码如下,同样也是把代码封装了一层<br>注意 () =&gt; {}  这是es6的箭头函数, 他就是函数跟上边的function是一样的,()括号中是这个函数的参数;<br>用axios get post 等请求.params是参数 transformRequest在向服务器发送前，修改请求数据<br>export 是把这个函数导出 ====&gt;&gt;&gt;其他地方import 引入就能直接用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getRequest = <span class="hljs-function">(<span class="hljs-params">url,params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">data</span>:params,<br>    <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;<br>        ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">&#x27;&amp;&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> ret<br>    &#125;],<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span><br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteRequest = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;delete&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span><br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> postRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>    <span class="hljs-attr">data</span>: params,<br>    <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-comment">// Do whatever you want to transform the data</span><br>      <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;<br>        ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">&#x27;&amp;&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> ret<br>    &#125;],<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> uploadFileRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>    <span class="hljs-attr">data</span>: params,<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;multipart/form-data&#x27;</span><br>    &#125;<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> putRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;put&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,<br>    <span class="hljs-attr">data</span>: params,<br>    <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">in</span> data) &#123;<br>        ret += <span class="hljs-built_in">encodeURIComponent</span>(it) + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[it]) + <span class="hljs-string">&#x27;&amp;&#x27;</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> ret<br>    &#125;],<br>    <span class="hljs-attr">headers</span>: &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript">找到登录的页面 用户输入的账号密码都通过 v-model进行双向绑定 存到了loginForm 这里<br><span class="hljs-keyword">import</span> &#123;postRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/api&#x27;</span>  通过<span class="hljs-keyword">import</span>引入封装好的方法<br>&lt;el-button type=<span class="hljs-string">&quot;primary&quot;</span> @click.native.prevent=<span class="hljs-string">&quot;submitClick&quot;</span> style=<span class="hljs-string">&quot;width: 100%&quot;</span>&gt;登录&lt;/el-button&gt;<br>这是登录的 按钮, 使用了element-ui ;  @click.native.prevent=<span class="hljs-string">&quot;submitClick&quot;</span> 绑定事件,当点击按钮的时候会触发这个方法函数.<br> <span class="hljs-string">&#x27;/login&#x27;</span>,为上方封装号的url; &#123;<span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.loginForm.username,<span class="hljs-attr">password</span>: <span class="hljs-built_in">this</span>.loginForm.password&#125;这就是要传递的参数<br>        <br>      <span class="hljs-attr">submitClick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">true</span>;<br>        postRequest(<span class="hljs-string">&#x27;/login&#x27;</span>, &#123;<br>          <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.loginForm.username,<br>          <span class="hljs-attr">password</span>: <span class="hljs-built_in">this</span>.loginForm.password<br>        &#125;).then(<span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span> &#123;<br>          _this.loading = <span class="hljs-literal">false</span>;<br>          <span class="hljs-keyword">if</span> (resp.status == <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-comment">//成功</span><br>            <span class="hljs-keyword">var</span> json = resp.data;<br>            <span class="hljs-keyword">if</span> (json.status == <span class="hljs-string">&#x27;success&#x27;</span>) &#123;<br>              _this.$router.replace(&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              _this.$alert(<span class="hljs-string">&#x27;登录失败!&#x27;</span>, <span class="hljs-string">&#x27;失败!&#x27;</span>);<br>            &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//失败</span><br>            _this.$alert(<span class="hljs-string">&#x27;登录失败!&#x27;</span>, <span class="hljs-string">&#x27;失败!&#x27;</span>);<br>          &#125;<br>        &#125;, <span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span> &#123;<br>          _this.loading = <span class="hljs-literal">false</span>;<br>          _this.$alert(<span class="hljs-string">&#x27;找不到服务器⊙﹏⊙∥!&#x27;</span>, <span class="hljs-string">&#x27;失败!&#x27;</span>);<br>        &#125;);<br>      &#125;<br>      ##############<br><span class="hljs-string">&#x27;/login&#x27;</span>  是后端的接口<br>注意 在config文件夹下的index文件中 配置了服务端的信息<br>意思就是 axios中写的url <span class="hljs-string">&#x27;/login&#x27;</span> 会和<span class="hljs-string">&#x27;http://localhost:8081&#x27;</span> 拼接在一起形成完整的服务端接口地址.<br>    <span class="hljs-comment">// Paths</span><br>    <span class="hljs-attr">assetsSubDirectory</span>: <span class="hljs-string">&#x27;static&#x27;</span>,<br>    <span class="hljs-attr">assetsPublicPath</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">proxyTable</span>: &#123;<br>      <span class="hljs-string">&#x27;/&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8081&#x27;</span>,  <span class="hljs-comment">// 本地测试</span><br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-string">&#x27;^/&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock.js的简单使用</title>
    <link href="/2021/04/01/Mockjs%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/04/01/Mockjs%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Mock-js"><a href="#Mock-js" class="headerlink" title="Mock.js"></a>Mock.js</h1><h2 id="在开发的过程中有很多需要发送请求-获取数据-可以通过Mock-js拦截ajax请求-简单的方便的构建你所需要的数据"><a href="#在开发的过程中有很多需要发送请求-获取数据-可以通过Mock-js拦截ajax请求-简单的方便的构建你所需要的数据" class="headerlink" title="在开发的过程中有很多需要发送请求,获取数据,可以通过Mock.js拦截ajax请求,简单的方便的构建你所需要的数据"></a>在开发的过程中有很多需要发送请求,获取数据,可以通过Mock.js拦截ajax请求,简单的方便的构建你所需要的数据</h2><ul><li>安装mock.js</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install mockjs --save-dev<br></code></pre></td></tr></table></figure><ul><li><p>具体 data 有什么,参阅官方文档   <a href="http://mockjs.com/examples.html">http://mockjs.com/examples.html</a></p></li><li><p>在项目中创建mock.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//引入mockjs</span><br><span class="hljs-keyword">import</span> Mock <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mockjs&#x27;</span><br><span class="hljs-comment">//使用mockjs模拟数据</span><br>Mock.mock(<span class="hljs-string">&#x27;/\/api\/msdk\/proxy\/query_common_credit/&#x27;</span>, &#123;<br>    <span class="hljs-string">&quot;ret&quot;</span>:<span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>:<br>      &#123;<br>        <span class="hljs-string">&quot;mtime&quot;</span>: <span class="hljs-string">&quot;@datetime&quot;</span>,<span class="hljs-comment">//随机生成日期时间</span><br>        <span class="hljs-string">&quot;score|1-800&quot;</span>: <span class="hljs-number">800</span>,<span class="hljs-comment">//随机生成1-800的数字</span><br>        <span class="hljs-string">&quot;rank|1-100&quot;</span>:  <span class="hljs-number">100</span>,<span class="hljs-comment">//随机生成1-100的数字</span><br>        <span class="hljs-string">&quot;stars|1-5&quot;</span>: <span class="hljs-number">5</span>,<span class="hljs-comment">//随机生成1-5的数字</span><br>        <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;@cname&quot;</span>,<span class="hljs-comment">//随机生成中文名字</span><br>      &#125;<br><span class="hljs-comment">//data里的属性看不懂，需要详细看语法规范,博客链接:https://www.jianshu.com/p/4579f40e6108</span><br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>在main.js中引入 该文档</p></li><li><p>xxx.vue文件中调用mock.js中模拟的数据接口，这时返回的response就是mock.js中用Mock.mock(‘url’,data）中设置的data了。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">query_common_credit()&#123;<br>      <span class="hljs-keyword">var</span> loginMode = <span class="hljs-string">&#x27;msdk&#x27;</span>;<span class="hljs-comment">//游戏内默认msdk(wx|qq|msdk)</span><br>      <span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;/api/msdk/proxy/query_common_credit&#x27;</span>;<br>      this.<span class="hljs-symbol">$a</span>xios.get(url)<br>        .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <br>        &#125;)<br>        .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>          <br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的学习笔记之 v-on</title>
    <link href="/2021/03/07/v-on/"/>
    <url>/2021/03/07/v-on/</url>
    
    <content type="html"><![CDATA[<p><code>v-on</code>就是<strong>用于绑定事件的</strong><br>例如：有个按钮，当点击的时候执行一些操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;app&quot;&gt;<br>    &lt;button v-on:click=&quot;myclick&quot;&gt;click me&lt;/button&gt;<br>&lt;/div&gt;  <br></code></pre></td></tr></table></figure><p><code>v-on:</code>后面的值是一个方法，可以写成<code>myclick()</code>，没有参数可以写成<code>myclick</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&#x27;.app&#x27;</span>,<br>    <span class="hljs-attr">data</span>:&#123;<br>        <br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-attr">myclick</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111111</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>v-on</code>也可以绑定多个事件<br>多个事件可以单独多个v-on绑定</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:mouseenter</span>=<span class="hljs-string">&#x27;onenter&#x27;</span> <span class="hljs-attr">v-on:mouseleave</span>=<span class="hljs-string">&#x27;leave&#x27;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;  <br></code></pre></td></tr></table></figure><h6 id="跟v-bind一样，v-on也非常常用，对应也有快捷方式："><a href="#跟v-bind一样，v-on也非常常用，对应也有快捷方式：" class="headerlink" title="跟v-bind一样，v-on也非常常用，对应也有快捷方式："></a><strong>跟<code>v-bind</code>一样，v-on也非常常用，对应也有快捷方式：</strong></h6><p><strong><code>**v-on:事件名** 可以简写为 **@事件名**</code></strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的学习笔记---vue的生命周期</title>
    <link href="/2021/03/04/learn-vue01/"/>
    <url>/2021/03/04/learn-vue01/</url>
    
    <content type="html"><![CDATA[<h2 id="vue学习小记—vue的生命周期"><a href="#vue学习小记—vue的生命周期" class="headerlink" title="vue学习小记—vue的生命周期"></a>vue学习小记—vue的生命周期</h2><p>建议学习 vue ,直接阅读官方文档就好,真的很强.</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue生命周期"></p><p><strong>beforeCreate( 创建前 )</strong></p><p>el 和data都没有初始化,无妨访问methods,data,computed上的方法和数据</p><p><strong>created ( 创建后 ）</strong></p><p>实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成</p><p><strong>beforeMount</strong></p><p>挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。</p><p><strong>mounted</strong></p><p>挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。</p><p><strong>beforeUpdate</strong></p><p>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程</p><p><strong>updated（更新后）</strong></p><p>在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用</p><p><strong>beforeDestroy（销毁前）</strong></p><p>在实例销毁之前调用，实例仍然完全可用，</p><ol><li>这一步还可以用this来获取实例，</li><li>一般在这一步做一些重置的操作，比如清除掉组件中的定时器     和 监听的dom事件</li></ol><p><strong>destroyed（销毁后）</strong></p><p>在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
